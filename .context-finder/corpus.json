{
  "schema_version": 1,
  "files": {
    ".github/ISSUE_TEMPLATE/bug_report.md": [
      {
        "file_path": ".github/ISSUE_TEMPLATE/bug_report.md",
        "start_line": 1,
        "end_line": 36,
        "content": "[LEGEND]\n\n[CONTENT]\n---\nname: Bug report\nabout: Report a problem to help us improve\nlabels: bug\n---\n## Summary\n\nDescribe the bug in 1‚Äì2 sentences.\n\n## Steps to reproduce\n\n1.\n2.\n3.\n\n## Expected behavior\n\n## Actual behavior\n\n## Environment\n\n- OS:\n- Node.js version: (`node -v`)\n- npm version: (`npm -v`)\n- MCP client (name + version):\n\n## Logs / output\n\nPaste relevant **redacted** output.\n\nNotes:\n- Do not paste secrets (tokens, passwords, private keys, `profiles.json`, `.mcp_profiles.key`).\n- For security-sensitive issues, follow `SECURITY.md` instead of opening a public issue.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 145,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    ".github/ISSUE_TEMPLATE/config.yml": [
      {
        "file_path": ".github/ISSUE_TEMPLATE/config.yml",
        "start_line": 1,
        "end_line": 5,
        "content": "blank_issues_enabled: true\ncontact_links:\n  - name: Security vulnerabilities\n    url: https://github.com/AmirTlinov/SentryFrogg-MCP/blob/master/SECURITY.md\n    about: Please do not open public issues for security reports.",
        "metadata": {
          "language": "yaml",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    ".github/ISSUE_TEMPLATE/feature_request.md": [
      {
        "file_path": ".github/ISSUE_TEMPLATE/feature_request.md",
        "start_line": 1,
        "end_line": 24,
        "content": "[LEGEND]\n\n[CONTENT]\n---\nname: Feature request\nabout: Suggest an idea for this project\nlabels: enhancement\n---\n## Problem\n\nWhat problem are you trying to solve?\n\n## Proposed solution\n\nWhat would you like to happen?\n\n## Alternatives considered\n\n## Additional context\n\nIf relevant, include:\n- MCP client details\n- Example tool calls / schemas\n- Constraints (security, compliance, environments)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 97,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    ".github/dependabot.yml": [
      {
        "file_path": ".github/dependabot.yml",
        "start_line": 1,
        "end_line": 8,
        "content": "version: 2\nupdates:\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n",
        "metadata": {
          "language": "yaml",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 35,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    ".github/pull_request_template.md": [
      {
        "file_path": ".github/pull_request_template.md",
        "start_line": 1,
        "end_line": 17,
        "content": " [LEGEND]\n\n[CONTENT]\n## What changed?\n\n## Why?\n\n## How was it verified?\n\n- [ ] `npm run check`\n- [ ] `npm test`\n\n## Notes\n\n- [ ] No secrets were committed (`profiles.json`, `.mcp_profiles.key`, tokens, private keys, etc.)\n- [ ] Docs were updated where relevant (`README.md`, `mcp_config.md`, etc.)\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    ".github/workflows/ci.yml": [
      {
        "file_path": ".github/workflows/ci.yml",
        "start_line": 1,
        "end_line": 22,
        "content": "name: CI\n\non:\n  push:\n  pull_request:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        node: [18, 20]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n          cache: npm\n      - run: npm ci\n      - run: npm run check\n      - run: npm test",
        "metadata": {
          "language": "yaml",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 95,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "AGENTS.md": [
      {
        "file_path": "AGENTS.md",
        "start_line": 1,
        "end_line": 23,
        "content": "# SentryFrogg ‚Äî Agent Rules (Golden Path)\n\nThis repo is optimized for humans + AI agents to collaborate without guesswork.\n\nGolden path:\n- Run `./tools/doctor` first (diagnose).\n- Then run `./tools/gate` (fail-closed correctness gate).\n\nDoc standard:\n- Repo-root `AGENTS.md` and repo-root `README.md` are freeform Markdown.\n- Every other `.md` doc MUST be written in the context format:\n  - A `[LEGEND]` block (definitions)\n  - A `[CONTENT]` block (uses definitions)\n\nChange protocol (contracts-first):\n1) Update contracts/interfaces first.\n2) Update implementation.\n3) Update tests.\n4) Update docs (context format).\n\nBoundaries:\n- Prefer explicit contracts over ‚Äúconventions‚Äù.\n- Prefer deterministic checks over ‚Äútribal knowledge‚Äù.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 185,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "ARCHITECTURE.md": [
      {
        "file_path": "ARCHITECTURE.md",
        "start_line": 1,
        "end_line": 8,
        "content": "[LEGEND]\nBOUNDARY = A seam where we define contracts to prevent implicit coupling.\n\n[CONTENT]\nHigh-level architecture is described via:\n- Boundaries ([BOUNDARY]) via contracts\n- Data flow (events / APIs)\n- Operational gates (doctor + gate)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "CHANGELOG.md": [
      {
        "file_path": "CHANGELOG.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# üìã CHANGELOG\n\n## [6.4.0] - 2025-12-23 - Unsafe local mode (opt-in)\n\n### Summary\n- –î–æ–±–∞–≤–ª–µ–Ω `mcp_local` (exec + filesystem) –¥–ª—è –ø–æ–ª–Ω–æ–π –∞–≤—Ç–æ–Ω–æ–º–Ω–æ—Å—Ç–∏ –∞–≥–µ–Ω—Ç–∞ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–π –º–∞—à–∏–Ω–µ.\n- –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç **–≤—ã–∫–ª—é—á–µ–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é** –∏ –ø–æ—è–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ `SENTRYFROGG_UNSAFE_LOCAL=1` (–∏–ª–∏ `SF_UNSAFE_LOCAL=1`).\n- –î–æ–±–∞–≤–ª–µ–Ω—ã —Ç–µ—Å—Ç—ã –Ω–∞ –≥–µ–π—Ç–∏–Ω–≥ `tools/list` –∏ –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ `mcp_local`, –æ–±–Ω–æ–≤–ª–µ–Ω—ã docs/SECURITY/README.\n\n### Compatibility\nAdditive –∏–∑–º–µ–Ω–µ–Ω–∏–µ: –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤ opt-in —Ä–µ–∂–∏–º–µ –∏ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É.\n\n## [6.3.0] - 2025-12-23 - Atomic persistence + audit streaming\n\n### Summary\n- –ê—Ç–æ–º–∞—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è (`profiles/state/runbooks/aliases/presets/cache`) + –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –ø—Ä–∞–≤–∞ (best-effort `0600`).\n- `download` (HTTP) –∏ `export` (Postgres) –±–æ–ª—å—à–µ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—é—Ç –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã –±–µ–∑ `overwrite: true`.\n- –ß—Ç–µ–Ω–∏–µ audit-–ª–æ–≥–∞ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ –Ω–∞ —Å—Ç—Ä–∏–º–∏–Ω–≥ (–Ω–µ –≥—Ä—É–∑–∏—Ç –≤–µ—Å—å `audit.jsonl` –≤ –ø–∞–º—è—Ç—å).\n- –°—Ö–µ–º—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∏ `docs/tools.md` —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –ø–æ `overwrite`, README —Å–ª–µ–≥–∫–∞ ¬´–æ—á–µ–ª–æ–≤–µ—á–µ–Ω¬ª.\n\n### Compatibility\n–ï—Å—Ç—å –Ω–µ–±–æ–ª—å—à–æ–µ –ø–æ–≤–µ–¥–µ–Ω—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞–ø–∏—Å–∏ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª —Ç–µ–ø–µ—Ä—å —Ç—Ä–µ–±—É—é—Ç —è–≤–Ω–æ–≥–æ `overwrite: true`.\n\n## [6.2.1] - 2025-12-23 - Security hardening + UX fixes\n\n### Summary\n- –û–±–Ω–æ–≤–ª—ë–Ω `@modelcontextprotocol/sdk` –∏ –∑–∞–∫—Ä—ã—Ç—ã —É—è–∑–≤–∏–º–æ—Å—Ç–∏ `npm audit`.\n- –£—Å–∏–ª–µ–Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å cache-–∫–ª—é—á–µ–π (–∑–∞—â–∏—Ç–∞ –æ—Ç path traversal –ø—Ä–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º `cache.key`).\n- –ü–æ—á–∏–Ω–µ–Ω—ã built-in –∞–ª–∏–∞—Å—ã (`alias`/`preset`/`audit`/`pipeline`) –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –≤–µ—Ä—Å–∏–∏ –≤ –ª–æ–≥–∞—Ö/UA.\n\n### Compatibility\nPatch-—Ä–µ–ª–∏–∑ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤; —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∑—Ä–∞—á–Ω—ã –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –≤—ã–∑–æ–≤–æ–≤.\n\n## [6.2.0] - 2025-12-23 - Streaming Postgres exports to SFTP/HTTP\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 602,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 39,
        "end_line": 76,
        "content": "### Summary\n- –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã `postgres_to_sftp` –∏ `postgres_to_http`.\n- –≠–∫—Å–ø–æ—Ä—Ç PostgreSQL —Ç–µ–ø–µ—Ä—å —É–º–µ–µ—Ç —Å—Ç—Ä–∏–º–∏—Ç—å—Å—è –≤ –ø–æ—Ç–æ–∫ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π.\n- –í `mcp_pipeline` –¥–æ–±–∞–≤–ª–µ–Ω—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —ç–∫—Å–ø–æ—Ä—Ç–∞ (limit/offset, order_by, filters).\n- –û–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ –ø–∞–π–ø–ª–∞–π–Ω–∞–º.\n\n### Compatibility\n–†–µ–ª–∏–∑ —Å–æ–≤–º–µ—Å—Ç–∏–º —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º–∏ –≤–µ—Ä—Å–∏—è–º–∏; –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª—è—é—Ç –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏.\n\n## [6.1.0] - 2025-12-23 - UX aliases/presets, audit + traces, streaming pipelines\n\n### Summary\n- –î–æ–±–∞–≤–ª–µ–Ω—ã alias/preset —Ä–µ–µ—Å—Ç—Ä—ã –∏ DSL-–æ–±–æ–ª–æ—á–∫–∞ –¥–ª—è runbooks.\n- –í–≤–µ–¥–µ–Ω—ã trace/span –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏ –∞—É–¥–∏—Ç-–ª–æ–≥ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏.\n- –ü–æ—è–≤–∏–ª–∏—Å—å –ø–æ—Ç–æ–∫–æ–≤—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã HTTP‚ÜîSFTP‚ÜîPostgreSQL –∏ —Ñ–∞–π–ª–æ–≤—ã–π cache.\n- PostgreSQL –ø–æ–ª—É—á–∏–ª `insert_bulk`, HTTP ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∫–∞ cache-–ø–æ–ª–∏—Ç–∏–∫.\n\n### Compatibility\n–†–µ–ª–∏–∑ –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã (`mcp_alias`, `mcp_preset`, `mcp_audit`, `mcp_pipeline`) –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (`span_id`, `parent_span_id`, `preset`). –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –≤—ã–∑–æ–≤—ã –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.\n\n## [6.0.0] - 2025-12-23 - Runbooks, state, SFTP, HTTP reliability, SQL helpers\n\n### Summary\n- –î–æ–±–∞–≤–ª–µ–Ω—ã runbooks –∏ session/persistent state –¥–ª—è –º–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤.\n- HTTP –∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∏–ª retry/backoff, –ø–∞–≥–∏–Ω–∞—Ü–∏—é, download –∏ auth providers (exec/oauth2).\n- SSH —Ç–µ–ø–µ—Ä—å —É–º–µ–µ—Ç SFTP (list/upload/download).\n- PostgreSQL –ø–æ–ª—É—á–∏–ª helpers: select/count/exists –∏ —ç–∫—Å–ø–æ—Ä—Ç –≤ csv/jsonl.\n- –ï–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–æ–≤ —Å `ok/result/meta`, –ø–æ–¥–¥–µ—Ä–∂–∫–∞ `output` –∏ `store_as` –≤ –∫–∞–∂–¥–æ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–µ.\n\n### Compatibility\n–†–µ–ª–∏–∑ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è: –æ—Ç–≤–µ—Ç—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Ç–µ–ø–µ—Ä—å –æ–±—ë—Ä–Ω—É—Ç—ã –≤ `ok/result/meta`, –ø–ª—é—Å –Ω–æ–≤—ã–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç –ø–æ–ª–µ–π (`output`, `store_as`, `trace_id`). –û–±–Ω–æ–≤–∏—Ç–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –∏ runbooks.\n\n## [5.0.0] - 2025-12-23 - Engine-grade toolchain overhaul\n\n### Summary\n- –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ–±–Ω–æ–≤–ª—ë–Ω –∫–æ–Ω—Ç—Ä–∞–∫—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: –ø—Ä–æ—Ñ–∏–ª–∏ (`profile_*`), –∑–∞–ø—Ä–æ—Å—ã (`query`, `batch`, `transaction`), CRUD (`insert/update/delete`), –∫–∞—Ç–∞–ª–æ–≥.\n- –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ—Ñ–∏–ª–µ–π (`data` + `secrets`) –∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-256-GCM –±–µ–∑ legacy-–≤–µ—Ç–æ–∫.\n- –£–±—Ä–∞–Ω—ã –Ω–µ—è–≤–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (`LIMIT` –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏ –ª–∏–º–∏—Ç—ã –¥–ª–∏–Ω—ã), –¥–æ–±–∞–≤–ª–µ–Ω—ã —É–¥–æ–±–Ω—ã–µ –æ–ø—Ü–∏–∏ –¥–ª—è inline-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 736,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 77,
        "end_line": 114,
        "content": "- HTTP –∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∏–ª –ø—Ä–æ—Ñ–∏–ª–∏, –≥–∏–±–∫–∏–µ —Ç–µ–ª–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π auth.\n- SSH –∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∏–ª batch-—Ä–µ–∂–∏–º, env/cwd/timeout –∏ —Ä–∞–±–æ—Ç—É —Å inline-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º–∏.\n\n### Compatibility\n–≠—Ç–æ —Ä–µ–ª–∏–∑ —Å –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏: –æ–±–Ω–æ–≤–ª—ë–Ω —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ—Ñ–∏–ª–µ–π –∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–µ–π—Å—Ç–≤–∏–π. –°–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä—É–π—Ç–µ –Ω–æ–≤—ã–µ `profile_*` –≤—ã–∑–æ–≤—ã –∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª–∏.\n\n## [4.2.0] - 2025-09-26 - Client TLS for PostgreSQL\n\n### Summary\n- –î–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–ª—è `ssl_ca`, `ssl_cert`, `ssl_key`, `ssl_passphrase`, `ssl_servername` –∏ `ssl_mode` –¥–ª—è `setup_profile`.\n- –ü—Ä–æ—Ñ–∏–ª–∏ —à–∏—Ñ—Ä—É—é—Ç –∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–ª—é—á–∏, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å mutual TLS.\n- –ü—É–ª—ã `pg` —Å–æ–∑–¥–∞—é—Ç—Å—è —Å —É—á—ë—Ç–æ–º —Ä–µ–∂–∏–º–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤ –∏ –∏–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞; `sslmode=verify-full` —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞–µ—Ç —à—Ç–∞—Ç–Ω–æ.\n\n## [4.1.1] - 2025-09-25 - Rebranding to SentryFrogg\n\n### Summary\n- –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞ —Å `psql-ssh-api` –Ω–∞ –±—Ä–µ–Ω–¥ SentryFrogg –≤–æ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞—Ö.\n- –û–±–Ω–æ–≤–ª–µ–Ω—ã –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è, –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω—ã–µ –∑–∞—è–≤–ª–µ–Ω–∏—è –∏ —Å–ø—Ä–∞–≤–æ—á–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –ø–æ–¥ –Ω–æ–≤–æ–µ –∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ.\n- –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Å –Ω–æ–≤—ã–º –±—Ä–µ–Ω–¥–æ–º –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏.\n\n### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏\n```json\n{\n  \"mcpServers\": {\n    \"sentryfrogg\": {\n      \"command\": \"node\",\n      \"args\": [\"path/to/dist/sentryfrogg_server.js\"]\n    }\n  }\n}\n```\n\n## [4.1.0] - 2025-09-25 - –£–ø—Ä–æ—â–µ–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—É—Ç—Ä—ã –∏ UX –¥–ª—è –∞–≥–µ–Ω—Ç–æ–≤\n\n### –ì–ª–∞–≤–Ω–æ–µ\n- –ü–µ—Ä–µ–ø–∏—Å–∞–Ω—ã `PostgreSQLManager`, `SSHManager`, `APIManager` ‚Äî –º–µ–Ω—å—à–µ –∫–æ–¥–∞, –±–æ–ª—å—à–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏\n- –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π: –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π AES-–∫–ª—é—á (`.mcp_profiles.key`) –∏ –ø—Ä—è–º–æ–µ API –±–µ–∑ –ø—Ä–æ–∫—Å–∏\n- PostgreSQL —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç `connection_url`, –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã (`params`) –∏ –æ–ø—Ü–∏—é `ssl`",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 610,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 115,
        "end_line": 152,
        "content": "- SSH –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—Ö–æ–¥ —Å `private_key`/`passphrase` –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–µ —Ç–∞–π–º–∞—É—Ç—ã\n- –£–¥–∞–ª–µ–Ω—ã —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ —Å–µ—Ä–≤–∏—Å—ã (`ConnectionService`, `QueryService`, `ServiceContainer` –∏ –ø—Ä.)\n- –ü–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω—ã `Security`, `Validation`, `Logger` ‚Äî —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞—è –ª–æ–≥–∏–∫–∞, –±–µ–∑ —Ä–µ–π—Ç–æ–≤ –∏ —Å–ª–æ–∂–Ω—ã—Ö –ª–æ–∫–æ–≤\n- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –∏ –ø—Ä–∏–º–µ—Ä—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π (`README.md`, `README_RU.md`, `mcp_config.md`)\n\n### –ß—Ç–æ —É–ª—É—á—à–∏–ª–æ—Å—å\n- **–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞ ‚Üì** ‚Äì –æ–¥–∏–Ω —Ñ–∞–π–ª = –æ–¥–Ω–∞ –∑–∞–¥–∞—á–∞, —á–∏—Å—Ç—ã–µ –æ—Ç–≤–µ—Ç—ã –æ–± –æ—à–∏–±–∫–∞—Ö\n- **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å ‚Üë** ‚Äì SSH-–∫–æ–º–∞–Ω–¥—ã –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É—é—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ, PostgreSQL-–ø—É–ª—ã —Å–æ–∑–¥–∞—é—Ç—Å—è –ª–µ–Ω–∏–≤–æ\n- **API-–≥–∏–±–∫–æ—Å—Ç—å** ‚Äì `mcp_api_client` —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–µ URL –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `node-fetch`\n- **–ü—Ä–æ—Ñ–∏–ª–∏ —É—Å—Ç–æ–π—á–∏–≤—ã** ‚Äì –∫–ª—é—á –Ω–µ —Ç–µ—Ä—è–µ—Ç—Å—è –º–µ–∂–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–º–∏, –ø–∞—Ä–æ–ª–∏ –º–æ–∂–Ω–æ –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç—å\n\n### –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å\n–í—Å–µ –¥–µ–π—Å—Ç–≤–∏—è (`setup_profile`, `quick_query`, `execute`, `get` –∏ —Ç.–¥.) —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è, –µ—Å–ª–∏ –∫–ª—é—á –Ω–µ –º–µ–Ω—è–ª—Å—è.\n\n## [4.0.0] - 2024-12-19 - –ö–û–ú–ü–ê–ö–¢–ù–´–ï –ò–ú–ï–ù–ê –ò –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–´\n\n### üöÄ –ö–õ–Æ–ß–ï–í–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø\n\n#### ‚ú® –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∏–º–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤\n- **–ò–º—è —Å–µ—Ä–≤–µ—Ä–∞** - `postgresql-api-ssh-mcp-server` ‚Üí `psql-ssh-api` (—Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 75%)\n- **–ò–º–µ–Ω–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤** - –°–æ–∫—Ä–∞—â–µ–Ω—ã —Å 81 —Å–∏–º–≤–æ–ª–æ–≤ –¥–æ 17-20 —Å–∏–º–≤–æ–ª–æ–≤\n  - `mcp_postgresql-api-ssh-mcp-server_postgresql_manager` ‚Üí `mcp_psql_manager`\n  - `mcp_postgresql-api-ssh-mcp-server_ssh_manager` ‚Üí `mcp_ssh_manager`\n  - `mcp_postgresql-api-ssh-mcp-server_universal_api_client` ‚Üí `mcp_api_client`\n\n#### üèóÔ∏è Service Layer –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n- **ServiceContainer** - Dependency Injection —Å–∏—Å—Ç–µ–º–∞\n- **ConnectionService** - –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏\n- **QueryService** - –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤\n- **ProfileService** - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è–º–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n- **ServiceBootstrap** - –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤\n\n#### üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã\n- **PostgreSQLManager** - –°–æ–∫—Ä–∞—â–µ–Ω –Ω–∞ 30% (476 ‚Üí 333 —Å—Ç—Ä–æ–∫–∏)\n- **SSHManager** - –°–æ–∫—Ä–∞—â–µ–Ω –Ω–∞ 35% (442 ‚Üí 286 —Å—Ç—Ä–æ–∫)\n- **–£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è** - –£–¥–∞–ª–µ–Ω—ã ES –º–æ–¥—É–ª–∏ (50% —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤)\n- **Dependency Injection** - –°–Ω–∏–∂–µ–Ω–∏–µ —Å–≤—è–∑–∞–Ω–Ω–æ—Å—Ç–∏ –Ω–∞ 80%\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 754,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 153,
        "end_line": 190,
        "content": "#### üìä –£–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏\n- **–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è** - –£—Å–∫–æ—Ä–µ–Ω–∏–µ –Ω–∞ 20%\n- **–ü–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏** - –°–Ω–∏–∂–µ–Ω–∏–µ –Ω–∞ 15%\n- **–í—Ä–µ–º—è –æ—Ç–∫–ª–∏–∫–∞** - –£—Å–∫–æ—Ä–µ–Ω–∏–µ –Ω–∞ 10%\n- **–ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å** - –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –Ω–∞ 25%\n\n#### üõ°Ô∏è –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n- **100% API —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å** - –í—Å–µ –∫–æ–º–∞–Ω–¥—ã —Ä–∞–±–æ—Ç–∞—é—Ç –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π\n- **AES-256-CBC —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ** - –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ\n- **SQL injection –∑–∞—â–∏—Ç–∞** - –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞\n- **Command injection –∑–∞—â–∏—Ç–∞** - –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞\n- **SSRF –∑–∞—â–∏—Ç–∞** - –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞\n\n#### üìö –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è\n- **README.md** - –û–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è v4.0.0\n- **mcp_config.md** - –ù–æ–≤—ã–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–º–µ–Ω–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤\n- **EFFICIENCY_OPTIMIZATION_REPORT.md** - –î–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –æ–± –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏\n\n### üéØ –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –í–ï–†–°–ò–ò 4.0.0\n\n#### –î–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤:\n- **–ö–æ—Ä–æ—Ç–∫–∏–µ –∏–º–µ–Ω–∞** - –ü—Ä–æ—â–µ –∑–∞–ø–æ–º–Ω–∏—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å\n- **–ë—ã—Å—Ç—Ä–∞—è —Ä–∞–±–æ—Ç–∞** - –ü–æ–≤—ã—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏\n- **–¢–∞ –∂–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –í—Å–µ –∑–∞—â–∏—Ç–Ω—ã–µ –º–µ—Ö–∞–Ω–∏–∑–º—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã\n- **–õ—É—á—à–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å** - –†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –∏–º–µ–Ω–∞–º–∏\n\n#### –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤:\n- **Service Layer** - –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n- **Dependency Injection** - –õ–µ–≥–∫–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ\n- **–ß–∏—Å—Ç—ã–π –∫–æ–¥** - –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è\n- **–í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n### üîß –ú–ò–ì–†–ê–¶–ò–Ø –° v3.0.0\n\n#### –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:\n```json\n// –°—Ç–∞—Ä–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è\n{",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 533,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 191,
        "end_line": 228,
        "content": "  \"mcpServers\": {\n    \"postgresql-api-ssh\": {\n      \"command\": \"node\",\n      \"args\": [\"path/to/dist/sentryfrogg_server.js\"]\n    }\n  }\n}\n\n// –ù–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è\n{\n  \"mcpServers\": {\n    \"psql-ssh-api\": {\n      \"command\": \"node\", \n      \"args\": [\"path/to/dist/sentryfrogg_server.js\"]\n    }\n  }\n}\n```\n\n#### –ù–æ–≤—ã–µ –∏–º–µ–Ω–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤:\n- `mcp_psql_manager` - PostgreSQL –æ–ø–µ—Ä–∞—Ü–∏–∏\n- `mcp_ssh_manager` - SSH –æ–ø–µ—Ä–∞—Ü–∏–∏  \n- `mcp_api_client` - API –∑–∞–ø—Ä–æ—Å—ã\n\n---\n\n## [3.0.0] - 2024-12-19 - –ú–û–î–£–õ–¨–ù–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ò –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨\n\n### üöÄ –†–ï–í–û–õ–Æ–¶–ò–û–ù–ù–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø\n\n#### ‚ú® –ú–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n- **–†–∞–∑–±–∏–≤–∫–∞ God Object** - –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª —É–º–µ–Ω—å—à–µ–Ω —Å 1505 –¥–æ 275 —Å—Ç—Ä–æ–∫ (-82%)\n- **7 —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π** - –ö–∞–∂–¥—ã–π –º–æ–¥—É–ª—å –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Å–≤–æ—é –æ–±–ª–∞—Å—Ç—å\n- **CommonJS —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å** - –ü–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ MCP SDK\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n#### üõ°Ô∏è –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å\n- **AES-256-CBC —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ** - –ü–∞—Ä–æ–ª–∏ –∑–∞—â–∏—â–µ–Ω—ã –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 341,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 229,
        "end_line": 266,
        "content": "- **SQL Injection –∑–∞—â–∏—Ç–∞** - –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö SQL –∑–∞–ø—Ä–æ—Å–æ–≤\n- **Command Injection –∑–∞—â–∏—Ç–∞** - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è SSH –∫–æ–º–∞–Ω–¥\n- **SSRF –∑–∞—â–∏—Ç–∞** - –í–∞–ª–∏–¥–∞—Ü–∏—è URL –¥–ª—è API –∑–∞–ø—Ä–æ—Å–æ–≤\n- **XSS –∑–∞—â–∏—Ç–∞** - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n- **–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ** - –î–µ—Ç–∞–ª—å–Ω—ã–µ –ª–æ–≥–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n\n#### üß™ –ö–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n- **36 –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ç–µ—Å—Ç–æ–≤** - –ü–æ–∫—Ä—ã—Ç–∏–µ 100% –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π\n- **–¢–µ—Å—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏** - –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –≤–∏–¥–æ–≤ –∏–Ω—ä–µ–∫—Ü–∏–π\n- **–¢–µ—Å—Ç—ã —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è** - –í–∞–ª–∏–¥–∞—Ü–∏—è AES-256-CBC\n- **–¢–µ—Å—Ç—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏** - –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫** - npm test\n\n#### üèóÔ∏è –ù–æ–≤–∞—è –º–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞\n```\nsentryfrogg_server.ts (275 —Å—Ç—Ä–æ–∫) - –ì–ª–∞–≤–Ω—ã–π —Å–µ—Ä–≤–µ—Ä\nsrc/\n‚îú‚îÄ‚îÄ constants/index.ts   - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã\n‚îú‚îÄ‚îÄ logger/index.ts      - –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ  \n‚îú‚îÄ‚îÄ security/index.ts    - AES-256-CBC —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ\n‚îú‚îÄ‚îÄ validation/index.ts  - –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –∑–∞—â–∏—Ç–∞ –æ—Ç –∏–Ω—ä–µ–∫—Ü–∏–π\n‚îú‚îÄ‚îÄ database/postgresql.ts - –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å PostgreSQL\n‚îú‚îÄ‚îÄ ssh/index.ts         - –ó–∞—â–∏—Ç–∞ –æ—Ç command injection\n‚îî‚îÄ‚îÄ api/index.ts         - SSRF –∑–∞—â–∏—Ç–∞ –¥–ª—è API –∑–∞–ø—Ä–æ—Å–æ–≤\n```\n\n#### üîÑ –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ PostgreSQL Manager\n- **–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏** - –ü–∞—Ä–æ–ª–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ AES-256-CBC\n- **SQL injection –∑–∞—â–∏—Ç–∞** - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è** - –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤\n- **–î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ** - –õ–æ–≥–∏ –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö\n\n#### üîÑ –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ SSH Manager  \n- **Command injection –∑–∞—â–∏—Ç–∞** - –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –æ–ø–∞—Å–Ω—ã—Ö –∫–æ–º–∞–Ω–¥\n- **–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–∞—Ä–æ–ª–∏** - AES-256-CBC –¥–ª—è SSH –ø–∞—Ä–æ–ª–µ–π\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è** - –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–∞–Ω–¥ –∏ —Ö–æ—Å—Ç–æ–≤\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ** - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 637,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 267,
        "end_line": 304,
        "content": "#### üîÑ –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ API Client\n- **SSRF –∑–∞—â–∏—Ç–∞** - –í–∞–ª–∏–¥–∞—Ü–∏—è URL –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∞—Ç–∞–∫\n- **–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö** - –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –∏ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –î–µ—Ç–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö\n- **–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤** - –ü–æ–ª–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ API –≤—ã–∑–æ–≤–æ–≤\n\n#### üìä –ú–µ—Ç—Ä–∏–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π\n- **–ö–æ–¥:** 1505 ‚Üí 275 —Å—Ç—Ä–æ–∫ (-82% –≥–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª)\n- **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** –í—ã—Å–æ–∫–∞—è ‚Üí –ù–∏–∑–∫–∞—è (-70%)\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:** –ë–∞–∑–æ–≤–∞—è ‚Üí –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è (+400%)\n- **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:** 0% ‚Üí 100% –ø–æ–∫—Ä—ã—Ç–∏–µ\n- **–ú–æ–¥—É–ª–∏:** 1 God Object ‚Üí 7 —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π\n\n#### üõ†Ô∏è –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è\n- **–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è** - –ï–¥–∏–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–∞–Ω–Ω—ã—Ö\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –î–µ—Ç–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\n- **–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è** - –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º–∏\n- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –ú–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n#### üìö –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è v3.0.0\n- **–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è** - –û–ø–∏—Å–∞–Ω–∏–µ –º–æ–¥—É–ª—å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã\n- **–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏** - –ü–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞—â–∏—Ç–Ω—ã—Ö –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤\n- **–ü—Ä–∏–º–µ—Ä—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è** - –ö–∞–∫ –∑–∞–ø—É—Å–∫–∞—Ç—å –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç—ã\n- **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –¥–∏–∞–≥—Ä–∞–º–º—ã** - –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã\n\n### üóëÔ∏è –£–î–ê–õ–ï–ù–ù–´–ï –ü–†–û–ë–õ–ï–ú–´\n\n#### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:\n- **God Object** - –†–∞–∑–±–∏—Ç –Ω–∞ 7 —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π\n- **–ö–æ–¥ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ** - –£—Å—Ç—Ä–∞–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ –º–æ–¥—É–ª—å–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É\n- **–í—ã—Å–æ–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å** - –°–Ω–∏–∂–µ–Ω–∞ –Ω–∞ 70% —á–µ—Ä–µ–∑ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏\n- **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç–µ—Å—Ç–æ–≤** - –î–æ–±–∞–≤–ª–µ–Ω–æ 36 —Ç–µ—Å—Ç–æ–≤ —Å 100% –ø–æ–∫—Ä—ã—Ç–∏–µ–º\n\n#### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:\n- **–ü–∞—Ä–æ–ª–∏ –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –≤–∏–¥–µ** - –ó–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ AES-256-CBC —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ\n- **SQL injection —É—è–∑–≤–∏–º–æ—Å—Ç–∏** - –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è\n- **Command injection —É—è–∑–≤–∏–º–æ—Å—Ç–∏** - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥\n- **SSRF —É—è–∑–≤–∏–º–æ—Å—Ç–∏** - –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö URL",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 745,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 305,
        "end_line": 342,
        "content": "- **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è** - –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ª–æ–≥–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n\n### üéØ –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –í–ï–†–°–ò–ò 3.0.0\n\n#### –î–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤:\n- **–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –ó–∞—â–∏—Ç–∞ –æ—Ç –≤—Å–µ—Ö –≤–∏–¥–æ–≤ –∞—Ç–∞–∫\n- **–ü—Ä–æ—Å—Ç–æ—Ç–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è** - –¢–µ –∂–µ –ø—Ä–æ—Å—Ç—ã–µ –∫–æ–º–∞–Ω–¥—ã\n- **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å** - –ö–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n#### –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤:\n- **–ú–æ–¥—É–ª—å–Ω–æ—Å—Ç—å** - –õ–µ–≥–∫–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å\n- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å** - –ß–∏—Å—Ç—ã–π, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥\n- **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å** - 100% –ø–æ–∫—Ä—ã—Ç–∏–µ —Ç–µ—Å—Ç–∞–º–∏\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –∑–∞—â–∏—Ç—ã\n\n### üîß –ú–ò–ì–†–ê–¶–ò–Ø –° v2.0.0\n\n#### API –æ—Å—Ç–∞–µ—Ç—Å—è —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º:\n```json\n// –ö–æ–º–∞–Ω–¥—ã –æ—Å—Ç–∞–ª–∏—Å—å —Ç–µ–º–∏ –∂–µ —Å–∞–º—ã–º–∏\n{\n  \"action\": \"setup_profile\",\n  \"host\": \"localhost\",\n  \"username\": \"postgres\", \n  \"password\": \"mypassword\",\n  \"database\": \"mydb\"\n}\n```\n\n#### –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n- –ü–∞—Ä–æ–ª–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —à–∏—Ñ—Ä—É—é—Ç—Å—è AES-256-CBC\n- –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –ø—Ä–æ—Ö–æ–¥—è—Ç –≤–∞–ª–∏–¥–∞—Ü–∏—é –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n- –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ª–æ–≥–∏—Ä—É–µ—Ç—Å—è\n- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –∏–Ω—ä–µ–∫—Ü–∏–π\n\n### üêõ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ü–†–û–ë–õ–ï–ú–´\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 413,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 343,
        "end_line": 380,
        "content": "- **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** - God Object —Ä–∞–∑–±–∏—Ç –Ω–∞ –º–æ–¥—É–ª–∏\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –î–æ–±–∞–≤–ª–µ–Ω–∞ –∑–∞—â–∏—Ç–∞ –æ—Ç –≤—Å–µ—Ö –≤–∏–¥–æ–≤ –∞—Ç–∞–∫  \n- **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ** - 100% –ø–æ–∫—Ä—ã—Ç–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π\n- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥\n- **–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å** - –ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞\n- **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è** - –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ–±–Ω–æ–≤–ª–µ–Ω–∞\n\n---\n\n## [2.0.0] - 2024-12-XX - –ö–ê–†–î–ò–ù–ê–õ–¨–ù–û–ï –£–ü–†–û–©–ï–ù–ò–ï –î–õ–Ø –ò–ò –ê–ì–ï–ù–¢–û–í\n\n### üöÄ –ì–õ–ê–í–ù–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø\n\n#### ‚ú® –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏\n- **–°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π** - –ü–∞—Ä–æ–ª—å —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è\n- **–£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã** - –ú–∏–Ω–∏–º—É–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞\n- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏** - –°–µ—Ä–≤–µ—Ä —Å–∞–º —É–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º–∏\n- **–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ** - –í—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤ –ø–∞–º—è—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞\n- **–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π** - –ú–æ–∂–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Å —Ä–∞–∑–Ω—ã–º–∏ —Å–µ—Ä–≤–µ—Ä–∞–º–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ\n\n#### üîÑ –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ PostgreSQL Manager\n- **–ù–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã:**\n  - `setup_profile` - –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n  - `list_profiles` - –°–ø–∏—Å–æ–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π\n  - `quick_query` - –ë—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SQL –∑–∞–ø—Ä–æ—Å–æ–≤\n  - `describe_table` - –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç–∞–±–ª–∏—Ü—ã\n  - `insert_data` - –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤—Å—Ç–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö\n  - `update_data` - –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n  - `delete_data` - –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n  - `database_info` - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\n\n#### üîÑ –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ SSH Manager\n- **–ù–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã:**\n  - `setup_profile` - –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è SSH –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n  - `list_profiles` - –°–ø–∏—Å–æ–∫ SSH –ø—Ä–æ—Ñ–∏–ª–µ–π\n  - `system_info` - –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏—Å—Ç–µ–º–µ\n\n#### üîÑ –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ API Client",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 600,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 381,
        "end_line": 418,
        "content": "- **–£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã** - –£–±—Ä–∞–Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å —É–∫–∞–∑—ã–≤–∞—Ç—å `auth_type`\n- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ** - –°–µ—Ä–≤–µ—Ä —Å–∞–º –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏\n\n#### üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è\n- **–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π** - `Map` –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª–µ–π\n- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏** - –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ/–æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é\n- **–£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –ë–æ–ª–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö\n\n#### üìö –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è\n- **–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è** - –°–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤\n- **–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è** - –ü–æ–¥—Ä–æ–±–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥—ã\n- **Troubleshooting** - –†–∞–∑–¥–µ–ª —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Ç–∏–ø–∏—á–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º\n\n### üóëÔ∏è –£–î–ê–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò (–ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å v1.0.0)\n\n#### PostgreSQL Manager\n- `connect` - –ó–∞–º–µ–Ω–µ–Ω –Ω–∞ `setup_profile`\n- `analyze_schema` - –°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω–æ –¥–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤\n- `table_stats` - –°–ª–∏—à–∫–æ–º –¥–µ—Ç–∞–ª—å–Ω–æ\n- `relationships` - –£–ø—Ä–æ—â–µ–Ω–æ –≤ `describe_table`\n- `indexes` - –†–µ–¥–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ò–ò –∞–≥–µ–Ω—Ç–∞–º–∏\n- `generate_query` - –ó–∞–º–µ–Ω–µ–Ω –Ω–∞ `quick_query`\n- `alter_table` - –°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω–æ\n- –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –º–∏–≥—Ä–∞—Ü–∏–π - –°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω–æ –¥–ª—è –ò–ò\n- –§—É–Ω–∫—Ü–∏–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ - –£–ø—Ä–æ—â–µ–Ω—ã\n\n#### SSH Manager\n- `connect` - –ó–∞–º–µ–Ω–µ–Ω –Ω–∞ `setup_profile`\n- –°–ª–æ–∂–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã - –£–ø—Ä–æ—â–µ–Ω—ã –¥–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö\n\n### üéØ –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –ù–û–í–û–ô –í–ï–†–°–ò–ò\n\n#### –î–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤:\n- **–ü—Ä–æ—Å—Ç–æ—Ç–∞** - –ú–µ–Ω—å—à–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞\n- **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å** - –ù–µ –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å –ø–∞—Ä–æ–ª—å –≤ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –ü–∞—Ä–æ–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ\n- **–£–¥–æ–±—Å—Ç–≤–æ** - –†–∞–±–æ—Ç–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–µ—Ä–≤–µ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ –ø—Ä–æ—Ñ–∏–ª–∏\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 602,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 419,
        "end_line": 456,
        "content": "#### –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤:\n- **–ú–µ–Ω—å—à–µ –∫–æ–¥–∞** - –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞\n- **–õ—É—á—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π\n- **–ü—Ä–æ—â–µ –æ—Ç–ª–∞–¥–∫–∞** - –ú–µ–Ω—å—à–µ —Å–ª–æ–∂–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π\n\n### üîß –ú–ò–ì–†–ê–¶–ò–Ø –° v1.0.0\n\n#### –°—Ç–∞—Ä—ã–π —Å–ø–æ—Å–æ–± (v1.0.0):\n```json\n{\n  \"action\": \"query\",\n  \"sql\": \"SELECT * FROM users\",\n  \"host\": \"localhost\",\n  \"username\": \"postgres\",\n  \"password\": \"mypassword\",\n  \"database\": \"mydb\"\n}\n```\n\n#### –ù–æ–≤—ã–π —Å–ø–æ—Å–æ–± (v2.0.0):\n```json\n// 1. –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å (–æ–¥–∏–Ω —Ä–∞–∑)\n{\n  \"action\": \"setup_profile\",\n  \"host\": \"localhost\",\n  \"username\": \"postgres\",\n  \"password\": \"mypassword\",\n  \"database\": \"mydb\"\n}\n\n// 2. –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å (–±–µ–∑ –ø–∞—Ä–æ–ª—è)\n{\n  \"action\": \"quick_query\",\n  \"sql\": \"SELECT * FROM users\"\n}\n```\n\n### üêõ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ü–†–û–ë–õ–ï–ú–´",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 238,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CHANGELOG.md",
        "start_line": 457,
        "end_line": 495,
        "content": "\n- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –ü–∞—Ä–æ–ª–∏ –±–æ–ª—å—à–µ –Ω–µ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ\n- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π\n- **–£–¥–æ–±—Å—Ç–≤–æ** - –ú–µ–Ω—å—à–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –∫–æ–¥–∞ –¥–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤\n- **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å** - –õ—É—á—à–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n\n### üìã TECHNICAL DETAILS\n\n#### –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∏–º–µ–Ω–∞—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤:\n- `postgresql_manager` ‚Üí `mcp_postgresql-api-ssh-mcp-server_postgresql_manager`\n- `ssh_manager` ‚Üí `mcp_postgresql-api-ssh-mcp-server_ssh_manager`\n- `universal_api_client` ‚Üí `mcp_postgresql-api-ssh-mcp-server_universal_api_client`\n\n#### –ù–æ–≤—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö:\n- `connections.postgresql` - Map –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è PostgreSQL –ø—Ä–æ—Ñ–∏–ª–µ–π\n- `connections.ssh` - Map –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è SSH –ø—Ä–æ—Ñ–∏–ª–µ–π\n- `connections.defaultProfiles` - –ü—Ä–æ—Ñ–∏–ª–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n\n---\n\n## [1.0.0] - 2024-12-XX - –ü–ï–†–í–ê–Ø –í–ï–†–°–ò–Ø\n\n### ‚ú® –§—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–≤–æ–π –≤–µ—Ä—Å–∏–∏\n- –ü–æ–ª–Ω—ã–π PostgreSQL manager —Å 31 —Ñ—É–Ω–∫—Ü–∏–µ–π\n- –°–∏—Å—Ç–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å —Ç–æ–∫–µ–Ω–∞–º–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n- –§—É–Ω–∫—Ü–∏–∏ –ò–ò –∞–Ω–∞–ª–∏–∑–∞ –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö\n- –°–∏—Å—Ç–µ–º–∞ –º–∏–≥—Ä–∞—Ü–∏–π\n- SSH manager —Å –ø–æ–ª–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é\n- Universal API client\n\n### üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏\n- –¢—Ä–µ–±–æ–≤–∞–ª —É–∫–∞–∑–∞–Ω–∏—è –ø–∞—Ä–æ–ª—è –≤ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ\n- –°–ª–æ–∂–Ω—ã–µ –º–Ω–æ–≥–æ–ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã\n- –ú–Ω–æ–∂–µ—Å—Ç–≤–æ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–∞—á\n- –°–∏—Å—Ç–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å —Ç–æ–∫–µ–Ω–∞–º–∏\n\n---\n**üéâ –í–µ—Ä—Å–∏—è 3.0.0 - —ç—Ç–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –º–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é –¥–ª—è –ò–ò –∞–≥–µ–Ω—Ç–æ–≤!** ",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 505,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "CODE_OF_CONDUCT.md": [
      {
        "file_path": "CODE_OF_CONDUCT.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# Code of Conduct\n\nThis project follows the Contributor Covenant Code of Conduct.\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment include:\n- Demonstrating empathy and kindness toward other people\n- Being respectful of differing opinions, viewpoints, and experiences\n- Giving and gracefully accepting constructive feedback\n- Accepting responsibility and apologizing to those affected by our mistakes\n- Focusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n- The use of sexualized language or imagery, and sexual attention or advances of any kind\n- Trolling, insulting or derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or email address, without their explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Enforcement Responsibilities\n\nProject maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces.\n\n## Enforcement",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 498,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "CODE_OF_CONDUCT.md",
        "start_line": 39,
        "end_line": 48,
        "content": "\nTo report unacceptable behavior, contact the project maintainers via GitHub (for example, by messaging the repository owner or opening an issue requesting a private channel).\n\nAll complaints will be reviewed and investigated promptly and fairly.\n\n## Attribution\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 2.1:\nhttps://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 102,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "CONTRIBUTING.md": [
      {
        "file_path": "CONTRIBUTING.md",
        "start_line": 1,
        "end_line": 36,
        "content": " [LEGEND]\n\n[CONTENT]\n# Contributing\n\nThanks for taking the time to contribute to SentryFrogg.\n\n## Development setup\n\nPrerequisites:\n- Node.js `>=18`\n- npm `>=8`\n- Docker (optional, for `npm run smoke`)\n\nInstall dependencies:\n- `npm install` (local development)\n- `npm ci` (recommended for CI / reproducible installs)\n\n## Useful scripts\n\n- `npm start` ‚Äî run the MCP server over stdio\n- `npm run check` ‚Äî syntax check (`node --check`)\n- `npm test` ‚Äî run the Node.js test suite\n- `npm run smoke` ‚Äî validate Docker-backed integration targets (see `integration/README.md`)\n\n## Pull requests\n\n- Keep PRs focused and easy to review.\n- Include evidence of verification (`npm run check` and `npm test`).\n- Update documentation when behaviour or tool schemas change.\n\n## Security and secrets\n\n- Do **not** commit `profiles.json` or `.mcp_profiles.key` (local state only).\n- Prefer storing local profile state outside the repository via `MCP_PROFILES_DIR` / `MCP_PROFILE_KEY_PATH`.\n- For security reports, see `SECURITY.md`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 255,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "GOALS.md": [
      {
        "file_path": "GOALS.md",
        "start_line": 1,
        "end_line": 11,
        "content": "[LEGEND]\nGOAL = A desired long-term property of the system.\nNON_GOAL = An explicit ‚Äúwe are not doing this‚Äù.\n\n[CONTENT]\nGoals ([GOAL]):\n- Make behavior explicit via contracts.\n- Make change safe via a fail-closed gate.\n\nNon-goals ([NON_GOAL]):\n- Perfect completeness on day 1.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 69,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "LEGEND.md": [
      {
        "file_path": "LEGEND.md",
        "start_line": 1,
        "end_line": 24,
        "content": "[LEGEND]\nDOC_FORMAT = The canonical doc shape: a `[LEGEND]` block then a `[CONTENT]` block.\nLEGEND_BLOCK = The `[LEGEND]` block containing definitions.\nCONTENT_BLOCK = The `[CONTENT]` block containing the document body.\nTOKEN = A named meaning reused across docs.\nGLOBAL_TOKEN = A token defined in `LEGEND.md`; available repo-wide.\nLOCAL_TOKEN = A token defined in a specific doc; scoped to that doc.\nTOKEN_REF = A reference in content like `[TOKEN]` (optionally `[TOKEN|LEGEND.md]`).\nNO_SHADOWING = Rule: a doc must not redefine a global token locally.\nGATE = A deterministic checker that fails closed on drift.\nDOCTOR = A diagnostic checker for environment + repo foundation.\nCONTRACT = A versioned interface spec with examples.\nCHANGE_PROTOCOL = The sequence: contracts ‚Üí implementation ‚Üí tests ‚Üí docs.\nCI = Continuous Integration (automated build/test checks).\n\n[CONTENT]\nThis file is the global vocabulary for the repo.\n\nUse it when:\n- A meaning repeats across multiple documents.\n- You want agents to reuse the same mental model without re-parsing prose.\n\nAvoid it when:\n- The concept is unique to one doc (keep it local).",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 283,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "MAP.md": [
      {
        "file_path": "MAP.md",
        "start_line": 1,
        "end_line": 17,
        "content": "[LEGEND]\nENTRYPOINTS = The minimal set of docs that explain ‚Äúhow this repo works‚Äù.\n\n[CONTENT]\nStart here ([ENTRYPOINTS]):\n- README.md (human entrypoint)\n- docs/AGENT_PLAYBOOK.md (agent workflow)\n- docs/DOC_STYLE.md (doc compiler rules)\n- docs/contracts/README.md (contract index)\n\nCore context:\n- PHILOSOPHY.md\n- GOALS.md\n- ARCHITECTURE.md\n\nMachine index:\n- ai/context_index.json (generated by `./tools/context`)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 104,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "PHILOSOPHY.md": [
      {
        "file_path": "PHILOSOPHY.md",
        "start_line": 1,
        "end_line": 8,
        "content": "[LEGEND]\nPRINCIPLE = A durable rule that trades off local optimization for global clarity.\n\n[CONTENT]\nThis repo prefers principles ([PRINCIPLE]) that optimize for long-term clarity:\n- Contracts over conventions.\n- Deterministic checks over ‚Äúworks on my machine‚Äù.\n- Small, reversible changes over heroic refactors.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 79,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "PUBLIC_RELEASE_CHECKLIST.md": [
      {
        "file_path": "PUBLIC_RELEASE_CHECKLIST.md",
        "start_line": 1,
        "end_line": 55,
        "content": " [LEGEND]\n\n[CONTENT]\n# Public Release Checklist\n\nThis project can create local state files (`profiles.json`, `.mcp_profiles.key`) that must never be committed.\n\n## 1) Quick sanity\n\n- Run `npm run check` and `npm test`.\n- Confirm ignored local state is not tracked:\n  - `git ls-files .mcp_profiles.key profiles.json` should print nothing.\n- Check if secret files exist in history:\n  - `git log --oneline -- .mcp_profiles.key profiles.json`\n  - if this prints commits, follow section **2** before going public.\n- Optional: scan history for other likely-sensitive filenames (names only):\n  - `git log --all --pretty=format: --name-only | rg -i \"password|token|secret|\\\\.pem$|id_rsa|\\\\.key$\" | sort -u`\n\n## 2) If secrets were committed in git history\n\nIf those files (or any other secrets) were ever committed, do **not** make the repository public until you:\n\n1. Rotate credentials (DB/SSH/API tokens) and replace `ENCRYPTION_KEY`.\n2. Purge history and force-push (coordinate with collaborators first).\n\nExample purge (uses `git filter-repo`):\n\n```bash\ngit filter-repo --path .mcp_profiles.key --path profiles.json --invert-paths\n```\n\nIf `git filter-repo` is not available, you can use the built-in `git filter-branch` (slower, but works for small repos):\n\n```bash\ngit filter-branch --force --index-filter \\\n  \"git rm --cached --ignore-unmatch .mcp_profiles.key profiles.json\" \\\n  --prune-empty --tag-name-filter cat -- --all\nrm -rf .git/refs/original\ngit reflog expire --expire=now --all\ngit gc --prune=now --aggressive\n```\n\nAfter rewriting history:\n- Re-tag/release as needed\n- Force-push branches and tags\n- Ask collaborators to re-clone\n\n## 3) GitHub hygiene\n\n- Ensure `SECURITY.md` is present and GitHub ‚ÄúPrivate vulnerability reporting‚Äù is enabled.\n- Keep templates and docs up to date:\n  - `.github/ISSUE_TEMPLATE/*`\n  - `.github/pull_request_template.md`\n  - `README.md`, `mcp_config.md`, `CHANGELOG.md`",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 478,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "README.md": [
      {
        "file_path": "README.md",
        "start_line": 1,
        "end_line": 38,
        "content": "# SentryFrogg MCP Server\n\n[–†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è](README_RU.md) ‚Ä¢ [Docs](docs/README.md) ‚Ä¢ [MCP configuration](mcp_config.md) ‚Ä¢ [Integration stack](integration/README.md) ‚Ä¢ [Changelog](CHANGELOG.md)\n\n![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)\n![Node.js >=18](https://img.shields.io/badge/node-%3E%3D18-brightgreen)\n[![CI](https://github.com/AmirTlinov/sentryfrogg-mcp/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/AmirTlinov/sentryfrogg-mcp/actions/workflows/ci.yml)\n\nSentryFrogg is a stdio-based Model Context Protocol (MCP) server that gives LLM agents a production-grade toolbox for PostgreSQL, SSH (incl. SFTP), and HTTP.\nUse it when you want real infrastructure access without glue scripts: profiles, streaming pipelines, runbooks, and auditability are built in.\n\nIf you want your agent to move real data (API ‚Üî SFTP ‚Üî Postgres), run controlled SSH ops, and leave a traceable trail ‚Äî this is the server.\n\n## Why SentryFrogg\n- One profile system across Postgres, SSH, and HTTP.\n- Streaming pipelines between HTTP, SFTP, and Postgres for large payloads.\n- Reliability primitives: retry/backoff, pagination, timeouts.\n- Runbooks + state for multi-step workflows and repeatable ops.\n- Intent layer with capability registry, previewed plans, and evidence bundles.\n- Observability with trace/span metadata and audit logs (redacted).\n- Encrypted local profile store (AES-256-GCM).\n- Safe-by-default local writes (no overwrite unless `overwrite: true`).\n- Optional unsafe local mode for full agent autonomy (local exec + filesystem).\n\n## Use cases\n- Sync or backfill data between APIs, SFTP drops, and PostgreSQL.\n- Run controlled remote operations via SSH with auditability.\n- Build repeatable incident runbooks for agents and operators.\n\n## Quick examples\nIngest JSONL into Postgres:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"http_to_postgres\",\n  \"http\": { \"url\": \"https://example.com/events.jsonl\" },\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 507,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "README.md",
        "start_line": 39,
        "end_line": 116,
        "content": "  \"format\": \"jsonl\",\n  \"batch_size\": 500\n}\n```\n\nExport Postgres to SFTP:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"postgres_to_sftp\",\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"csv\",\n  \"sftp\": { \"profile_name\": \"default\", \"remote_path\": \"/tmp/events.csv\", \"overwrite\": true }\n}\n```\n\n## Quick start\n1. Install: `npm install`\n2. Configure your MCP client (stdio):\n\n   ```json\n   {\n     \"mcpServers\": {\n       \"sentryfrogg\": {\n        \"command\": \"node\",\n        \"args\": [\"/absolute/path/to/dist/sentryfrogg_server.js\"]\n      }\n    }\n  }\n   ```\n\n   More details: `mcp_config.md`.\n3. Start: `npm start`\n4. In your MCP client: call `help`, then `profile_upsert` for PostgreSQL/SSH\n\n## Tools\n- `help`\n- `mcp_psql_manager`\n- `mcp_ssh_manager`\n- `mcp_api_client`\n- `mcp_state`\n- `mcp_runbook`\n- `mcp_project`\n- `mcp_context`\n- `mcp_workspace`\n- `mcp_capability`\n- `mcp_intent`\n- `mcp_evidence`\n- `mcp_alias`\n- `mcp_preset`\n- `mcp_audit`\n- `mcp_pipeline`\n- `mcp_local` (unsafe, opt-in)\n\nShort aliases are also available (`sql`, `psql`, `ssh`, `http`, `api`, `state`, `runbook`, `workspace`, `pipeline`; plus `local` when unsafe mode is enabled).\n\nReference + examples: `docs/tools.md`.\n\n## Intent UX\n- Define capabilities in `capabilities.json` (override path via `MCP_CAPABILITIES_PATH`).\n- Context snapshots are stored in `context.json` (override path via `MCP_CONTEXT_PATH`).\n- `mcp_intent` compiles to a runbook plan, dry-run by default; write/mixed effects require `apply: true`.\n- Evidence bundles are stored under `.sentryfrogg/evidence` (override path via `MCP_EVIDENCE_DIR`).\n\n## Development\n- `npm run check`\n- `npm test`\n- `npm run smoke` (Docker) ‚Äî see `integration/README.md`\n\n## Security\nThis server can execute SQL/SSH/HTTP by design. Run it only in environments you trust.\n\n- Vulnerability reporting: `SECURITY.md`\n- Public release checklist: `PUBLIC_RELEASE_CHECKLIST.md`\n## License\nMIT ‚Äî see `LICENSE`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 486,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "README_RU.md": [
      {
        "file_path": "README_RU.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# SentryFrogg MCP Server\n\n[English](README.md) ‚Ä¢ [Docs](docs/README.md) ‚Ä¢ [–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è MCP](mcp_config.md) ‚Ä¢ [–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–µ–Ω–¥](integration/README.md) ‚Ä¢ [–ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π](CHANGELOG.md)\n\n![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)\n![Node.js >=18](https://img.shields.io/badge/node-%3E%3D18-brightgreen)\n[![CI](https://github.com/AmirTlinov/sentryfrogg-mcp/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/AmirTlinov/sentryfrogg-mcp/actions/workflows/ci.yml)\n\nSentryFrogg ‚Äî MCP-—Å–µ—Ä–≤–µ—Ä (stdio), –∫–æ—Ç–æ—Ä—ã–π –¥–∞—ë—Ç LLM-–∞–≥–µ–Ω—Ç–∞–º –ø—Ä–æ–¥–∞–∫—à–Ω-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è PostgreSQL, SSH (–≤–∫–ª—é—á–∞—è SFTP) –∏ HTTP.\n–ü–æ–¥—Ö–æ–¥–∏—Ç, –∫–æ–≥–¥–∞ –Ω—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ —Ä–µ–∞–ª—å–Ω–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ –±–µ–∑ glue-—Å–∫—Ä–∏–ø—Ç–æ–≤: –ø—Ä–æ—Ñ–∏–ª–∏, –ø–æ—Ç–æ–∫–æ–≤—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã, runbooks –∏ –∞—É–¥–∏—Ç —É–∂–µ –µ—Å—Ç—å.\n\n–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –∞–≥–µ–Ω—Ç –≥–æ–Ω—è–ª —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (API ‚Üî SFTP ‚Üî Postgres), –¥–µ–ª–∞–ª —É–ø—Ä–∞–≤–ª—è–µ–º—ã–µ SSH-–æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ –æ—Å—Ç–∞–≤–ª—è–ª –ø–æ–Ω—è—Ç–Ω—ã–π —Å–ª–µ–¥ ‚Äî —ç—Ç–æ –æ–Ω–æ.\n\n## –ü–æ—á–µ–º—É SentryFrogg\n- –ï–¥–∏–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π –¥–ª—è Postgres, SSH –∏ HTTP.\n- –ü–æ—Ç–æ–∫–æ–≤—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã –º–µ–∂–¥—É HTTP, SFTP –∏ Postgres –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä—ë–º–æ–≤.\n- –ù–∞–¥—ë–∂–Ω–æ—Å—Ç—å: retry/backoff, –ø–∞–≥–∏–Ω–∞—Ü–∏—è, —Ç–∞–π–º–∞—É—Ç—ã.\n- Runbooks + state –¥–ª—è –º–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.\n- –ù–∞–±–ª—é–¥–∞–µ–º–æ—Å—Ç—å: trace/span –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏ –∞—É–¥–∏—Ç-–ª–æ–≥ —Å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º.\n- –ü—Ä–æ—Ñ–∏–ª–∏ —à–∏—Ñ—Ä—É—é—Ç—Å—è (AES-256-GCM) –∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ.\n- –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã –¥–ª—è –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–æ–≤ (–±–µ–∑ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞—Ç—å `overwrite: true`).\n- –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π unsafe local —Ä–µ–∂–∏–º –¥–ª—è –ø–æ–ª–Ω–æ–π –∞–≤—Ç–æ–Ω–æ–º–Ω–æ—Å—Ç–∏ –∞–≥–µ–Ω—Ç–∞ (–ª–æ–∫–∞–ª—å–Ω—ã–π exec + filesystem).\n\n## –°—Ü–µ–Ω–∞—Ä–∏–∏\n- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–ª–∏ –±—ç–∫—Ñ–∏–ª–ª –¥–∞–Ω–Ω—ã—Ö –º–µ–∂–¥—É API, SFTP –∏ PostgreSQL.\n- –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–æ SSH —Å –∞—É–¥–∏—Ç–æ–º.\n- –ü–æ–≤—Ç–æ—Ä—è–µ–º—ã–µ runbook-—Ü–µ–ø–æ—á–∫–∏ –¥–ª—è –∞–≥–µ–Ω—Ç–æ–≤ –∏ –∏–Ω–∂–µ–Ω–µ—Ä–æ–≤.\n\n## –ë—ã—Å—Ç—Ä—ã–µ –ø—Ä–∏–º–µ—Ä—ã\n–ó–∞–≥—Ä—É–∑–∫–∞ JSONL –≤ Postgres:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"http_to_postgres\",",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 644,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "README_RU.md",
        "start_line": 39,
        "end_line": 76,
        "content": "  \"http\": { \"url\": \"https://example.com/events.jsonl\" },\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"jsonl\",\n  \"batch_size\": 500\n}\n```\n\n–≠–∫—Å–ø–æ—Ä—Ç Postgres –≤ SFTP:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"postgres_to_sftp\",\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"csv\",\n  \"sftp\": { \"profile_name\": \"default\", \"remote_path\": \"/tmp/events.csv\", \"overwrite\": true }\n}\n```\n\n–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è: Node.js `>=18`, npm `>=8`.\n\n## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç\n1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: `npm install`\n2. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ —Å–µ—Ä–≤–µ—Ä –≤ MCP-–∫–ª–∏–µ–Ω—Ç–µ (stdio): —Å–º. `mcp_config.md`\n3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä: `npm start`\n4. –í MCP-–∫–ª–∏–µ–Ω—Ç–µ –≤—ã–∑–æ–≤–∏—Ç–µ `help`, –∑–∞—Ç–µ–º `profile_upsert` –¥–ª—è PostgreSQL/SSH\n5. –î–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω—ã—Ö write-—Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ `policy_profiles` (—Å–º. `docs/tools.md`)\n\n## –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã\n- `help`\n- `mcp_psql_manager`\n- `mcp_ssh_manager`\n- `mcp_api_client`\n- `mcp_state`\n- `mcp_runbook`\n- `mcp_project`\n- `mcp_context`\n- `mcp_workspace`",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 281,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "README_RU.md",
        "start_line": 77,
        "end_line": 102,
        "content": "- `mcp_capability`\n- `mcp_intent`\n- `mcp_evidence`\n- `mcp_alias`\n- `mcp_preset`\n- `mcp_audit`\n- `mcp_pipeline`\n- `mcp_local` (unsafe, –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n\n–ö–æ—Ä–æ—Ç–∫–∏–µ –∞–ª–∏–∞—Å—ã: `sql`, `psql`, `ssh`, `http`, `api`, `state`, `runbook`, `workspace`, `pipeline` (–∏ `local`, –µ—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω unsafe —Ä–µ–∂–∏–º).\n\n–ü—Ä–∏–º–µ—Ä—ã –∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤—ã–∑–æ–≤–æ–≤: `docs/tools.md`.\n\n## –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞\n- `npm run check`\n- `npm test`\n- `npm run smoke` (Docker) ‚Äî —Å–º. `integration/README.md`\n\n## –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å\n–°–µ—Ä–≤–µ—Ä —É–º–µ–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å SQL/SSH/HTTP –ø–æ –∑–∞–º—ã—Å–ª—É ‚Äî –∑–∞–ø—É—Å–∫–∞–π—Ç–µ —Ç–æ–ª—å–∫–æ –≤ –¥–æ–≤–µ—Ä–µ–Ω–Ω–æ–π —Å—Ä–µ–¥–µ.\n\n- –†–µ–ø–æ—Ä—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: `SECURITY.md`\n- –ß–µ–∫–ª–∏—Å—Ç –ø–µ—Ä–µ–¥ –ø—É–±–ª–∏–∫–∞—Ü–∏–µ–π: `PUBLIC_RELEASE_CHECKLIST.md`\n\n## –õ–∏—Ü–µ–Ω–∑–∏—è\nMIT ‚Äî —Å–º. `LICENSE`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 218,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "SECURITY.md": [
      {
        "file_path": "SECURITY.md",
        "start_line": 1,
        "end_line": 32,
        "content": " [LEGEND]\n\n[CONTENT]\n# Security Policy\n\nSentryFrogg is an MCP server capable of executing SQL, SSH commands, and HTTP requests. Treat it as privileged infrastructure software.\n\n## Unsafe local mode\n\nSentryFrogg also has an **optional** local-machine tool (`mcp_local`) that can execute commands and access the host filesystem.\nIt is **disabled by default** and is only exposed when you explicitly set `SENTRYFROGG_UNSAFE_LOCAL=1` (or `SF_UNSAFE_LOCAL=1`).\n\nEnable it only in environments you fully trust.\n\n## Reporting a vulnerability\n\nPlease **do not** open a public issue for security vulnerabilities.\n\nPreferred:\n- Use GitHub Security Advisories (private vulnerability reporting) for this repository.\n\nIf advisories are not available:\n- Contact the repository maintainers via GitHub and request a private channel for disclosure.\n\n## Supported versions\n\nOnly the latest released version is supported with security updates.\n\n## Handling secrets\n\n- `profiles.json` and `.mcp_profiles.key` are local state and must never be committed.\n- If secrets were accidentally committed in git history: rotate credentials, change `ENCRYPTION_KEY`, and purge history before making the repository public (e.g., `git filter-repo` / BFG).",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 305,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "ai/protocol.yaml": [
      {
        "file_path": "ai/protocol.yaml",
        "start_line": 1,
        "end_line": 17,
        "content": "protocol_version: 1\nproject:\n  name: \"SentryFrogg\"\n  slug: \"sentryfrogg\"\n  language: \"node\"\nforge:\n  skill: \"ai-first-project-forge\"\n  skeleton_version: \"0.7.6\"\n  generated_at_utc: \"2026-01-08T04:36:09+00:00\"\ndocs:\n  format:\n    legend_header: \"[LEGEND]\"\n    content_header: \"[CONTENT]\"\ngates:\n  golden_path:\n    - \"./tools/doctor\"\n    - \"./tools/gate\"",
        "metadata": {
          "language": "yaml",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 88,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/.clang-format": [
      {
        "file_path": "bootstrap/flagship/.clang-format",
        "start_line": 1,
        "end_line": 3,
        "content": "BasedOnStyle: LLVM\nIndentWidth: 2\nColumnLimit: 100",
        "metadata": {
          "language": "unknown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 12,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/.clang-tidy": [],
    "bootstrap/flagship/clippy.toml": [],
    "bootstrap/flagship/configs/guardrails.json": [
      {
        "file_path": "bootstrap/flagship/configs/guardrails.json",
        "start_line": 1,
        "end_line": 7,
        "content": "{\n  \"dup_threshold_pct\": 3,\n  \"cyclomatic_max\": 10,\n  \"cognitive_max\": 15,\n  \"p95_budget_ms\": 5,\n  \"p99_budget_ms\": 10\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 30,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/eslint.config.mjs": [
      {
        "file_path": "bootstrap/flagship/eslint.config.mjs",
        "start_line": 1,
        "end_line": 42,
        "content": "import js from \"@eslint/js\";\nimport sonarjs from \"eslint-plugin-sonarjs\";\n\nconst complexityLimit = Number(process.env.ESLINT_COMPLEXITY_LIMIT ?? \"10\");\nconst cognitiveLimit = Number(process.env.ESLINT_COGNITIVE_LIMIT ?? \"15\");\nconst cognitiveSeverity = process.env.CI_STRICT === \"1\" ? \"error\" : \"warn\";\n\nexport default [\n  {\n    ignores: [\n      \"node_modules/**\",\n      \"dist/**\",\n      \"build/**\",\n      \"coverage/**\",\n      \"reports/**\",\n      \"artifacts/**\",\n      \"tools/**\",\n      \".venv/**\",\n      \"eslint.config.mjs\",\n    ],\n  },\n  js.configs.recommended,\n  {\n    files: [\"**/*.{js,jsx,ts,tsx}\"],\n    languageOptions: {\n      parserOptions: {\n        ecmaVersion: \"latest\",\n        sourceType: \"module\",\n      },\n      globals: {\n        process: \"readonly\",\n      },\n    },\n    plugins: {\n      sonarjs,\n    },\n    rules: {\n      complexity: [\"error\", complexityLimit],\n      \"sonarjs/cognitive-complexity\": [cognitiveSeverity, cognitiveLimit],\n    },\n  },\n];\n",
        "metadata": {
          "language": "javascript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 242,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/package.json": [
      {
        "file_path": "bootstrap/flagship/package.json",
        "start_line": 1,
        "end_line": 18,
        "content": "{\n  \"name\": \"flagship-project\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"@eslint/js\": \"9.37.0\",\n    \"@redocly/cli\": \"2.4.0\",\n    \"@stoplight/spectral-cli\": \"6.15.0\",\n    \"clang-format\": \"1.8.0\",\n    \"eslint\": \"9.37.0\",\n    \"eslint-plugin-sonarjs\": \"3.0.5\",\n    \"jscpd\": \"4.0.5\",\n    \"prettier\": \"3.6.2\",\n    \"redoc\": \"2.5.1\",\n    \"stylelint\": \"16.25.0\",\n    \"stylelint-config-standard\": \"39.0.1\"\n  },\n  \"scripts\": {}\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 106,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/bench/generate_baseline.py": [
      {
        "file_path": "bootstrap/flagship/scripts/bench/generate_baseline.py",
        "start_line": 36,
        "end_line": 44,
        "content": "def percentile(values, pct):\n    if not values:\n        return 0.0\n    k = (len(values) - 1) * pct / 100.0\n    f = math.floor(k)\n    c = math.ceil(k)\n    if f == c:\n        return values[int(k)]\n    return values[f] + (values[c] - values[f]) * (k - f)",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "percentile",
          "context_imports": [
            "import math"
          ],
          "parent_scope": null,
          "estimated_tokens": 64,
          "qualified_name": "percentile",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/bench/parse_p95_p99.sh": [
      {
        "file_path": "bootstrap/flagship/scripts/bench/parse_p95_p99.sh",
        "start_line": 1,
        "end_line": 44,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nREPORTS_DIR=\"${1:-reports}\"\nmkdir -p \"$REPORTS_DIR\"\nOUT=\"$REPORTS_DIR/metrics.json\"\ntmp=\"$(mktemp)\"; [ -f \"$OUT\" ] && cp \"$OUT\" \"$tmp\" || echo '{}' > \"$tmp\"\n\n# pytest-benchmark JSON\nif [ -f \"$REPORTS_DIR/bench_py.json\" ]; then\n  ${PY:-python3} - \"$REPORTS_DIR/bench_py.json\" \"$tmp\" <<'PY'\nimport json,sys\nbench=json.load(open(sys.argv[1])); metrics=json.load(open(sys.argv[2]))\np95=p99=0.0\nfor b in bench.get(\"benchmarks\",[]):\n    stats=b.get(\"stats\",{}); perc=stats.get(\"percentile\",{})\n    p95=max(p95, float(perc.get(\"95.0\", 0.0))); p99=max(p99, float(perc.get(\"99.0\", 0.0)))\nmetrics[\"p95_ms\"]=p95; metrics[\"p99_ms\"]=p99\njson.dump(metrics, open(sys.argv[2],\"w\"))\nprint(f\"pytest-benchmark: p95={p95} p99={p99}\")\nPY\nfi\n\n# Criterion proxy (Rust)\nif [ -d target/criterion ]; then\n  ${PY:-python3} - \"$tmp\" <<'PY'\nimport json,sys,glob\nmetrics=json.load(open(sys.argv[1]))\np=0.0\nfor path in glob.glob(\"target/criterion/*/new/estimates.json\"):\n    try:\n        est=json.load(open(path))\n        mean_ns=est.get(\"mean\",{}).get(\"point_estimate\",0.0)\n        p=max(p, mean_ns/1e6)\n    except Exception: pass\nmetrics[\"p95_ms\"]=max(metrics.get(\"p95_ms\",0.0), p)\nmetrics[\"p99_ms\"]=max(metrics.get(\"p99_ms\",0.0), p)\njson.dump(metrics, open(sys.argv[1],\"w\"))\nprint(f\"criterion proxy mean_ms={p}\")\nPY\nfi\n\nmv \"$tmp\" \"$OUT\"\necho \"Bench metrics aggregated ‚Üí $OUT\"\n${PY:-python3} scripts/bench/generate_baseline.py \"$OUT\"",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 361,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/bootstrap/install_node.sh": [
      {
        "file_path": "bootstrap/flagship/scripts/bootstrap/install_node.sh",
        "start_line": 1,
        "end_line": 33,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nVER=\"${1:-v20.18.0}\"\nDEST=\"${2:-tools/node}\"\nmkdir -p \"$DEST\"\n\nif [ -x \"$DEST/bin/node\" ]; then\n  existing=\"$($DEST/bin/node -v 2>/dev/null || true)\"\n  if [ \"$existing\" = \"$VER\" ]; then\n    echo \"Node $existing already installed at $DEST\"\n    exit 0\n  fi\nfi\n\nOS=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\nARCH=\"$(uname -m)\"\ncase \"$ARCH\" in\n  x86_64|amd64) ARCH=x64 ;;\n  arm64|aarch64) ARCH=arm64 ;;\n  *) echo \"Unsupported arch: $ARCH\"; exit 1 ;;\nesac\ncase \"$OS\" in\n  linux) PKG=\"node-${VER}-linux-${ARCH}.tar.xz\" ;;\n  darwin) PKG=\"node-${VER}-darwin-${ARCH}.tar.xz\" ;;\n  *) echo \"Unsupported OS: $OS\"; exit 1 ;;\nesac\nURL=\"https://nodejs.org/dist/${VER}/${PKG}\"\ntmpfile=\"$(mktemp /tmp/node.XXXXXX)\"\necho \"Downloading $URL\"\ncurl -fsSL \"$URL\" -o \"$tmpfile\"\ntar -xf \"$tmpfile\" -C \"$DEST\" --strip-components=1\nrm -f \"$tmpfile\"\necho \"Installed node ‚Üí $DEST (node --version: $(\"$DEST/bin/node\" -v))\"",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 233,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/bootstrap/install_syft.sh": [
      {
        "file_path": "bootstrap/flagship/scripts/bootstrap/install_syft.sh",
        "start_line": 1,
        "end_line": 30,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nVER=\"${1:-v1.33.0}\"\nDEST=\"${2:-tools/syft}\"\nmkdir -p \"$DEST\"\n\nif [ -x \"$DEST/syft\" ]; then\n  existing=\"$($DEST/syft version 2>/dev/null | awk '{print $3}' || true)\"\n  if [ \"$existing\" = \"${VER#v}\" ]; then\n    echo \"Syft v${existing} already installed at $DEST\"\n    exit 0\n  fi\nfi\n\nOS=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\nARCH=\"$(uname -m)\"\ncase \"$ARCH\" in\n  x86_64|amd64) ARCH=amd64 ;;\n  arm64|aarch64) ARCH=arm64 ;;\n  *) echo \"Unsupported arch: $ARCH\"; exit 1 ;;\nesac\nTAR=\"syft_${VER#v}_${OS}_${ARCH}.tar.gz\"\nURL=\"https://github.com/anchore/syft/releases/download/${VER}/${TAR}\"\ntmpfile=\"$(mktemp /tmp/syft.XXXXXX)\"\necho \"Downloading $URL\"\ncurl -fsSL \"$URL\" -o \"$tmpfile\"\ntar -xzf \"$tmpfile\" -C \"$DEST\"\nrm -f \"$tmpfile\"\nchmod +x \"$DEST/syft\"\necho \"Installed syft ‚Üí $DEST/syft\"",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 205,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/cpp/generate_compile_commands.sh": [
      {
        "file_path": "bootstrap/flagship/scripts/cpp/generate_compile_commands.sh",
        "start_line": 1,
        "end_line": 11,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nmkdir -p build\nif command -v cmake >/dev/null 2>&1; then\n  cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON\n  ln -sf build/compile_commands.json . || true\nelif command -v bear >/dev/null 2>&1; then\n  echo \"WARN: using bear to capture compile commands; run your build to populate file\"\nelse\n  echo \"WARN: cmake/bear not found; cannot generate compile_commands.json\"\nfi",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 102,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/quality/complexity.py": [
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.py",
        "start_line": 12,
        "end_line": 16,
        "content": "def load_json(path: Path, default):\n    try:\n        return json.loads(path.read_text())\n    except Exception:\n        return default",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "load_json",
          "context_imports": [
            "from pathlib import Path",
            "import json"
          ],
          "parent_scope": null,
          "estimated_tokens": 41,
          "qualified_name": "load_json",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.py",
        "start_line": 19,
        "end_line": 28,
        "content": "def cyclomatic_from_lizard(data) -> int:\n    cyclo = 0\n    if isinstance(data, list):\n        for file_info in data:\n            for func in file_info.get(\"functions\", []):\n                try:\n                    cyclo = max(cyclo, int(func.get(\"cyclomatic_complexity\", 0)))\n                except Exception:\n                    continue\n    return cyclo",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "cyclomatic_from_lizard",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 88,
          "qualified_name": "cyclomatic_from_lizard",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.py",
        "start_line": 31,
        "end_line": 40,
        "content": "def cognitive_from_lizard(data) -> int:\n    cog = 0\n    if isinstance(data, list):\n        for file_info in data:\n            for func in file_info.get(\"functions\", []):\n                try:\n                    cog = max(cog, int(func.get(\"cognitive_complexity\", 0)))\n                except Exception:\n                    continue\n    return cog",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "cognitive_from_lizard",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 86,
          "qualified_name": "cognitive_from_lizard",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.py",
        "start_line": 43,
        "end_line": 50,
        "content": "def duplication_from_jscpd(data) -> float:\n    if isinstance(data, dict):\n        summary = data.get(\"summary\", {})\n        try:\n            return float(summary.get(\"percentage\", 0.0))\n        except Exception:\n            return 0.0\n    return 0.0",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "duplication_from_jscpd",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "duplication_from_jscpd",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.py",
        "start_line": 53,
        "end_line": 107,
        "content": "def main(argv: list[str]) -> int:\n    if len(argv) != 7:\n        print(f\"BLOCKER: {USAGE}\", file=sys.stderr)\n        return 2\n\n    metrics_path = Path(argv[1])\n    lizard_path = Path(argv[2])\n    jscpd_path = Path(argv[3])\n    try:\n        cyclo_limit = int(argv[4])\n        cog_limit = int(argv[5])\n        dup_limit = float(argv[6])\n    except ValueError:\n        print(\"BLOCKER: invalid numeric limits\", file=sys.stderr)\n        return 2\n\n    metrics = load_json(metrics_path, {})\n    lizard = load_json(lizard_path, [])\n    jscpd = load_json(jscpd_path, {})\n\n    cyclo = cyclomatic_from_lizard(lizard)\n    cog = cognitive_from_lizard(lizard)\n    dup = duplication_from_jscpd(jscpd)\n\n    metrics.update(\n        {\n            \"cyclomatic_max\": cyclo,\n            \"cognitive_max\": cog,\n            \"dup_pct\": dup,\n        }\n    )\n\n    metrics_path.parent.mkdir(parents=True, exist_ok=True)\n    metrics_path.write_text(json.dumps(metrics, indent=2))\n\n    print(\n        \"Complexity metrics ‚Üí cyclomatic_max={cyclo}, cognitive_max={cog}, dup_pct={dup:.2f}%\".format(\n            cyclo=cyclo,\n            cog=cog,\n            dup=dup,\n        )\n    )\n\n    if cyclo > cyclo_limit:\n        print(\"BLOCKER: cyclomatic complexity over limit\", file=sys.stderr)\n        return 2\n    if cog > cog_limit:\n        print(\"BLOCKER: cognitive complexity over limit\", file=sys.stderr)\n        return 2\n    if dup > dup_limit:\n        # jscpd already enforces, but keep guard for completeness\n        print(\"BLOCKER: duplication percentage over limit\", file=sys.stderr)\n        return 2\n\n    return 0",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "main",
          "context_imports": [
            "from pathlib import Path",
            "import json",
            "import sys"
          ],
          "parent_scope": null,
          "estimated_tokens": 406,
          "qualified_name": "main",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/quality/complexity.sh": [
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.sh",
        "start_line": 1,
        "end_line": 38,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nCYCLO_LIMIT=\"${1:-10}\"\nCOG_LIMIT=\"${2:-15}\"\nREPORTS_DIR=\"${3:-reports}\"\nDUP_LIMIT=\"${4:-${DUP_THRESHOLD:-3}}\"\nmkdir -p \"$REPORTS_DIR\"\nREPORTS_GLOB=\"./${REPORTS_DIR}/*\"\n\nLIST_FILE=$(mktemp)\ncleanup() {\n  rm -f \"$LIST_FILE\"\n}\ntrap cleanup EXIT\n\nif git rev-parse --is-inside-work-tree >/dev/null 2>&1; then\n  git ls-files > \"$LIST_FILE\" || true\nelse\n  find . -type f \\( \\\n    -name '*.py' -o -name '*.rs' -o -name '*.go' -o -name '*.js' -o -name '*.ts' -o -name '*.tsx' -o -name '*.jsx' -o \\\n    -name '*.[ch]' -o -name '*.cc' -o -name '*.cxx' -o -name '*.cpp' -o -name '*.hpp' -o -name '*.hh' -o -name '*.hxx' \\\n  \\) \\\n    -not -path './.git/*' -not -path './node_modules/*' -not -path './.venv/*' -not -path \"$REPORTS_GLOB\" -not -path './artifacts/*' \\\n    > \"$LIST_FILE\"\nfi\n\nif command -v .venv/bin/python >/dev/null 2>&1; then PY=.venv/bin/python; else PY=${PY:-python3}; fi\n\nif $PY -c \"import importlib.util,sys; sys.exit(0 if importlib.util.find_spec('lizard') else 1)\" >/dev/null 2>&1; then\n  FILE_LIST_PATH=\"$LIST_FILE\" $PY - <<'PY' > \"$REPORTS_DIR/lizard.json\"\nimport json, os, shlex, subprocess, sys\nfile_list_path = os.environ.get(\"FILE_LIST_PATH\", \"\")\nfiles = []\nif file_list_path:\n    try:\n        with open(file_list_path, \"r\", encoding=\"utf-8\") as fh:\n            files = [line.strip() for line in fh if line.strip()]\n    except OSError:",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 346,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/complexity.sh",
        "start_line": 39,
        "end_line": 57,
        "content": "        files = []\nif files:\n    cmd = \"lizard -j \" + \" \".join(shlex.quote(f) for f in files)\n    proc = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    sys.stdout.write(proc.stdout.decode())\nelse:\n    sys.stdout.write(\"[]\")\nPY\nelse\n  echo '{\"status\":\"skip\",\"reason\":\"lizard not installed\"}' > \"$REPORTS_DIR/lizard.json\"\nfi\n\nJSPCD_JSON=\"$REPORTS_DIR/jscpd/jscpd-report.json\"\nif [ ! -f \"$JSPCD_JSON\" ]; then\n  mkdir -p \"$(dirname \"$JSPCD_JSON\")\"\n  echo '{\"summary\":{\"percentage\":0.0}}' > \"$JSPCD_JSON\"\nfi\n\n$PY scripts/quality/complexity.py \"$REPORTS_DIR/metrics.json\" \"$REPORTS_DIR/lizard.json\" \"$JSPCD_JSON\" \"$CYCLO_LIMIT\" \"$COG_LIMIT\" \"$DUP_LIMIT\"",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 171,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/quality/guard.py": [
      {
        "file_path": "bootstrap/flagship/scripts/quality/guard.py",
        "start_line": 1,
        "end_line": 30,
        "content": "#!/usr/bin/env python3\nimport json, sys, os\nfrom pathlib import Path\n\nif len(sys.argv) < 3:\n    print(\"BLOCKER: guard.py usage: guard.py <configs/guardrails.json> <reports/metrics.json>\", file=sys.stderr)\n    sys.exit(2)\n\ncfg_path, met_path = Path(sys.argv[1]), Path(sys.argv[2])\nif not cfg_path.exists():\n    print(f\"BLOCKER: missing {cfg_path}\", file=sys.stderr); sys.exit(2)\nif not met_path.exists():\n    print(f\"BLOCKER: missing {met_path}\", file=sys.stderr); sys.exit(2)\n\ncfg = json.load(open(cfg_path))\nmet = json.load(open(met_path))\nviol = []\n\nif met.get(\"dup_pct\", 0) > cfg.get(\"dup_threshold_pct\", 1e9): viol.append(\"dup_pct\")\nif met.get(\"cyclomatic_max\", 0) > cfg.get(\"cyclomatic_max\", 1e9): viol.append(\"cyclomatic_max\")\nif met.get(\"cognitive_max\", 0) > cfg.get(\"cognitive_max\", 1e9): viol.append(\"cognitive_max\")\n\np95b = cfg.get(\"p95_budget_ms\", 0); p99b = cfg.get(\"p99_budget_ms\", 0)\nif p95b and met.get(\"p95_ms\", 0) > p95b: viol.append(\"p95_ms\")\nif p99b and met.get(\"p99_ms\", 0) > p99b: viol.append(\"p99_ms\")\n\nif viol:\n    print(\"BLOCKER: guardrails violated ‚Üí \" + \",\".join(viol))\n    sys.exit(2)\nprint(\"OK: guardrails pass\")\n",
        "metadata": {
          "language": "python",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "from pathlib import Path",
            "import json, sys, os"
          ],
          "parent_scope": null,
          "estimated_tokens": 296,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/quality/merge_cyclonedx.py": [
      {
        "file_path": "bootstrap/flagship/scripts/quality/merge_cyclonedx.py",
        "start_line": 7,
        "end_line": 12,
        "content": "def _load(path: Path, default):\n    try:\n        with path.open(\"r\", encoding=\"utf-8\") as fh:\n            return json.load(fh)\n    except Exception:\n        return default",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "_load",
          "context_imports": [
            "from pathlib import Path",
            "import json"
          ],
          "parent_scope": null,
          "estimated_tokens": 50,
          "qualified_name": "_load",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/merge_cyclonedx.py",
        "start_line": 15,
        "end_line": 27,
        "content": "def _dedup_append(target, items):\n    if not isinstance(items, list):\n        return\n    if not isinstance(target, list):\n        target[:] = []\n    seen = {json.dumps(entry, sort_keys=True) for entry in target if isinstance(entry, dict)}\n    for entry in items:\n        if not isinstance(entry, dict):\n            continue\n        signature = json.dumps(entry, sort_keys=True)\n        if signature not in seen:\n            target.append(entry)\n            seen.add(signature)",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "_dedup_append",
          "context_imports": [
            "import json"
          ],
          "parent_scope": null,
          "estimated_tokens": 121,
          "qualified_name": "_dedup_append",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/merge_cyclonedx.py",
        "start_line": 30,
        "end_line": 45,
        "content": "def merge(syft_path: Path, cargo_path: Path) -> bool:\n    syft = _load(syft_path, {})\n    cargo = _load(cargo_path, {})\n\n    if not cargo:\n        return False\n\n    syft.setdefault(\"components\", [])\n    syft.setdefault(\"dependencies\", [])\n\n    _dedup_append(syft[\"components\"], cargo.get(\"components\"))\n    _dedup_append(syft[\"dependencies\"], cargo.get(\"dependencies\"))\n\n    with syft_path.open(\"w\", encoding=\"utf-8\") as fh:\n        json.dump(syft, fh)\n    return True",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "merge",
          "context_imports": [
            "from pathlib import Path",
            "import json"
          ],
          "parent_scope": null,
          "estimated_tokens": 125,
          "qualified_name": "merge",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/quality/merge_cyclonedx.py",
        "start_line": 48,
        "end_line": 59,
        "content": "def main() -> int:\n    if len(sys.argv) != 3:\n        print(\"merge_cyclonedx.py <syft.json> <cargo.json>\", file=sys.stderr)\n        return 2\n    syft_path = Path(sys.argv[1])\n    cargo_path = Path(sys.argv[2])\n    merged = merge(syft_path, cargo_path)\n    if merged:\n        print(\"Rust cargo CycloneDX merged into SBOM\")\n    else:\n        print(\"INFO: cargo CycloneDX data empty ‚Üí nothing merged\")\n    return 0",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "main",
          "context_imports": [
            "from pathlib import Path",
            "import json",
            "import sys"
          ],
          "parent_scope": null,
          "estimated_tokens": 113,
          "qualified_name": "main",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/security/aggregate.py": [
      {
        "file_path": "bootstrap/flagship/scripts/security/aggregate.py",
        "start_line": 13,
        "end_line": 18,
        "content": "def load(path: Path, default: Any) -> Any:\n    try:\n        with path.open(\"r\", encoding=\"utf-8\") as fh:\n            return json.load(fh)\n    except Exception:\n        return default",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "load",
          "context_imports": [
            "from pathlib import Path",
            "from typing import Any, Dict, List, Tuple",
            "import json"
          ],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "load",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/aggregate.py",
        "start_line": 21,
        "end_line": 24,
        "content": "def npm_severity(data: Dict[str, Any]) -> Tuple[int, int]:\n    metadata = data.get(\"metadata\", {}) if isinstance(data, dict) else {}\n    vulns = metadata.get(\"vulnerabilities\", {}) if isinstance(metadata, dict) else {}\n    return int(vulns.get(\"high\", 0)), int(vulns.get(\"critical\", 0))",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "npm_severity",
          "context_imports": [
            "from typing import Any, Dict, List, Tuple"
          ],
          "parent_scope": null,
          "estimated_tokens": 81,
          "qualified_name": "npm_severity",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/aggregate.py",
        "start_line": 27,
        "end_line": 56,
        "content": "def pip_patch_applied() -> bool:\n    try:\n        module = importlib.import_module(\"pip._internal.utils.unpacking\")\n    except Exception:\n        return False\n\n    if not hasattr(module, \"is_symlink_target_in_tar\"):\n        return False\n\n    if hasattr(module, \"_untar_without_filter\"):\n        try:\n            source = inspect.getsource(module._untar_without_filter)\n        except (TypeError, OSError, AttributeError):\n            return False\n        return (\n            \"is_symlink_target_in_tar\" in source\n            and \"raise InstallationError\" in source\n            and \"linkname\" in source\n        )\n\n    try:\n        untar_src = inspect.getsource(module.untar_file)\n    except (TypeError, OSError, AttributeError):\n        return False\n\n    return (\n        \"is_symlink_target_in_tar\" in untar_src\n        and \"raise InstallationError\" in untar_src\n        and \"member.linkname\" in untar_src\n    )",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "pip_patch_applied",
          "context_imports": [
            "import inspect"
          ],
          "parent_scope": null,
          "estimated_tokens": 230,
          "qualified_name": "pip_patch_applied",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/aggregate.py",
        "start_line": 59,
        "end_line": 136,
        "content": "def summarise_pip(\n    pip_data: Any,\n) -> Tuple[int, int, List[Dict[str, Any]], List[Dict[str, str]], Any]:\n    high = crit = 0\n    skipped: List[Dict[str, Any]] = []\n    mitigations: List[Dict[str, str]] = []\n\n    if isinstance(pip_data, dict):\n        deps = pip_data.get(\"dependencies\", [])\n        high, crit, skipped, mitigations, sanitized_deps = summarise_pip(deps)\n        sanitized = dict(pip_data)\n        sanitized[\"dependencies\"] = sanitized_deps\n        return high, crit, skipped, mitigations, sanitized\n\n    if isinstance(pip_data, list):\n        sanitized: List[Dict[str, Any]] = []\n        patch_present = pip_patch_applied()\n        for package in pip_data:\n            entry: Dict[str, Any] = {k: v for k, v in package.items() if k != \"vulns\"}\n\n            skip_reason = package.get(\"skip_reason\")\n            if skip_reason:\n                if (\n                    package.get(\"name\") == \"pip\"\n                    and patch_present\n                    and \"Dependency not found on PyPI\" in skip_reason\n                ):\n                    mitigations.append(\n                        {\n                            \"package\": \"pip\",\n                            \"vulnerability\": PIP_VULN_ID,\n                            \"status\": \"local patched build (pip-audit skip)\",\n                        }\n                    )\n                    entry[\"vulns\"] = []\n                    sanitized.append(entry)\n                    continue\n                skipped.append({\"name\": package.get(\"name\"), \"reason\": skip_reason})\n                entry[\"vulns\"] = package.get(\"vulns\", [])\n                sanitized.append(entry)\n                continue\n\n            vulns_out: List[Dict[str, Any]] = []\n            for vuln in package.get(\"vulns\", []):\n                vuln_entry = dict(vuln)\n                vuln_id = vuln_entry.get(\"id\")\n\n                if (\n                    package.get(\"name\") == \"pip\"\n                    and vuln_id == PIP_VULN_ID\n                    and patch_present\n                ):\n                    mitigations.append(\n                        {\n                            \"package\": \"pip\",\n                            \"vulnerability\": vuln_id,\n                            \"status\": \"local patch detected\",\n                        }\n                    )\n                    continue\n\n                severity = (vuln_entry.get(\"severity\") or \"\").upper()\n                if severity == \"CRITICAL\":\n                    crit += 1\n                elif severity == \"HIGH\":\n                    high += 1\n                elif severity:\n                    pass\n                else:\n                    high += 1\n                    vuln_entry[\"severity\"] = \"HIGH (assumed)\"\n                vulns_out.append(vuln_entry)\n\n            entry[\"vulns\"] = vulns_out\n            sanitized.append(entry)\n        return high, crit, skipped, mitigations, sanitized\n\n    return high, crit, skipped, mitigations, pip_data",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "summarise_pip",
          "context_imports": [
            "from typing import Any, Dict, List, Tuple"
          ],
          "parent_scope": null,
          "estimated_tokens": 746,
          "qualified_name": "summarise_pip",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/aggregate.py",
        "start_line": 139,
        "end_line": 209,
        "content": "def main(argv: List[str]) -> int:\n    if len(argv) != 6:\n        print(\n            \"aggregate.py usage: aggregate.py <npm_json> <npm_present> <pip_json> <pip_status> <out_json>\",\n            file=sys.stderr,\n        )\n        return 2\n\n    npm_path = Path(argv[1])\n    npm_present = argv[2] == \"1\"\n    pip_path = Path(argv[3])\n    pip_status = argv[4]\n    out_path = Path(argv[5])\n\n    npm_data = load(npm_path, {}) if npm_present else None\n    pip_default: Any = [] if pip_status == \"ran\" else {}\n    pip_data = load(pip_path, pip_default)\n\n    npm_high, npm_crit = npm_severity(npm_data or {})\n    pip_high, pip_crit, pip_skipped, mitigations, pip_sanitized = summarise_pip(pip_data)\n\n    summary = {\n        \"npm\": {\"high\": npm_high, \"critical\": npm_crit, \"present\": npm_present},\n        \"pip\": {\n            \"high\": pip_high,\n            \"critical\": pip_crit,\n            \"skipped\": pip_skipped,\n            \"status\": pip_status,\n        },\n        \"mitigations\": mitigations,\n    }\n\n    report = {\n        \"npm\": npm_data if npm_present else None,\n        \"pip\": pip_sanitized,\n        \"summary\": summary,\n    }\n    out_path.write_text(json.dumps(report, indent=2), encoding=\"utf-8\")\n\n    summary_parts = [\n        f\"npm(high={npm_high}, critical={npm_crit})\",\n        f\"pip(high={pip_high}, critical={pip_crit}, skipped={len(pip_skipped)}, mitigations={len(mitigations)})\",\n    ]\n    print(\"Security audit summary ‚Üí \" + \"; \".join(summary_parts))\n\n    issues: List[str] = []\n    if pip_status == \"missing_tool\":\n        issues.append(\"pip-audit missing for detected Python stack\")\n    elif pip_status == \"error\":\n        issues.append(\"pip-audit execution failed\")\n    elif pip_status == \"ran\" and pip_skipped:\n        for entry in pip_skipped:\n            issues.append(\n                f\"pip audit skipped {entry.get('name')}: {entry.get('reason')}\"\n            )\n\n    total_highcrit = npm_high + npm_crit + pip_high + pip_crit\n    strict = os.environ.get(\"CI_STRICT\") == \"1\"\n\n    if strict and total_highcrit > 0:\n        issues.append(\"High/critical vulnerabilities detected\")\n\n    if strict and issues:\n        for issue in issues:\n            print(f\"BLOCKER: {issue}\", file=sys.stderr)\n        return 2\n\n    for issue in issues:\n        print(f\"INFO: {issue}\", file=sys.stderr)\n\n    return 0",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "main",
          "context_imports": [
            "from pathlib import Path",
            "from typing import Any, Dict, List, Tuple",
            "import json",
            "import os",
            "import sys"
          ],
          "parent_scope": null,
          "estimated_tokens": 598,
          "qualified_name": "main",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/scripts/security/patch_pip.py": [
      {
        "file_path": "bootstrap/flagship/scripts/security/patch_pip.py",
        "start_line": 21,
        "end_line": 26,
        "content": "def find_site_packages() -> Path:\n    for entry in sys.path:\n        path = Path(entry)\n        if path.name == \"site-packages\" and path.exists():\n            return path\n    raise SystemExit(\"BLOCKER: unable to locate site-packages to patch pip\")",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "find_site_packages",
          "context_imports": [
            "from pathlib import Path",
            "import re",
            "import sys"
          ],
          "parent_scope": null,
          "estimated_tokens": 71,
          "qualified_name": "find_site_packages",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/patch_pip.py",
        "start_line": 29,
        "end_line": 79,
        "content": "def apply_patch(module_path: Path) -> None:\n    source = module_path.read_text(encoding=\"utf-8\")\n\n    if HELPER_NAME in source:\n        ensure_version(module_path, already_patched=True)\n        print(\"INFO: pip unpacking already patched\")\n        return\n\n    helper_snippet = \"\"\"\ndef is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:\n    \\\"\\\"\\\"Check if the symbolic link target stays within the archive.\\\"\\\"\\\"\n    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)\n    linkname = os.path.normpath(linkname).replace(\"\\\\\\\\\", \"/\")\n    try:\n        tar.getmember(linkname)\n        return True\n    except KeyError:\n        return False\n\"\"\"\n\n    anchor_index = source.find(TARGET_FUNC_INSERT_ANCHOR)\n    if anchor_index == -1:\n        raise SystemExit(\"BLOCKER: pip unpacking layout unknown (anchor missing)\")\n\n    insert_pos = source.find(\"\\n\\n\", anchor_index)\n    if insert_pos == -1:\n        insert_pos = len(source)\n\n    updated = source[: insert_pos + 1] + helper_snippet.strip(\"\\n\") + \"\\n\\n\" + source[insert_pos + 1 :]\n\n    target = \"        elif member.issym():\\n            try:\"\n    if target not in updated:\n        raise SystemExit(\"BLOCKER: pip unpacking layout unexpected (target missing)\")\n\n    updated = updated.replace(\n        target,\n        \"\"\"        elif member.issym():\n            if not is_symlink_target_in_tar(tar, member):\n                message = (\n                    \"The tar file ({}) has a file ({}) trying to install \"\n                    \"outside target directory ({})\"\n                )\n                raise InstallationError(\n                    message.format(filename, member.name, member.linkname)\n                )\n            try:\"\"\",\n        1,\n    )\n    module_path.write_text(updated, encoding=\"utf-8\")\n    ensure_version(module_path, already_patched=False)\n    print(f\"‚úì patched pip unpacking ‚Üí {module_path}\")",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "apply_patch",
          "context_imports": [
            "from pathlib import Path",
            "import re"
          ],
          "parent_scope": null,
          "estimated_tokens": 485,
          "qualified_name": "apply_patch",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/patch_pip.py",
        "start_line": 82,
        "end_line": 118,
        "content": "def ensure_version(module_path: Path, *, already_patched: bool) -> None:\n    pip_package = module_path.parents[2]\n    init_path = pip_package / \"__init__.py\"\n    init_text = init_path.read_text(encoding=\"utf-8\")\n    if NEW_VERSION not in init_text:\n        init_text = re.sub(\n            r'__version__\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']',\n            f'__version__ = \"{NEW_VERSION}\"',\n            init_text,\n        )\n        init_path.write_text(init_text, encoding=\"utf-8\")\n    site_packages = module_path.parents[3]\n    dist_info = next(site_packages.glob(\"pip-*.dist-info\"), None)\n    if dist_info is None:\n        if already_patched:\n            print(\"WARN: pip dist-info not found while verifying version\", file=sys.stderr)\n        else:\n            raise SystemExit(\"BLOCKER: pip dist-info not found\")\n        return\n    metadata_path = dist_info / \"METADATA\"\n    if metadata_path.exists():\n        meta_text = metadata_path.read_text(encoding=\"utf-8\")\n        if f\"Version: {NEW_VERSION}\" not in meta_text:\n            meta_text = re.sub(\n                r\"^Version:\\s*.+$\",\n                f\"Version: {NEW_VERSION}\",\n                meta_text,\n                count=1,\n                flags=re.MULTILINE,\n            )\n            metadata_path.write_text(meta_text, encoding=\"utf-8\")\n\n    desired_dir = site_packages / f\"pip-{NEW_VERSION}.dist-info\"\n    if dist_info != desired_dir:\n        if desired_dir.exists():\n            shutil.rmtree(desired_dir)\n        dist_info.rename(desired_dir)",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "ensure_version",
          "context_imports": [
            "from pathlib import Path",
            "import re",
            "import shutil",
            "import sys"
          ],
          "parent_scope": null,
          "estimated_tokens": 386,
          "qualified_name": "ensure_version",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "bootstrap/flagship/scripts/security/patch_pip.py",
        "start_line": 121,
        "end_line": 126,
        "content": "def main() -> None:\n    site_packages = find_site_packages()\n    module_path = site_packages / \"pip/_internal/utils/unpacking.py\"\n    if not module_path.exists():\n        raise SystemExit(f\"BLOCKER: pip module not found at {module_path}\")\n    apply_patch(module_path)",
        "metadata": {
          "language": "python",
          "chunk_type": "Function",
          "symbol_name": "main",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 66,
          "qualified_name": "main",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "bootstrap/flagship/stylelint.config.mjs": [
      {
        "file_path": "bootstrap/flagship/stylelint.config.mjs",
        "start_line": 1,
        "end_line": 4,
        "content": "/** @type {import(\"stylelint\").Config} */\nexport default {\n  extends: [\"stylelint-config-standard\"],\n};\n",
        "metadata": {
          "language": "javascript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 26,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "capabilities.json": [
      {
        "file_path": "capabilities.json",
        "start_line": 1,
        "end_line": 38,
        "content": "{\n  \"version\": 1,\n  \"capabilities\": {\n    \"k8s.render\": {\n      \"intent\": \"k8s.render\",\n      \"description\": \"Render kustomize overlay via kubectl kustomize.\",\n      \"runbook\": \"k8s.render\",\n      \"tags\": [\"k8s\", \"gitops\"],\n      \"inputs\": {\n        \"required\": [\"overlay\", \"kubeconfig\"],\n        \"defaults\": {},\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\",\n          \"sops_age_key_file\": \"target.sops_age_key_file\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"k8s.diff\": {\n      \"intent\": \"k8s.diff\",\n      \"description\": \"Render and diff against cluster.\",\n      \"runbook\": \"k8s.diff\",\n      \"tags\": [\"k8s\", \"gitops\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"overlay\", \"kubeconfig\"],\n        \"defaults\": {},\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\",\n          \"sops_age_key_file\": \"target.sops_age_key_file\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"k8s.apply\": {\n      \"intent\": \"k8s.apply\",\n      \"description\": \"Render and apply to cluster.\",",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 291,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 39,
        "end_line": 76,
        "content": "      \"runbook\": \"k8s.apply\",\n      \"tags\": [\"k8s\", \"gitops\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"overlay\", \"kubeconfig\"],\n        \"defaults\": {},\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\",\n          \"sops_age_key_file\": \"target.sops_age_key_file\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"k8s.rollout.inspect\": {\n      \"intent\": \"k8s.rollout.inspect\",\n      \"description\": \"Inspect rollout/deployment and related pods by selector.\",\n      \"runbook\": \"k8s.rollout.inspect\",\n      \"tags\": [\"k8s\", \"diagnostic\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"namespace\", \"selector\", \"workload_kind\", \"workload_name\"],\n        \"defaults\": { \"namespace\": \"default\", \"logs\": false, \"tail_lines\": 200 },\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"k8s.images.list\": {\n      \"intent\": \"k8s.images.list\",\n      \"description\": \"List container images used by workloads in a namespace.\",\n      \"runbook\": \"k8s.images.list\",\n      \"tags\": [\"k8s\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"namespace\"],\n        \"defaults\": { \"namespace\": \"default\" },\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\"",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 344,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 77,
        "end_line": 114,
        "content": "        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.argocd.refresh\": {\n      \"intent\": \"gitops.argocd.refresh\",\n      \"description\": \"Refresh ArgoCD application and show status.\",\n      \"runbook\": \"gitops.argocd.refresh\",\n      \"tags\": [\"gitops\", \"argocd\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"app_name\"],\n        \"defaults\": { \"namespace\": \"argocd\", \"refresh\": true },\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.status.argocd\": {\n      \"intent\": \"gitops.status\",\n      \"description\": \"GitOps status (ArgoCD marker): repo snapshot.\",\n      \"runbook\": \"gitops.status.argocd\",\n      \"tags\": [\"gitops\", \"argocd\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_root\": \"context.root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.status.flux\": {\n      \"intent\": \"gitops.status\",\n      \"description\": \"GitOps status (Flux marker): repo snapshot.\",",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 313,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 115,
        "end_line": 152,
        "content": "      \"runbook\": \"gitops.status.flux\",\n      \"tags\": [\"gitops\", \"flux\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_root\": \"context.root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.plan.argocd\": {\n      \"intent\": \"gitops.plan\",\n      \"description\": \"GitOps plan (ArgoCD marker): render + git diff.\",\n      \"runbook\": \"gitops.plan.argocd\",\n      \"tags\": [\"gitops\", \"argocd\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"overlay\"],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_root\": \"context.root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.plan.flux\": {\n      \"intent\": \"gitops.plan\",\n      \"description\": \"GitOps plan (Flux marker): render + git diff.\",\n      \"runbook\": \"gitops.plan.flux\",\n      \"tags\": [\"gitops\", \"flux\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"overlay\"],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_root\": \"context.root\"\n        }",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 286,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 153,
        "end_line": 190,
        "content": "      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.propose\": {\n      \"intent\": \"gitops.propose\",\n      \"description\": \"GitOps propose: branch + patch + commit + push + PR/MR.\",\n      \"runbook\": \"gitops.propose\",\n      \"tags\": [\"gitops\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"patch\", \"message\"],\n        \"defaults\": {\n          \"remote\": \"origin\",\n          \"branch_prefix\": \"sf/gitops\",\n          \"title\": \"GitOps update\",\n          \"wait_for_checks\": false,\n          \"checks_max_attempts\": 30,\n          \"checks_delay_ms\": 2000,\n          \"merge\": false,\n          \"merge_method\": \"squash\",\n          \"github_api_base_url\": \"https://api.github.com\",\n          \"gitlab_api_base_url\": \"https://gitlab.com/api/v4\"\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"gitops\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.sync.argocd\": {\n      \"intent\": \"gitops.sync\",\n      \"description\": \"GitOps sync (ArgoCD): trigger sync and wait for Synced/Healthy.\",\n      \"runbook\": \"gitops.sync.argocd\",\n      \"tags\": [\"gitops\", \"argocd\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"app_name\", \"kubeconfig\"],\n        \"defaults\": { \"namespace\": \"argocd\", \"wait\": true, \"max_attempts\": 30, \"delay_ms\": 2000 },",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 348,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 191,
        "end_line": 228,
        "content": "        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.sync.flux\": {\n      \"intent\": \"gitops.sync\",\n      \"description\": \"GitOps sync (Flux): request reconcile and wait for Ready=True.\",\n      \"runbook\": \"gitops.sync.flux\",\n      \"tags\": [\"gitops\", \"flux\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"kustomization_name\", \"kubeconfig\"],\n        \"defaults\": { \"namespace\": \"flux-system\", \"wait\": true, \"max_attempts\": 30, \"delay_ms\": 2000 },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.verify.argocd\": {\n      \"intent\": \"gitops.verify\",\n      \"description\": \"GitOps verify (ArgoCD): wait for Synced/Healthy.\",\n      \"runbook\": \"gitops.verify.argocd\",\n      \"tags\": [\"gitops\", \"argocd\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"app_name\", \"kubeconfig\"],\n        \"defaults\": {\n          \"namespace\": \"argocd\",\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000,\n          \"metrics_max_attempts\": 6,\n          \"metrics_delay_ms\": 10000\n        },",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 335,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 229,
        "end_line": 266,
        "content": "        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.verify.flux\": {\n      \"intent\": \"gitops.verify\",\n      \"description\": \"GitOps verify (Flux): wait for Ready=True.\",\n      \"runbook\": \"gitops.verify.flux\",\n      \"tags\": [\"gitops\", \"flux\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"kustomization_name\", \"kubeconfig\"],\n        \"defaults\": {\n          \"namespace\": \"flux-system\",\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000,\n          \"metrics_max_attempts\": 6,\n          \"metrics_delay_ms\": 10000\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"gitops.rollback.argocd\": {\n      \"intent\": \"gitops.rollback\",\n      \"description\": \"GitOps rollback (ArgoCD): revert git commit, push, sync, verify.\",\n      \"runbook\": \"gitops.rollback.argocd\",\n      \"tags\": [\"gitops\", \"argocd\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"app_name\", \"kubeconfig\"],\n        \"defaults\": {",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 318,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 267,
        "end_line": 304,
        "content": "          \"namespace\": \"argocd\",\n          \"remote\": \"origin\",\n          \"wait\": true,\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.rollback.flux\": {\n      \"intent\": \"gitops.rollback\",\n      \"description\": \"GitOps rollback (Flux): revert git commit, push, reconcile, verify.\",\n      \"runbook\": \"gitops.rollback.flux\",\n      \"tags\": [\"gitops\", \"flux\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"kustomization_name\", \"kubeconfig\"],\n        \"defaults\": {\n          \"namespace\": \"flux-system\",\n          \"remote\": \"origin\",\n          \"wait\": true,\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.release.argocd\": {\n      \"intent\": \"gitops.release\",",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 293,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 305,
        "end_line": 342,
        "content": "      \"description\": \"GitOps release autopilot (ArgoCD): plan‚Üípropose‚Üímerge‚Üísync‚Üíverify‚Üírollback.\",\n      \"runbook\": \"gitops.release\",\n      \"tags\": [\"gitops\", \"argocd\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"patch\", \"message\", \"app_name\", \"kubeconfig\"],\n        \"defaults\": {\n          \"namespace\": \"argocd\",\n          \"remote\": \"origin\",\n          \"branch_prefix\": \"sf/gitops\",\n          \"title\": \"GitOps release\",\n          \"wait\": true,\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000,\n          \"metrics_max_attempts\": 6,\n          \"metrics_delay_ms\": 10000,\n          \"wait_for_checks\": true,\n          \"checks_max_attempts\": 30,\n          \"checks_delay_ms\": 2000,\n          \"merge\": true,\n          \"merge_method\": \"squash\",\n          \"github_api_base_url\": \"https://api.github.com\",\n          \"gitlab_api_base_url\": \"https://gitlab.com/api/v4\"\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"argocd\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"gitops.release.flux\": {\n      \"intent\": \"gitops.release\",\n      \"description\": \"GitOps release autopilot (Flux): plan‚Üípropose‚Üímerge‚Üísync‚Üíverify‚Üírollback.\",\n      \"runbook\": \"gitops.release\",\n      \"tags\": [\"gitops\", \"flux\", \"write\"],\n      \"inputs\": {\n        \"required\": [\"patch\", \"message\", \"kustomization_name\", \"kubeconfig\"],",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 366,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 343,
        "end_line": 380,
        "content": "        \"defaults\": {\n          \"namespace\": \"flux-system\",\n          \"remote\": \"origin\",\n          \"branch_prefix\": \"sf/gitops\",\n          \"title\": \"GitOps release\",\n          \"wait\": true,\n          \"max_attempts\": 30,\n          \"delay_ms\": 2000,\n          \"metrics_max_attempts\": 6,\n          \"metrics_delay_ms\": 10000,\n          \"wait_for_checks\": true,\n          \"checks_max_attempts\": 30,\n          \"checks_delay_ms\": 2000,\n          \"merge\": true,\n          \"merge_method\": \"squash\",\n          \"github_api_base_url\": \"https://api.github.com\",\n          \"gitlab_api_base_url\": \"https://gitlab.com/api/v4\"\n        },\n        \"map\": {\n          \"repo_root\": \"context.root\",\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"flux\"] },\n      \"effects\": { \"kind\": \"write\", \"requires_apply\": true }\n    },\n    \"registry.tags.list\": {\n      \"intent\": \"registry.tags.list\",\n      \"description\": \"List repository tags via registry API.\",\n      \"runbook\": \"registry.tags.list\",\n      \"tags\": [\"registry\", \"api\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"repo\"],\n        \"defaults\": {},\n        \"map\": {\n          \"base_url\": \"target.registry_url\"\n        }\n      },",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 302,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 381,
        "end_line": 418,
        "content": "      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"repo.snapshot\": {\n      \"intent\": \"repo.snapshot\",\n      \"description\": \"Fast repository context: root, branch, status, recent commits, diffstat.\",\n      \"runbook\": \"repo.snapshot\",\n      \"tags\": [\"repo\", \"git\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_path\": \"project.repo_root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"git\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"ssh.system_info\": {\n      \"intent\": \"ssh.system_info\",\n      \"description\": \"Remote system snapshot via SSH.\",\n      \"runbook\": \"ssh.system_info\",\n      \"tags\": [\"ssh\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {}\n      },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"ssh.health\": {\n      \"intent\": \"ssh.health\",\n      \"description\": \"Quick SSH reachability check.\",\n      \"runbook\": \"ssh.health\",\n      \"tags\": [\"ssh\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {}\n      },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 292,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "capabilities.json",
        "start_line": 419,
        "end_line": 480,
        "content": "    },\n    \"api.check\": {\n      \"intent\": \"api.check\",\n      \"description\": \"API health check.\",\n      \"runbook\": \"api.check\",\n      \"tags\": [\"api\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"path\"],\n        \"defaults\": { \"path\": \"/health\" },\n        \"map\": {\n          \"base_url\": \"target.api_base_url\"\n        }\n      },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"preflight.k8s\": {\n      \"intent\": \"preflight.k8s\",\n      \"description\": \"Preflight kubectl + kubeconfig connectivity check.\",\n      \"runbook\": \"preflight.k8s\",\n      \"tags\": [\"k8s\", \"diagnostic\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"namespace\"],\n        \"defaults\": { \"namespace\": \"default\" },\n        \"map\": {\n          \"kubeconfig\": \"target.kubeconfig\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"k8s\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"preflight.ssh\": {\n      \"intent\": \"preflight.ssh\",\n      \"description\": \"Preflight SSH connectivity and auth.\",\n      \"runbook\": \"preflight.ssh\",\n      \"tags\": [\"ssh\", \"diagnostic\", \"read\"],\n      \"inputs\": {\n        \"required\": [\"project_name\", \"target_name\"],\n        \"defaults\": {},\n        \"map\": {\n          \"project_name\": \"context.project_name\",\n          \"target_name\": \"context.target_name\"\n        }\n      },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    },\n    \"preflight.node\": {\n      \"intent\": \"preflight.node\",\n      \"description\": \"Preflight Node.js and pnpm versions for repo.\",\n      \"runbook\": \"preflight.node\",\n      \"tags\": [\"node\", \"diagnostic\", \"read\"],\n      \"inputs\": {\n        \"required\": [],\n        \"defaults\": {},\n        \"map\": {\n          \"repo_path\": \"context.root\"\n        }\n      },\n      \"when\": { \"tags_any\": [\"node\"] },\n      \"effects\": { \"kind\": \"read\", \"requires_apply\": false }\n    }\n  }\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 462,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/AGENT_PLAYBOOK.md": [
      {
        "file_path": "docs/AGENT_PLAYBOOK.md",
        "start_line": 1,
        "end_line": 11,
        "content": "[LEGEND]\nGOLDEN_PATH = The recommended sequence that keeps work safe and deterministic.\n\n[CONTENT]\nGolden path ([GOLDEN_PATH]):\n1) Read MAP.md.\n2) Change contracts first (docs/contracts).\n3) Implement.\n4) Add/adjust tests.\n5) Run `./tools/gate` until green.\n6) Refresh the machine index: `./tools/context`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 76,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/DOC_STYLE.md": [
      {
        "file_path": "docs/DOC_STYLE.md",
        "start_line": 1,
        "end_line": 15,
        "content": "[LEGEND]\nCONTEXT_DOC = A Markdown doc written as `[LEGEND]` then `[CONTENT]`.\n\n[CONTENT]\nDoc format (mandatory for every [CONTEXT_DOC]):\n- Repo-root `AGENTS.md` and repo-root `README.md` are freeform Markdown.\n- Every other `.md` MUST be a context doc:\n  - First non-empty line is `[LEGEND]`.\n  - Then a `[CONTENT]` block.\n\nToken rules:\n- Define shared meanings in `LEGEND.md` as `TOKEN = Meaning`.\n- Define doc-specific meanings in the doc‚Äôs own `[LEGEND]`.\n- Do not shadow: a doc MUST NOT redefine a global token locally ([NO_SHADOWING]).\n- Use tokens in content via `[TOKEN]` (optionally `[TOKEN|LEGEND.md]`).",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 153,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md": [
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# Flagship Principal++ GitOps Plan for SentryFrogg\n\nStatus: proposal\n\n## 0) One-line goal\nMake SentryFrogg the **default GitOps control plane for AI agents**: one calm UX surface (`workspace.run(intent_type=gitops.*)`) that safely plans, proposes, syncs, verifies, and rolls back changes across **any repo + any stack** without enabling unsafe local exec.\n\n## 1) Non-goals (to protect cognitive cheapness)\n- No ‚Äú150 tools‚Äù. Keep public surface to **~6 GitOps intents**.\n- No ‚Äúgod tool‚Äù with 200 actions as the primary UX. If a tool grows, it must stay behind `workspace.run(intent_type=...)`.\n- No unbounded scanning, watchers, or hidden side-effects.\n- No secrets in stdout, artifacts, audit, or PR comments.\n- No dependency on `mcp_local` for GitOps (unsafe local stays optional).\n\n## 2) Flagship UX contract (what agents learn)\nAgents should only need these intents (plus `help/legend`):\n\n1. `gitops.status` (read): drift/health summary for a target\n2. `gitops.plan` (read): render + diff + plan + evidence\n3. `gitops.propose` (write, gated): branch/commit/PR with attached evidence\n4. `gitops.sync` (write, gated): reconcile/sync via controller (ArgoCD/Flux)\n5. `gitops.verify` (read): rollout + health + optional metrics checks\n6. `gitops.rollback` (write, gated): revert + sync back + verify\n\nGolden path for an agent:\n```text\nworkspace.run(intent_type=gitops.plan, inputs={...})\nworkspace.run(intent_type=gitops.propose, inputs={...}, apply=true)\nworkspace.run(intent_type=gitops.sync, inputs={...}, apply=true)\nworkspace.run(intent_type=gitops.verify, inputs={...})\n```\n\nAll outputs are `.context` summaries with `R:` artifact references to large payloads.\n\n### 2.1) Operatorless autonomy (agent does the whole loop)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 438,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 39,
        "end_line": 76,
        "content": "Constraint: the agent must be able to ship changes **without a human operator**, while still being safe.\n\nDesign:\n- ‚ÄúOperatorless‚Äù means **no interactive prompts**, no manual approvals at runtime, and bounded self-healing.\n- Prefer platform-native automation knobs instead of inventing a new orchestrator:\n  - GitHub: auto-merge / merge-queue\n  - GitLab: merge when pipeline succeeds\n  - ArgoCD: auto-sync (optional)\n  - Flux: continuous reconcile\n\nAutopilot mode (recommended):\n- Add an optional *single* public intent: `gitops.release` (still keeps the surface small).\n- `gitops.release` is a state machine that orchestrates:\n  `plan ‚Üí propose ‚Üí (CI gates) ‚Üí merge ‚Üí sync ‚Üí verify ‚Üí (rollback if needed)`\n- All loops are bounded:\n  - `max_attempts` for CI re-runs / transient controller errors\n  - time budgets for waits (checks/sync/rollout)\n\nKey safety invariant:\n- Write steps still require `apply=true`, but **no human** is required‚Äîpolicy decides if the target is allowed.\n\n## 3) The single missing primitive: a safe repo/runner tool\n### Why\nGitOps needs **repo-local git + render + diff + patch**. Today that implies unsafe local exec.\n\n### Deliverable\nAdd **one** new MCP tool: `mcp_repo` (safe-by-default).\n\n### Design laws (Principal++)\n- **Sandbox**: all file operations are confined to `repo_root`.\n- **No shell**: only `command` + `args[]` (deny `sh -c`, deny `shell: true`).\n- **Allowlist**: only known binaries/subcommands (configurable per target).\n- **Budgets**: per-call `timeout_ms` and output byte caps; spill into artifacts.\n- **Deterministic receipts**: every meaningful operation writes artifacts:\n  - `artifact://runs/<trace_id>/tool_calls/<span_id>.context`\n  - plus optional `artifact://.../*.patch`, `artifact://.../*.yaml`, `artifact://.../*.json`\n- **Write gating**: any repo mutation requires `apply=true`.\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 464,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 77,
        "end_line": 114,
        "content": "### `mcp_repo` actions (kept small, capability-driven)\nMinimal actions to cover everything without tool explosion:\n\n#### Read\n- `repo_info`: root, git root, remotes, default branch, clean/dirty, last commits\n- `git_diff`: unified diff (or diffstat) into artifact\n- `render`: produce rendered manifests (helm/kustomize/plain) into artifact\n\n#### Write (requires apply=true)\n- `apply_patch`: apply a unified diff patch (artifact produced)\n- `git_commit`: create commit (message template enforced)\n- `git_push`: push branch (policy-gated)\n\n#### Exec (still one action, but safe)\n- `exec`: allowlisted command runner for: `git`, `kubectl`, `helm`, `kustomize`, `flux`, `argocd`\n\nNotes:\n- ‚ÄúMany features‚Äù live as runbooks built from these primitives.\n- If a new stack appears, we add a **runbook**, not a new tool.\n\n## 4) Context-driven routing (works on ‚Äúany project‚Äù)\nWe already have `mcp_context` tags. Extend detection to add GitOps-relevant tags:\n- `argocd` (e.g. marker files/dirs: `argocd-apps/`, `applicationset`, `argocd` manifests)\n- `flux` (marker: `gotk-components.yaml`, `kustomization.toolkit.fluxcd.io`, `helmrelease` CRDs)\n- `gitops` (derived: `argocd || flux`)\n- `kustomize` vs `helm` already exist (`k8s`, `helm`)\n\nRouting model:\n- capabilities define `when.tags_any` and `depends_on`.\n- the agent always calls `gitops.*` intents; SentryFrogg chooses the correct internal plan.\n\n## 5) Capability graph (intents compile to an execution pipeline)\nEach public intent is backed by a root capability. Dependencies stitch the pipeline:\n\nExample (conceptual):\n```text\ngitops.plan\n  depends_on: preflight.repo, preflight.k8s, preflight.controller",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 414,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 115,
        "end_line": 152,
        "content": "  ‚Üí render (helm/kustomize)\n  ‚Üí diff (cluster/controller)\n  ‚Üí plan summary + evidence\n```\n\nKey principle: **effects aggregation** (already in IntentManager) must remain strict:\n- any write in the chain ‚áí `requires_apply=true`\n- dry-run by default; execution requires explicit `apply=true`\n\n## 6) Controller integrations (no new tools)\nUse `mcp_api_client` as the only HTTP primitive; implement controllers as runbooks:\n\n### ArgoCD\n- status/health/sync/rollback via ArgoCD API (or `argocd` CLI via `mcp_repo.exec` as fallback)\n\n### Flux\n- reconcile/suspend/resume + status via Kubernetes API (prefer `kubectl` JSON; CLI via `mcp_repo.exec`)\n\nRule:\n- Prefer HTTP APIs where stable.\n- Prefer `kubectl` JSON for portable health/status.\n- Store big controller payloads as artifacts; return `.context` summary.\n\n## 7) PR/MR automation (no new tools)\nImplement provider adapters as **runbooks + presets** on top of `mcp_api_client`:\n- GitHub: create branch (via `mcp_repo`), push, open PR, comment evidence, wait for checks\n- GitLab: same for MR\n\nProvider selection:\n- detect from git remote in `mcp_repo.repo_info`.\n- allow override via inputs / project target.\n\n## 7.1) CI/CD gates (close the ‚Äúdelivery loop‚Äù without new tools)\nGitOps becomes flagship only when it can **safely close the loop**:\n\n- `gitops.propose` SHOULD:\n  - publish evidence (plan/diff) into PR/MR,\n  - detect CI provider from repo markers (`.github/workflows`, `gitlab-ci.yml`, `Jenkinsfile`, etc.),",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 369,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 153,
        "end_line": 190,
        "content": "  - wait for required checks to pass (bounded by time/output budgets),\n  - optionally enable auto-merge or perform merge (policy-gated).\n\nImplementation approach (keep tools small):\n- Use `mcp_repo.repo_info` for remote detection + branch naming.\n- Use `mcp_api_client` for GitHub/GitLab CI status + logs/artifacts URLs.\n- Spill CI logs/artifacts into `artifact://...` and return a `.context` summary.\n\nResult: agents do not need a separate ‚Äúcicd.*‚Äù surface for the common path; it is embedded into `propose`.\n\n## 7.2) Supply-chain integration (images, provenance, scans) without becoming a shovel\nTreat supply-chain as **verifiers** and **materializers**, not new tools.\n\n### Verifiers (read)\nRun during `gitops.plan` and/or `gitops.verify` depending on policy:\n- resolve image digest(s) (tag ‚Üí digest) via registry HTTP API\n- verify signatures/attestations if configured (prefer API-based services; CLI only via allowlisted `mcp_repo.exec` and only if present)\n- fetch SBOM / scan reports (Snyk/Trivy server/Aqua/etc.) via `mcp_api_client`\n\n### Materializers (write, gated)\nWhen policy requires immutability:\n- update manifests to pin digests instead of tags (done via `mcp_repo.apply_patch`)\n\nEvidence outputs (artifacts-first):\n- `registry.resolve.json`, `sbom.json`, `scan.json`, `attestation.json` as artifacts\n- `.context` summary with the verdict + links\n\n## 7.3) Observability gates (metrics/errors) as part of `gitops.verify`\nTo be ‚Äúprincipal‚Äù in production, GitOps must answer: **did the release improve or degrade the system?**\n\nModel this as optional, pluggable verifiers executed by `gitops.verify`:\n- rollout status (k8s) and controller health (Argo/Flux)\n- SLO-ish checks (latency/error rate) via Prometheus-compatible APIs\n- error regressions via an error tracker API (Sentry, etc.)\n\nKeep it tool-light:\n- Use `mcp_api_client` to query metrics/error services.\n- Store large time series / raw responses as artifacts; return only verdict summaries in `.context`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 496,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 191,
        "end_line": 228,
        "content": "\nPolicy hooks:\n- fail verification if thresholds exceeded\n- auto-suggest `gitops.rollback` when verification fails\n\n## 8) Policy + safety gates (must feel boring)\n\n## 8) Policy + safety gates (must feel boring)\n### Hard gates\n- `apply=true` required for:\n  - repo mutations (`apply_patch`, `git_commit`, `git_push`)\n  - controller sync/rollback\n- `diff-before-apply`:\n  - `gitops.sync` requires an existing `gitops.plan` artifact in the same `trace_id` (or explicit override)\n\n### Target allowlists (per project.target)\n- allowed git remotes/orgs\n- allowed clusters/kubeconfigs\n- allowed namespaces/resources (optional but recommended)\n\n### Governance (principal-level)\nKeep these as **policy fields on project targets** (not new tools):\n- required approvals / CODEOWNERS expectations (enforced by PR provider)\n- change windows (time-based allow/deny)\n- environment locks (prevent concurrent deploys to the same target)\n- required checks (CI contexts) and required evidence artifacts\n\n### Operatorless policy profile\nTo enable autonomy without humans, define a policy profile per target:\n- `mode: operatorless` (explicit opt-in)\n- allowed write scopes (what targets/resources can be changed)\n- required gates (CI pass, plan artifact present, verify pass)\n- rollback strategy (auto rollback on verify failure)\n\nHard rule:\n- If policy cannot prove safety within declared bounds, it must fail-closed (no ‚Äúask operator‚Äù).\n\n### Secret discipline",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 361,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 229,
        "end_line": 266,
        "content": "- redact aggressively (already present)\n- forbid copying `.env`, kubeconfigs, private keys into artifacts\n\n### Identity & credentials (universal projects)\nDo not add a dozen cloud tools.\n\nPrincipal approach:\n- Prefer **short-lived tokens** (OIDC) issued by CI/provider where possible.\n- Store long-lived credentials only in Vault/profiles; keep them out of repo.\n- Extend SecretRef patterns only when there is a clear, stable contract (e.g. `ref:env:*`, `ref:vault:*` already exist).\n\nTarget configuration SHOULD define where tokens come from:\n- git provider token / app installation\n- controller token (Argo) or kubeconfig\n- registry credentials (if needed)\n- observability API tokens\n\n## 9) Evidence model (artifact-first)\nFor each GitOps run, produce a consistent artifact set:\n- `plan.context` (human+agent readable)\n- `render.yaml` (large)\n- `diff.patch` (large)\n- `controller.status.json` (large)\n- `ci.status.json` / `ci.logs.txt` (large, when applicable)\n- `supplychain.*.json` (sbom/scan/attestation, when applicable)\n- `observe.metrics.json` / `observe.errors.json` (large, when applicable)\n- `pr.context` (PR url + IDs)\n- `verify.context` (what checks passed/failed)\n\nStdout remains calm `.context`:\n- `A:` summary line\n- `R:` links\n- `E:` on errors (typed)\n\n## 10) Testing strategy (flagship quality)\n### Unit tests\n- path traversal / sandbox escapes\n- allowlist enforcement (`sh -c` and unknown binaries denied)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 356,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 267,
        "end_line": 304,
        "content": "- apply gating for write actions\n- artifact writing + size capping\n\n### Integration tests (Docker)\n- local git repo fixture: branch/commit/patch\n- render fixtures (helm/kustomize) (skip if tools missing; gate by preflight)\n\n### Contract tests\n- tools/list schema remains OpenAI-compatible\n- `.context` output always includes `[LEGEND]` + `[CONTENT]` and never leaks secrets\n\n### Autopilot tests\n- bounded wait behavior (CI wait/sync wait/rollout wait)\n- bounded retries (transient failures)\n- rollback path correctness (verify failure triggers rollback and evidence)\n\n## 11) Milestones (execution order)\n1) **MVP Safe Runner**: `mcp_repo` sandbox + allowlist + artifacts + apply gating\n2) **GitOps Plan**: `gitops.plan` (render+diff) + evidence artifacts\n3) **Propose**: branch/commit/push + GitHub PR (then GitLab)\n4) **CI Gates**: required checks + bounded log/artifact capture + merge policy\n5) **Verify Gates**: rollout + metrics/error verifiers (policy-thresholded)\n6) **Controller Ops**: ArgoCD/Flux sync + rollback primitives (policy-gated)\n7) **Hardening**: policy allowlists, diff-before-apply, change windows/locks, perf, failure modes\n\n## 12) Success metrics\n- Agent can ship a GitOps change with <5 calls and no manual glue.\n- No unsafe local needed for normal GitOps workflows.\n- All write operations are gated, auditable, and reproducible from artifacts.\n- Outputs stay small and high-signal; large payloads always spill into artifacts.\n- CI results and verify gates are visible as artifacts and summarized in `.context`.\n- Operatorless: a full release can be executed end-to-end via `workspace.run(intent_type=gitops.release, apply=true)` with no interactive steps.\n\n## 13) Implementation decomposition (–∞—Ç–æ–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏ ‚â•20 –º–∏–Ω—É—Ç)\n\n–ù–∏–∂–µ ‚Äî –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è ¬´–¥–æ –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏¬ª –≤ —Ç–µ–∫—É—â–µ–º SentryFrogg MCP. –ö–∞–∂–¥—ã–π —à–∞–≥:\n- —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –Ω–∞ **–æ–¥–Ω—É PR-–∏—Ç–µ—Ä–∞—Ü–∏—é** –∏ –æ–±—ã—á–Ω–æ –∑–∞–Ω–∏–º–∞–µ—Ç **20‚Äì90 –º–∏–Ω—É—Ç**;\n- –∏–º–µ–µ—Ç **—á—ë—Ç–∫–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ Done**, **–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–µ—Å—Ç—ã**, –∏ **—è–≤–Ω—ã–µ –±–ª–æ–∫–µ—Ä—ã**;",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 535,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 305,
        "end_line": 342,
        "content": "- –¥–æ–ª–∂–µ–Ω –∑–∞–≤–µ—Ä—à–∞—Ç—å—Å—è –∑–µ–ª—ë–Ω—ã–º–∏ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞–º–∏: `npm run check && npm test`.\n\n### Milestone 1 ‚Äî MVP Safe Runner: `mcp_repo`\n\n#### M1.1 ‚Äî –í—ã–¥–µ–ª–∏—Ç—å –æ–±—â–∏–π —Å–ª–æ–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤ (–ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º–∏)\n- **Goal**: —á—Ç–æ–±—ã `mcp_repo` (–∏ –¥—Ä—É–≥–∏–µ –±—É–¥—É—â–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã) –º–æ–≥–ª–∏ –ø–∏—Å–∞—Ç—å –∫—Ä—É–ø–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ `SF_CONTEXT_REPO_ROOT` —Ç–∞–∫ –∂–µ, –∫–∞–∫ —ç—Ç–æ —É–∂–µ –¥–µ–ª–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä.\n- **Implementation**:\n  - –≤—ã–Ω–µ—Å—Ç–∏ –ª–æ–≥–∏–∫—É —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø—É—Ç–µ–π/–∫–∞—Ç–∞–ª–æ–≥–æ–≤/URI `artifact://...` –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–æ–¥—É–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä `src/utils/artifacts.ts` –∏–ª–∏ `src/services/ArtifactService.ts`);\n  - –æ–±–µ—Å–ø–µ—á–∏—Ç—å API —É—Ä–æ–≤–Ω—è: `writeTextArtifact({ trace_id, span_id, filename, content }) -> { uri, abs_path, bytes }` –∏ `writeBinaryArtifact(...)`;\n  - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞—Ç–æ–º–∞—Ä–Ω—É—é –∑–∞–ø–∏—Å—å (—á–µ—Ä–µ–∑ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ `fsAtomic.ts`).\n- **Done criteria**:\n  - –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ `SF_CONTEXT_REPO_ROOT` –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è **—Ç–æ–ª—å–∫–æ** –ø–æ–¥ —ç—Ç–∏–º –∫–æ—Ä–Ω–µ–º;\n  - –ª—é–±—ã–µ –ø–æ–ø—ã—Ç–∫–∏ path traversal (–≤–∫–ª—é—á–∞—è `..`, –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –ø—É—Ç–∏, UNC) –ø—Ä–∏–≤–æ–¥—è—Ç –∫ fail-closed –æ—à–∏–±–∫–µ;\n  - —Ñ–æ—Ä–º–∞—Ç URI —Å—Ç–∞–±–∏–ª–µ–Ω (–ø–æ –ø–ª–∞–Ω—É: `artifact://runs/<trace_id>/...`).\n- **Tests**:\n  - –¥–æ–±–∞–≤–∏—Ç—å `tests/artifacts.test.ts`: –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø—É—Ç—å, –∑–∞–ø—Ä–µ—Ç traversal, –∑–∞–ø–∏—Å—å/—á—Ç–µ–Ω–∏–µ, –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ (–º–∏–Ω–∏–º—É–º 0600 –¥–ª—è —Ñ–∞–π–ª–æ–≤).\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å –µ–¥–∏–Ω—ã–π ¬´layout¬ª –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤ (–∫–∞—Ç–∞–ª–æ–≥–∏/–∏–º–µ–Ω–∞) –º–µ–∂–¥—É —Å–µ—Ä–≤–µ—Ä–æ–º –∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º–∏.\n\n#### M1.2 ‚Äî –°–∫–µ–ª–µ—Ç `RepoManager` + —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ DI/ToolExecutor + schema\n- **Goal**: –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π MCP tool `mcp_repo` (–ø–æ–∫–∞ –±–µ–∑ –ø–æ–ª–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏), —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –Ω–∞—Ä–∞—â–∏–≤–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ.\n- **Implementation**:\n  - —Å–æ–∑–¥–∞—Ç—å `src/managers/RepoManager.ts` —Å–æ switch –ø–æ `action` –∏ –±–∞–∑–æ–≤–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤;\n  - –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä –≤ `src/bootstrap/ServiceBootstrap.ts` –∏ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤ `ToolExecutor` (–∫–∞–∫ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ–Ω–µ–¥–∂–µ—Ä—ã);\n  - –¥–æ–±–∞–≤–∏—Ç—å `mcp_repo` –≤ `tools/list` schema –≤ `sentryfrogg_server.ts` (OpenAI-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π inputSchema).\n- **Done criteria**:\n  - `tools/list` —Å–æ–¥–µ—Ä–∂–∏—Ç `mcp_repo` —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –Ω–∞–±–æ—Ä–æ–º –ø–æ–ª–µ–π `action`, `repo_root`, `output?` (–±–µ–∑ ‚Äúsemantic fields‚Äù);\n  - –≤—ã–∑–æ–≤ `mcp_repo` —Å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–º `action` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –æ—à–∏–±–∫—É;\n  - –Ω–∏—á–µ–≥–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `mcp_local`.\n- **Tests**:\n  - `tests/schema-openai-compat.test.ts`: `mcp_repo` –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏ schema –≤–∞–ª–∏–¥–Ω–∞;\n  - –Ω–æ–≤—ã–π `tests/repo-manager.test.ts`: unknown action ‚Üí error.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –≥–¥–µ –±—Ä–∞—Ç—å `repo_root` –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–∏–∑ `project.repo_root`/`context.root`/`args.repo_root`).\n\n#### M1.3 ‚Äî Sandbox: –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–µ–π + –∑–∞–ø—Ä–µ—Ç –≤—ã—Ö–æ–¥–∞ –∑–∞ `repo_root`\n- **Goal**: –æ–±–µ—Å–ø–µ—á–∏—Ç—å ¬´–∂–µ–ª–µ–∑–Ω—ã–π¬ª sandbox –¥–ª—è –ª—é–±—ã—Ö —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π `mcp_repo`.\n- **Implementation**:",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 906,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 343,
        "end_line": 380,
        "content": "  - –¥–æ–±–∞–≤–∏—Ç—å —É—Ç–∏–ª–∏—Ç—É `resolveRepoPath(repo_root, rel)`:\n    - –≤—Å–µ–≥–¥–∞ `path.resolve(repo_root, rel)`;\n    - –∑–∞–ø—Ä–µ—Ç `..`/–∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –ø—É—Ç–µ–π/–ø—É—Å—Ç—ã—Ö –ø—É—Ç–µ–π;\n    - –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ ‚Äî –¥–µ—Ç–µ–∫—Ç symlink-escape (—á–µ—Ä–µ–∑ `realpath`) –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏.\n  - –ø–æ–∫—Ä—ã—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –Ω—É–∂–Ω—ã –¥–∞–ª—å—à–µ: —á—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ (–¥–ª—è render), –∑–∞–ø–∏—Å—å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤, –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ patch.\n- **Done criteria**:\n  - –ª—é–±—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ `/etc/passwd`, `../secret`, `C:\\Windows\\...` –∏ —Ç.–ø. fail-closed;\n  - –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ symlink –≤–Ω—É—Ç—Ä–∏ repo, –≤–µ–¥—É—â–µ–≥–æ –Ω–∞—Ä—É–∂—É, –¥–æ—Å—Ç—É–ø –Ω–∞—Ä—É–∂—É —Ç–∞–∫–∂–µ –∑–∞–ø—Ä–µ—â—ë–Ω.\n- **Tests**:\n  - `tests/repo-sandbox.test.ts`: traversal, absolute path, symlink escape.\n- **Blockers**:\n  - symlink-–ø–æ–ª–∏—Ç–∏–∫–∞: —Ä–µ—à–∏—Ç—å, —Ä–∞–∑—Ä–µ—à–∞–µ–º –ª–∏ —á—Ç–µ–Ω–∏–µ symlink –≤–Ω—É—Ç—Ä–∏ repo, –µ—Å–ª–∏ realpath –æ—Å—Ç–∞—ë—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ repo.\n\n#### M1.4 ‚Äî `mcp_repo.exec`: allowlist + no-shell + budgets + spill-to-artifacts\n- **Goal**: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π runner, –ø—Ä–∏–≥–æ–¥–Ω—ã–π –¥–ª—è `git`, `kubectl`, `helm`, `kustomize`, `argocd`, `flux`.\n- **Implementation**:\n  - `exec` –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ `{ command: string, args: string[] }`, –≤—Å–µ–≥–¥–∞ `shell=false`;\n  - denylist: `sh`, `bash`, `cmd`, `powershell`, –∞ —Ç–∞–∫–∂–µ –ª—é–±—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –ø–µ—Ä–µ–¥–∞—Ç—å `-c`/`/c` –≤ args –¥–ª—è shell-like –∫–æ–º–∞–Ω–¥;\n  - allowlist –∫–æ–º–∞–Ω–¥ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∫–æ–Ω—Ñ–∏–≥–æ–º (–Ω–∞ —Å—Ç–∞—Ä—Ç–µ ‚Äî env –∏–ª–∏ `project.targets[*].policy.repo.allowlist`);\n  - —Ç–∞–π–º–∞—É—Ç (`timeout_ms`) + –ª–∏–º–∏—Ç stdout/stderr (–Ω–∞–ø—Ä–∏–º–µ—Ä `max_bytes`) —Å –ø—Ä–æ–ª–∏–≤–æ–º –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç.\n- **Done criteria**:\n  - `mcp_repo.exec` –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –æ—Ç–∫–ª–æ–Ω—è–µ—Ç –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—É—é –∫–æ–º–∞–Ω–¥—É –∏ –ª—é–±—ã–µ shell-–ø–∞—Ç—Ç–µ—Ä–Ω—ã;\n  - stdout/stderr > –ª–∏–º–∏—Ç–∞ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è inline –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã;\n  - `duration_ms`, `exit_code`, `timed_out` –≤—Å–µ–≥–¥–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç.\n- **Tests**:\n  - `tests/repo-exec-allowlist.test.ts`: deny/allow; `sh -c` –æ—Ç–∫–ª–æ–Ω—è–µ—Ç—Å—è;\n  - `tests/repo-exec-budgets.test.ts`: –±–æ–ª—å—à–æ–π stdout ‚Üí artifact ref.\n- **Blockers**:\n  - –Ω—É–∂–Ω–∞ –µ–¥–∏–Ω–∞—è –ø–æ–ª–∏—Ç–∏–∫–∞ ¬´—á—Ç–æ –∏–º–µ–Ω–Ω–æ allowlisted –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é¬ª (–º–∏–Ω–∏–º—É–º `git`).\n\n#### M1.5 ‚Äî Git primitives: `repo_info`, `git_diff`, `apply_patch`, `git_commit`, `git_push`\n- **Goal**: –ø–æ–∫—Ä—ã—Ç—å –≤–µ—Å—å GitOps workflow –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ git-–ø—Ä–∏–º–∏—Ç–∏–≤–∞–º–∏.\n- **Implementation**:\n  - `repo_info`: git root, remote urls, default branch (best-effort), dirty/clean, current branch, last N commits;\n  - `git_diff`: diffstat + full diff –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç;\n  - `apply_patch`: –ø—Ä–∏–º–µ–Ω–∏—Ç—å unified diff patch –≤ sandbox (–∏ –≤–µ—Ä–Ω—É—Ç—å –∏—Ç–æ–≥–æ–≤—ã–π diffstat);\n  - `git_commit`: –∫–æ–º–º–∏—Ç —Å —à–∞–±–ª–æ–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏—è; –∑–∞–ø—Ä–µ—Ç –ø—É—Å—Ç—ã—Ö –∫–æ–º–º–∏—Ç–æ–≤; –≤–æ–∑–≤—Ä–∞—Ç sha;\n  - `git_push`: push –≤ remote/branch, policy-gated.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 815,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 381,
        "end_line": 418,
        "content": "  - **Write gating**: –ª—é–±—ã–µ –º—É—Ç–∞—Ü–∏–∏ —Ç—Ä–µ–±—É—é—Ç `apply=true` (—Å–º. —Ç–∞–∫–∂–µ M2.2 –ø—Ä–æ –ø—Ä–æ–±—Ä–æ—Å apply –≤ runbook inputs).\n- **Done criteria**:\n  - –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ –º–æ–∂–Ω–æ: —Å–æ–∑–¥–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ ‚Üí `apply_patch` ‚Üí `git_commit` ‚Üí `git_push` –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π bare remote;\n  - –±–µ–∑ `apply=true` –ª—é–±—ã–µ write-action –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç fail-closed;\n  - –±–æ–ª—å—à–∏–µ diff‚Äô—ã —É—Ö–æ–¥—è—Ç –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.\n- **Tests**:\n  - `tests/repo-git-primitives.test.ts`: init temp repo + bare remote; —Å—Ü–µ–Ω–∞—Ä–∏–π commit/push;\n  - `tests/repo-write-gating.test.ts`: –±–µ–∑ apply=true –º—É—Ç–∞—Ü–∏–∏ –∑–∞–ø—Ä–µ—â–µ–Ω—ã.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –Ω–∞–ª–∏—á–∏–µ `git` –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏ —Ç–µ—Å—Ç–æ–≤/CI.\n\n### Milestone 2 ‚Äî GitOps Plan/Status: `gitops.status`, `gitops.plan`\n\n#### M2.1 ‚Äî –†–∞—Å—à–∏—Ä–∏—Ç—å Context markers: `argocd`, `flux`, `gitops`\n- **Goal**: –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ `context.tags` –¥–ª—è –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏ GitOps.\n- **Implementation**:\n  - –¥–æ–±–∞–≤–∏—Ç—å –≤ `src/services/ContextService.ts` –º–∞—Ä–∫–µ—Ä—ã:\n    - `argocd`: `applicationset`, `argocd` manifests, `argocd-apps/`;\n    - `flux`: `gotk-components.yaml`, `kustomization.toolkit.fluxcd.io`, `helmrelease` CRDs;\n  - –¥–æ–±–∞–≤–∏—Ç—å derived tags: `gitops = argocd || flux` (–ª–∏–±–æ –Ω–∞ —É—Ä–æ–≤–Ω–µ tags derivation).\n- **Done criteria**:\n  - –Ω–∞ fixture-–¥–µ—Ä–µ–≤—å—è—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ç–µ–≥–∏ –≤—ã—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ;\n  - `workspace.summary` –Ω–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å gitops-capabilities —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Ç–µ–≥–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç.\n- **Tests**:\n  - —Ä–∞—Å—à–∏—Ä–∏—Ç—å `tests/context-service.test.ts`: —Ñ–∏–∫—Å—Ç—É—Ä—ã –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏ ‚Üí –æ–∂–∏–¥–∞–µ–º—ã–µ tags.\n- **Blockers**:\n  - –Ω—É–∂–Ω–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å ¬´–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã¬ª, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ª–æ–∂–Ω—ã—Ö —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–π.\n\n#### M2.2 ‚Äî –ü—Ä–æ–±—Ä–æ—Å `apply` –≤ runbook input + –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è —Ä–µ–∑–æ–ª—é—Ü–∏—è capability (routing)\n- **Goal**: (1) tool-level write gating —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–¥ `mcp_intent`/`workspace.run`; (2) –æ–¥–∏–Ω public intent –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π –ø–æ `when`.\n- **Implementation**:\n  - **apply**: –ø—Ä–∏ `IntentManager.execute` –¥–æ–±–∞–≤–ª—è—Ç—å `apply` –≤ `step.inputs` (–∏–ª–∏ –≤ –æ–±—â–∏–π input), —á—Ç–æ–±—ã runbook –º–æ–≥ –ø—Ä–æ–∫–∏–¥—ã–≤–∞—Ç—å `apply: {{ input.apply }}` –≤ `mcp_repo` write actions;\n  - **routing**: —Ä–∞—Å—à–∏—Ä–∏—Ç—å `CapabilityService.findByIntent(...)`/`IntentManager.resolveCapability(...)`:\n    - —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ capabilities —Å `intent == <intentType>`;\n    - –≤—ã–±—Ä–∞—Ç—å —Ç—É, —É –∫–æ—Ç–æ—Ä–æ–π `when` –º–∞—Ç—á–∏—Ç—Å—è —Å `intent.inputs.context` (—á–µ—Ä–µ–∑ `matchesWhen`);\n    - –ø—Ä–∏ –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏ ‚Äî –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π tie-break (–Ω–∞–ø—Ä–∏–º–µ—Ä —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ name).\n- **Done criteria**:\n  - `mcp_repo.apply_patch` –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ runbook —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –≤–Ω–µ—à–Ω–∏–π intent –±—ã–ª `apply=true`;",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 791,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 419,
        "end_line": 456,
        "content": "  - –º–æ–∂–Ω–æ –∑–∞–≤–µ—Å—Ç–∏ –¥–≤–µ capabilities —Å –æ–¥–Ω–∏–º intent (–Ω–∞–ø—Ä–∏–º–µ—Ä `gitops.plan.argocd` –∏ `gitops.plan.flux`) –∏ –≤–∏–¥–µ—Ç—å, —á—Ç–æ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ tags.\n- **Tests**:\n  - `tests/intent-manager.test.ts`: –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ `input.apply` –¥–æ—Å—Ç—É–ø–µ–Ω –≤–Ω—É—Ç—Ä–∏ runbook input;\n  - –Ω–æ–≤—ã–π `tests/capability-routing.test.ts`: –¥–≤–µ capabilities —Å —Ä–∞–∑–Ω—ã–º–∏ `when` ‚Üí –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –æ–∂–∏–¥–∞–µ–º–∞—è.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ ¬´–Ω–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π when¬ª (fail –∏–ª–∏ fallback).\n\n#### M2.3 ‚Äî `mcp_repo.render`: kustomize/helm/plain + –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã\n- **Goal**: –µ–¥–∏–Ω—ã–π render primitive –¥–ª—è `gitops.plan`.\n- **Implementation**:\n  - `render` action –≤ `mcp_repo`:\n    - `type: kustomize | helm | plain` (–∏–ª–∏ autodetect –ø–æ `context.tags`);\n    - –Ω–∞ –≤—ã—Ö–æ–¥ ‚Äî `render.yaml` –∞—Ä—Ç–µ—Ñ–∞–∫—Ç;\n    - –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ inline —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.\n  - –≤–∞–ª–∏–¥–∞—Ü–∏–∏: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å allowlisted, –∏–Ω–∞—á–µ fail-closed —Å –ø–æ–Ω—è—Ç–Ω–æ–π –æ—à–∏–±–∫–æ–π.\n- **Done criteria**:\n  - –¥–ª—è kustomize overlay/helm chart –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å—Ç–∞–±–∏–ª—å–Ω—ã–π `artifact://.../render.yaml`;\n  - –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –±–∏–Ω–∞—Ä—è (helm/kubectl) ‚Äî –ø–æ–Ω—è—Ç–Ω—ã–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–π error –±–µ–∑ –ø–∞–¥–µ–Ω–∏—è –≤—Å–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ (–≤ —Ä–∞–º–∫–∞—Ö –ø–æ–ª–∏—Ç–∏–∫–∏).\n- **Tests**:\n  - `tests/repo-render.test.ts`: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π plain render (–±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –±–∏–Ω–∞—Ä–µ–π);\n  - –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: kustomize/helm —Ç–µ—Å—Ç—ã —Å —É—Å–ª–æ–≤–Ω—ã–º skip, –µ—Å–ª–∏ –±–∏–Ω–∞—Ä—å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.\n- **Blockers**:\n  - –Ω–∞–ª–∏—á–∏–µ `kubectl`/`kustomize`/`helm` –≤ CI (–µ—Å–ª–∏ —Ö–æ—Ç–∏–º –Ω–µ-skip).\n\n#### M2.4 ‚Äî –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `gitops.status` –∏ `gitops.plan` (capabilities + runbooks + evidence)\n- **Goal**: –æ–±–µ—Å–ø–µ—á–∏—Ç—å ¬´golden path¬ª `gitops.plan` —Å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞–º–∏ –∏ —Å–ø–æ–∫–æ–π–Ω—ã–º `.context` –≤—ã–≤–æ–¥–æ–º.\n- **Implementation**:\n  - –¥–æ–±–∞–≤–∏—Ç—å capabilities –≤ `capabilities.json`:\n    - `gitops.status.*` (read)\n    - `gitops.plan.*` (read)\n  - –¥–æ–±–∞–≤–∏—Ç—å runbooks –≤ `runbooks.json`, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ `mcp_repo.repo_info`, `mcp_repo.render`, `mcp_repo.exec(kubectl diff)`;\n  - –≤–µ—Ä–Ω—É—Ç—å `.context` summary + `R:` —Å—Å—ã–ª–∫–∏ –Ω–∞ `render.yaml`, `diff.patch`, `plan.context`.\n- **Done criteria**:\n  - `workspace.run(intent_type=gitops.plan, ...)` –≤ dry-run —Ä–µ–∂–∏–º–µ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –ø–ª–∞–Ω (IntentManager.preview) –±–µ–∑ side-effects;\n  - `workspace.run(..., apply=true)` **–Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è** (—ç—Ç–æ read intent), –Ω–æ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è;\n  - –∫—Ä—É–ø–Ω—ã–µ payload‚Äô—ã –≤—Å–µ–≥–¥–∞ –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞—Ö, stdout –æ—Å—Ç–∞—ë—Ç—Å—è –∫–æ—Ä–æ—Ç–∫–∏–º.\n- **Tests**:\n  - `tests/gitops-plan.test.ts`: —Å–æ–±—Ä–∞—Ç—å in-memory ToolExecutor stub (–∏–ª–∏ —Ä–µ–∞–ª—å–Ω—ã–π RepoManager –Ω–∞ temp repo) –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å:",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 780,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 457,
        "end_line": 494,
        "content": "    - –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Å–æ–∑–¥–∞–Ω—ã;\n    - stdout –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≥–∏–≥–∞–Ω—Ç—Å–∫–∏—Ö –∫—É—Å–∫–æ–≤ yaml/diff.\n- **Blockers**:\n  - –Ω—É–∂–µ–Ω –¥–æ–≥–æ–≤–æ—Ä –æ —Ñ–æ—Ä–º–∞—Ç–µ `plan.context` (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø–æ–ª—è, —Å—Å—ã–ª–∫–∏, summary).\n\n### Milestone 3 ‚Äî Propose: `gitops.propose` (branch/commit/push + PR/MR)\n\n#### M3.1 ‚Äî –†–µ–ø–æ–∑–∏—Ç–æ—Ä–Ω—ã–π workflow: branch naming + push –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π remote (e2e)\n- **Goal**: –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ Git primitives –ø–æ–∫—Ä—ã–≤–∞—é—Ç —Ä–µ–∞–ª—å–Ω—ã–π ¬´propose¬ª –ø—É—Ç—å.\n- **Implementation**:\n  - –¥–æ–±–∞–≤–∏—Ç—å –≤ `mcp_repo` –ø–æ–¥–¥–µ—Ä–∂–∫—É:\n    - create/switch branch (–µ—Å–ª–∏ —Ä–µ—à–∏–º –≤—ã–¥–µ–ª–∏—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–π action, –∏–ª–∏ —á–µ—Ä–µ–∑ `exec git switch -c` —Å allowlist);\n    - ¬´deterministic branch name¬ª helper (–Ω–∞–ø—Ä–∏–º–µ—Ä `sf/<intent>/<timestamp>-<shortid>`).\n- **Done criteria**:\n  - —Ç–µ—Å—Ç–æ–≤—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π: temp repo ‚Üí branch ‚Üí patch ‚Üí commit ‚Üí push ‚Üí remote —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ—Ç–∫—É –∏ commit.\n- **Tests**:\n  - —Ä–∞—Å—à–∏—Ä–∏—Ç—å `tests/repo-git-primitives.test.ts`: branch+push path.\n- **Blockers**:\n  - –Ω—É–∂–Ω–∞ –ø–æ–ª–∏—Ç–∏–∫–∞ –∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –≤–µ—Ç–æ–∫ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤.\n\n#### M3.2 ‚Äî Git provider detection (GitHub/GitLab) –ø–æ remote URL\n- **Goal**: –∞–≤—Ç–æ–º–∞—Ç–æ–º –≤—ã–±–∏—Ä–∞—Ç—å runbook GitHub vs GitLab.\n- **Implementation**:\n  - –≤ `mcp_repo.repo_info` –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π provider —Å–∏–≥–Ω–∞–ª (`github|gitlab|unknown`) + owner/repo;\n  - –¥–æ–±–∞–≤–∏—Ç—å override —á–µ—Ä–µ–∑ input (–µ—Å–ª–∏ repo unusual).\n- **Done criteria**:\n  - ssh/https remotes –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è;\n  - provider/owner/repo –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è downstream runbooks –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤.\n- **Tests**:\n  - `tests/repo-remote-detect.test.ts`: —Ç–∞–±–ª–∏—Ü–∞ URL ‚Üí –æ–∂–∏–¥–∞–µ–º—ã–π provider/owner/repo.\n- **Blockers**:\n  - –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–æ–≤ URL (git@, https://, self-hosted gitlab).\n\n#### M3.3 ‚Äî GitHub PR propose (runbook) + –∫–æ–Ω—Ç—Ä–∞–∫—Ç–Ω—ã–µ —Ç–µ—Å—Ç—ã —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã–π HTTP server\n- **Goal**: `gitops.propose` —Å–æ–∑–¥–∞—ë—Ç PR + –ø—É–±–ª–∏–∫—É–µ—Ç evidence (links) –±–µ–∑ —Ä—É—á–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞.\n- **Implementation**:\n  - –Ω–æ–≤—ã–π runbook `gitops.propose.github`:\n    - `mcp_repo.*` –¥–ª—è –≤–µ—Ç–∫–∏/–∫–æ–º–º–∏—Ç–∞/push;",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 620,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 495,
        "end_line": 532,
        "content": "    - `mcp_api_client.request` –¥–ª—è:\n      - create PR,\n      - post comment —Å `artifact://...` —Å—Å—ã–ª–∫–∞–º–∏,\n      - –≤–∫–ª—é—á–µ–Ω–∏–µ auto-merge (policy-gated, optional).\n  - capability `gitops.propose` –º–∞—Ä—à—Ä—É—Ç–∏–∑–∏—Ä—É–µ—Ç –Ω–∞ `gitops.propose.github` –ø—Ä–∏ provider=github.\n- **Done criteria**:\n  - PR url + ids –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ `.context` –∫–∞–∫ `R:`;\n  - –ª—é–±—ã–µ —Ç–æ–∫–µ–Ω—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä—É—é—Ç—Å—è/–Ω–µ –ø–æ–ø–∞–¥–∞—é—Ç –≤ stdout/artifacts.\n- **Tests**:\n  - `tests/gitops-propose-github.test.ts`: –ø–æ–¥–Ω—è—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π `http.createServer()` –∫–∞–∫ fake GitHub API:\n    - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å payload –∑–∞–ø—Ä–æ—Å–æ–≤;\n    - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ runbook –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç PR url.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å auth contract –¥–ª—è GitHub (api_profile + Bearer token).\n\n#### M3.4 ‚Äî GitLab MR propose (runbook) + —Ç–µ—Å—Ç—ã —Å fake GitLab\n- **Goal**: parity —Å GitHub.\n- **Implementation**: –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ M3.3, –Ω–æ —Å GitLab endpoints.\n- **Done criteria**: MR url + ids; evidence comment.\n- **Tests**:\n  - `tests/gitops-propose-gitlab.test.ts`: fake server + –∫–æ–Ω—Ç—Ä–∞–∫—Ç –∑–∞–ø—Ä–æ—Å–æ–≤.\n- **Blockers**:\n  - —Ä–∞–∑–ª–∏—á–∏—è GitLab self-hosted URL/path; –Ω—É–∂–µ–Ω –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ç–æ—Ä.\n\n### Milestone 4 ‚Äî CI gates (embedded into `gitops.propose`)\n\n#### M4.1 ‚Äî CI detection + required checks policy\n- **Goal**: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ CI –∏ —Å–ø–∏—Å–æ–∫ required contexts.\n- **Implementation**:\n  - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `ContextService` –º–∞—Ä–∫–µ—Ä—ã (`.github/workflows`, `gitlab-ci.yml`) + provider;\n  - –¥–æ–±–∞–≤–∏—Ç—å policy –Ω–∞ target: `required_checks: [..]`, `max_wait_ms`, `max_attempts`.\n- **Done criteria**:\n  - `gitops.propose` –∑–Ω–∞–µ—Ç, –∫–∞–∫–∏–µ —á–µ–∫–∏ –∂–¥–∞—Ç—å, –∏ —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏.\n- **Tests**:\n  - `tests/ci-detect.test.ts`: fixture repo layout ‚Üí –æ–∂–∏–¥–∞–µ–º—ã–π ci provider.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É—é—Ç—Å—è —Å–æ–≥–ª–∞—à–µ–Ω–∏—è –ø–æ –∏–º–µ–Ω–∞–º check contexts (GitHub) / job names (GitLab).\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 519,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 533,
        "end_line": 570,
        "content": "#### M4.2 ‚Äî Wait-for-checks state machine (bounded) + –ª–æ–≥-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã\n- **Goal**: –∑–∞–∫—Ä—ã—Ç—å delivery loop –¥–æ merge.\n- **Implementation**:\n  - —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å polling (–≤ –∫–æ–¥–µ, –Ω–µ –≤ runbook DSL) –∫–∞–∫ helper (–Ω–∞–ø—Ä–∏–º–µ—Ä `src/core/waiter.ts`):\n    - backoff,\n    - `timeout_ms`,\n    - `max_attempts`.\n  - `gitops.propose` –ø–æ—Å–ª–µ PR/MR:\n    - –æ–ø—Ä–∞—à–∏–≤–∞–µ—Ç CI —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ `mcp_api_client`;\n    - –ø—Ä–∏ fail ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç diagnostics/log URLs –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.\n- **Done criteria**:\n  - –ø—Ä–∏ ‚Äúpending ‚Üí success‚Äù propose –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è success;\n  - –ø—Ä–∏ ‚Äúpending ‚Üí failure‚Äù propose –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è fail-closed –∏ –ø—Ä–∏–∫–ª–∞–¥—ã–≤–∞–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç —Å summary.\n- **Tests**:\n  - `tests/gitops-ci-wait.test.ts`: fake API, —É–ø—Ä–∞–≤–ª—è–µ–º—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ —É—Å–∫–æ—Ä–µ–Ω–Ω—ã–π —Ç–∞–π–º–µ—Ä –∏ –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã).\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–≥–æ–≤–æ—Ä –æ —Ç–æ–º, –≥–¥–µ –±—Ä–∞—Ç—å –ª–æ–≥–∏ (URL‚Äô—ã) –∏ —á—Ç–æ –∏–º–µ–Ω–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å.\n\n#### M4.3 ‚Äî Merge policy (auto-merge / merge queue) + enforcement\n- **Goal**: –æ–ø–µ—Ä–∞—Ç–æ—Äless merge –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö gate‚Äô–∞—Ö.\n- **Implementation**:\n  - –ø–æ–ª–∏—Ç–∏–∫–∞ target: `mode: operatorless`, `merge: auto|manual|queue`;\n  - GitHub/GitLab adapters –≤–∫–ª—é—á–∞—é—Ç auto-merge –∏–ª–∏ –¥–µ–ª–∞—é—Ç merge –≤—ã–∑–æ–≤–æ–º API.\n- **Done criteria**:\n  - –≤ operatorless mode merge –¥–µ–ª–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ success checks;\n  - –µ—Å–ª–∏ –ø–æ–ª–∏—Ç–∏–∫–∞ –∑–∞–ø—Ä–µ—â–∞–µ—Ç merge ‚Äî –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è (no side effects).\n- **Tests**:\n  - —Ä–∞—Å—à–∏—Ä–∏—Ç—å `tests/gitops-propose-github.test.ts`/`gitlab`: –ø—Ä–æ–≤–µ—Ä–∫–∞ ‚Äúmerge denied‚Äù vs ‚Äúmerge allowed‚Äù.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è —á—ë—Ç–∫–æ –æ–ø–∏—Å–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π policy schema –∏ –≥–¥–µ –æ–Ω —Ö—Ä–∞–Ω–∏—Ç—Å—è (projects.json).\n\n### Milestone 5 ‚Äî Verify gates: rollout + observability\n\n#### M5.1 ‚Äî Kubernetes rollout verifier (read) + –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã\n- **Goal**: `gitops.verify` —É–º–µ–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—Ç—å rollout.\n- **Implementation**:\n  - runbook `gitops.verify.k8s.rollout`:\n    - `kubectl rollout status`/`kubectl get ... -o json` —á–µ—Ä–µ–∑ `mcp_repo.exec`;",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 594,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 571,
        "end_line": 608,
        "content": "    - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—ã—Ä–æ–≥–æ json –≤ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç;\n    - –≤–æ–∑–≤—Ä–∞—Ç –∫–æ—Ä–æ—Ç–∫–æ–≥–æ verdict.\n- **Done criteria**:\n  - verifier –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `pass|fail|unknown` (–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–æ–ª–∏—Ç–∏–∫–∏) –∏ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã;\n  - –ø—Ä–∏ –æ—à–∏–±–∫–µ kubectl ‚Äî –ø–æ–Ω—è—Ç–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞.\n- **Tests**:\n  - `tests/gitops-verify-rollout.test.ts`: stub `mcp_repo.exec` (ToolExecutor with fake) ‚Üí –æ–∂–∏–¥–∞–µ–º—ã–π verdict.\n- **Blockers**:\n  - –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ‚Äú—á—Ç–æ –∏–º–µ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º‚Äù (deployments vs rollouts/argo-rollouts).\n\n#### M5.2 ‚Äî Prometheus/SLO verifier —á–µ—Ä–µ–∑ `mcp_api_client`\n- **Goal**: –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ä–µ–≥—Ä–µ—Å—Å–∏–π.\n- **Implementation**:\n  - runbook `gitops.verify.metrics`:\n    - `mcp_api_client.request` –∫ Prometheus API;\n    - thresholds –≤ policy (`error_rate_max`, `p95_latency_max`, –æ–∫–Ω–∞ –≤—Ä–µ–º–µ–Ω–∏);\n    - raw responses ‚Üí –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.\n- **Done criteria**:\n  - –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ thresholds verifier fail;\n  - `.context` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–º–µ–Ω–Ω–æ verdict + —Å—Å—ã–ª–∫—É –Ω–∞ raw.\n- **Tests**:\n  - `tests/gitops-verify-metrics.test.ts`: fake Prometheus server, —Ä–∞–∑–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã ‚Üí pass/fail.\n- **Blockers**:\n  - –Ω—É–∂–µ–Ω –∫–æ–Ω—Ç—Ä–∞–∫—Ç: –≥–¥–µ —Ö—Ä–∞–Ω–∏—Ç—Å—è Prometheus base_url/token (api_profile / target field).\n\n#### M5.3 ‚Äî Error-regression verifier (Sentry-like API) —á–µ—Ä–µ–∑ `mcp_api_client`\n- **Goal**: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ª–æ–≤–∏—Ç—å —Ä–æ—Å—Ç –æ—à–∏–±–æ–∫ –ø–æ—Å–ª–µ deploy.\n- **Implementation**:\n  - runbook `gitops.verify.errors`:\n    - –∑–∞–ø—Ä–æ—Å –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫ –æ—à–∏–±–æ–∫;\n    - thresholds (`new_issues_max`, `error_events_delta_max`).\n- **Done criteria**:\n  - –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π fail –ø—Ä–∏ —Ä–µ–≥—Ä–µ—Å—Å–∏–∏; –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Å raw payload.\n- **Tests**:\n  - `tests/gitops-verify-errors.test.ts`: fake server, pass/fail.\n- **Blockers**:\n  - –∫–æ–Ω–∫—Ä–µ—Ç–∏–∫–∞ API error tracker (—ç–Ω–¥–ø–æ–π–Ω—Ç—ã/–º–æ–¥–µ–ª—å) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ –∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω–∞ –≤ –ø—Ä–µ—Å–µ—Ç—ã.\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 544,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 609,
        "end_line": 646,
        "content": "### Milestone 6 ‚Äî Controller ops: `gitops.sync`, `gitops.rollback`\n\n#### M6.1 ‚Äî ArgoCD sync/status/rollback primitives\n- **Goal**: –ø–æ–¥–¥–µ—Ä–∂–∫–∞ ArgoCD –±–µ–∑ –Ω–æ–≤—ã—Ö tools.\n- **Implementation**:\n  - runbooks:\n    - `gitops.argocd.status` (read),\n    - `gitops.argocd.sync` (write, apply-gated),\n    - `gitops.argocd.rollback` (write, apply-gated);\n  - –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ —á–µ—Ä–µ–∑ HTTP API (`mcp_api_client`), CLI fallback —á–µ—Ä–µ–∑ `mcp_repo.exec`.\n- **Done criteria**:\n  - `gitops.sync`/`gitops.rollback` –≤ operatorless —Ä–µ–∂–∏–º–µ –º–æ–≥—É—Ç –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å sync/rollback;\n  - –∫—Ä—É–ø–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã ArgoCD ‚Üí –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.\n- **Tests**:\n  - `tests/argocd-runbooks.test.ts`: fake ArgoCD server, happy/fail paths.\n- **Blockers**:\n  - –Ω—É–∂–Ω–∞ auth —Å—Ö–µ–º–∞ ArgoCD (api_profile/vault) –∏ —Å–ø–∏—Å–æ–∫ required endpoints.\n\n#### M6.2 ‚Äî Flux reconcile/status primitives\n- **Goal**: –ø–æ–¥–¥–µ—Ä–∂–∫–∞ Flux —á–µ—Ä–µ–∑ Kubernetes API.\n- **Implementation**:\n  - runbooks:\n    - `gitops.flux.status`, `gitops.flux.sync`/`reconcile`, `gitops.flux.rollback` (–µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ);\n  - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ `kubectl` json + `mcp_repo.exec`.\n- **Done criteria**:\n  - reconcile –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ apply=true;\n  - —Å—Ç–∞—Ç—É—Å –æ—Ç–¥–∞—ë—Ç –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π verdict.\n- **Tests**:\n  - `tests/flux-runbooks.test.ts`: ToolExecutor stub + –ø—Ä–æ–≤–µ—Ä–∫–∞ args.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å ¬´–∫–∞–∫–∏–µ CRD –ø—Ä–æ–≤–µ—Ä—è–µ–º¬ª (Kustomization/HelmRelease/GitRepository).\n\n#### M6.3 ‚Äî Root intents: `gitops.sync` –∏ `gitops.rollback` + diff-before-apply\n- **Goal**: –µ–¥–∏–Ω—ã–π UX –¥–ª—è sync/rollback, –≤–∫–ª—é—á–∞—é—â–∏–π hard gate ‚Äúdiff-before-apply‚Äù.\n- **Implementation**:\n  - capabilities: `gitops.sync.*`, `gitops.rollback.*` —Å `effects.requires_apply=true`;\n  - enforce ‚Äúdiff-before-apply‚Äù:\n    - —Ö—Ä–∞–Ω–∏—Ç—å reference –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π `gitops.plan` artifact –≤ `StateService` –≤ —Ä–∞–º–∫–∞—Ö `trace_id`/session;",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 519,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 647,
        "end_line": 684,
        "content": "    - `gitops.sync` –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ plan evidence –∏–ª–∏ explicit override.\n- **Done criteria**:\n  - `gitops.sync` –±–µ–∑ prior plan ‚Üí fail-closed;\n  - —Å plan ‚Üí —Ä–∞–∑—Ä–µ—à–∞–µ—Ç controller sync.\n- **Tests**:\n  - `tests/gitops-diff-before-apply.test.ts`: state seeded ‚Üí allow/deny.\n- **Blockers**:\n  - –Ω—É–∂–Ω–æ —Ä–µ—à–∏—Ç—å: –ø–ª–∞–Ω –ø—Ä–∏–≤—è–∑–∞–Ω –∫ `trace_id` –∏–ª–∏ –∫ project/target (–∏ TTL).\n\n### Milestone 7 ‚Äî Hardening + operatorless `gitops.release`\n\n#### M7.1 ‚Äî Policy engine: allowlists, change windows, locks (fail-closed)\n- **Goal**: —Å–¥–µ–ª–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å ¬´—Å–∫—É—á–Ω–æ–π¬ª: –≤—Å—ë –∑–∞–ø—Ä–µ—â–µ–Ω–æ, –ø–æ–∫–∞ —è–≤–Ω–æ –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ policy.\n- **Implementation**:\n  - –æ–ø–∏—Å–∞—Ç—å policy schema –≤ `projects.json` (–±–µ–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞):\n    - `mode: operatorless`,\n    - allowlist remotes/orgs,\n    - allowlist namespaces/resources,\n    - change windows,\n    - environment lock.\n  - enforcement —Ç–æ—á–∫–∏:\n    - `mcp_repo.git_push`,\n    - `gitops.sync/rollback`,\n    - CI merge.\n- **Done criteria**:\n  - –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ policy –¥–ª—è target –ª—é–±—ã–µ write –æ–ø–µ—Ä–∞—Ü–∏–∏ fail-closed;\n  - lock –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ release –≤ –æ–¥–∏–Ω target.\n- **Tests**:\n  - `tests/gitops-policy.test.ts`: –Ω–∞–±–æ—Ä policy-–∫–µ–π—Å–æ–≤ allow/deny, –≤–∫–ª—é—á–∞—è lock.\n- **Blockers**:\n  - –Ω—É–∂–µ–Ω —Ñ–æ—Ä–º–∞—Ç —Ö—Ä–∞–Ω–µ–Ω–∏—è lock (StateService persistent vs file vs remote).\n\n#### M7.2 ‚Äî `gitops.release`: state machine (plan‚Üípropose‚Üímerge‚Üísync‚Üíverify‚Üírollback)\n- **Goal**: –æ–¥–∏–Ω intent –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –≤–µ—Å—å loop –±–µ–∑ —á–µ–ª–æ–≤–µ–∫–∞.\n- **Implementation**:\n  - —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `gitops.release` –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—É—é capability+runbook **–∏–ª–∏** –∫–∞–∫ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –∫–æ–¥–æ–≤—ã–π orchestrator (–ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ –∫–æ–¥–æ–º, —Ç.–∫. –Ω—É–∂–Ω—ã –æ–∂–∏–¥–∞–Ω–∏—è/—Ä–µ—Ç—Ä–∞–∏);\n  - bounded waits/retries:\n    - CI checks wait,",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 507,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/GITOPS_FLAGSHIP_PRINCIPAL_PLAN.md",
        "start_line": 685,
        "end_line": 716,
        "content": "    - controller sync wait,\n    - rollout/metrics waits,\n    - `max_attempts` + `timeout_ms` –Ω–∞ –∫–∞–∂–¥—ã–π —ç—Ç–∞–ø.\n  - –ø—Ä–∏ verify failure ‚Äî –∞–≤—Ç–æ-–∑–∞–ø—É—Å–∫ `gitops.rollback` (policy-driven).\n- **Done criteria**:\n  - –æ–¥–∏–Ω –≤—ã–∑–æ–≤ `workspace.run(intent_type=gitops.release, apply=true)`:\n    - —Å–æ–∑–¥–∞—ë—Ç PR/MR,\n    - –¥–æ–∂–∏–¥–∞–µ—Ç—Å—è CI,\n    - –º–µ—Ä–∂–∏—Ç,\n    - —Å–∏–Ω–∫–∞–µ—Ç,\n    - –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç,\n    - –ø—Ä–∏ –ø—Ä–æ–≤–∞–ª–µ ‚Äî –¥–µ–ª–∞–µ—Ç rollback,\n    - –≤—Å–µ–≥–¥–∞ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –Ω–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ.\n- **Tests**:\n  - `tests/gitops-release-autopilot.test.ts`: –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞ stubbed ToolExecutor + fake HTTP servers, —Å –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ ‚Äúpending‚Üísuccess/fail‚Äù —Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏.\n- **Blockers**:\n  - —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—ã–±—Ä–∞—Ç—å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É orchestrator (–≤–Ω—É—Ç—Ä–∏ IntentManager vs –æ—Ç–¥–µ–ª—å–Ω—ã–π Manager/Service) –∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç—Ä–∞–∫—Ç –≤—Ö–æ–¥–æ–≤/–≤—ã—Ö–æ–¥–æ–≤.\n\n#### M7.3 ‚Äî End-to-end smoke (–±–µ–∑ –Ω–∞—Å—Ç–æ—è—â–∏—Ö –æ–±–ª–∞–∫–æ–≤): demo repo + fake providers\n- **Goal**: CI-–ø—Ä–æ–≤–µ—Ä—è–µ–º—ã–π e2e –±–µ–∑ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ä–µ–∞–ª—å–Ω—ã–º GitHub/Argo/Prometheus.\n- **Implementation**:\n  - –¥–æ–±–∞–≤–∏—Ç—å/—Ä–∞—Å—à–∏—Ä–∏—Ç—å `integration/smoke.ts`:\n    - —Å–æ–∑–¥–∞—Ç—å temp repo + bare remote,\n    - –ø–æ–¥–Ω—è—Ç—å fake GitHub/GitLab/CI/Argo/Prometheus servers,\n    - –ø—Ä–æ–≥–Ω–∞—Ç—å `gitops.release` –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.\n- **Done criteria**:\n  - `npm run smoke` –ø—Ä–æ—Ö–æ–¥–∏—Ç –ª–æ–∫–∞–ª—å–Ω–æ –∏ –≤ CI —Å—Ä–µ–¥–µ (–±–µ–∑ –≤–Ω–µ—à–Ω–µ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞);\n  - smoke –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–ª—é—á–µ–≤–æ–π –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç: ¬´large payload ‚Üí artifact, stdout ‚Üí calm context¬ª.\n- **Tests**:\n  - smoke —Å–∞–º –ø–æ —Å–µ–±–µ (–∫–∞–∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ç–µ—Å—Ç), –ø–ª—é—Å –∫–æ—Ä–æ—Ç–∫–∏–µ unit —Ç–µ—Å—Ç—ã –¥–ª—è –æ–±—â–∏—Ö helper‚Äô–æ–≤.\n- **Blockers**:\n  - –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è smoke: –Ω—É–∂–Ω–æ —É–¥–µ—Ä–∂–∞—Ç—å –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä <30‚Äì60s).",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 532,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/README.md": [
      {
        "file_path": "docs/README.md",
        "start_line": 1,
        "end_line": 54,
        "content": " [LEGEND]\n\n[CONTENT]\n# Documentation\n\nThis directory contains the long-form documentation for SentryFrogg.\n\n## Quick demo\n1. Configure your MCP client (stdio): see `../mcp_config.md`.\n2. Start the server: `npm start`.\n3. Create a Postgres profile:\n\n   ```json\n   {\n     \"action\": \"profile_upsert\",\n     \"profile_name\": \"default\",\n     \"connection\": {\n       \"host\": \"127.0.0.1\",\n       \"port\": 5432,\n       \"username\": \"mcp_user\",\n       \"password\": \"mcp_pass\",\n       \"database\": \"mcp_demo\"\n     }\n   }\n   ```\n\n4. Stream JSONL into Postgres:\n\n   ```json\n   {\n     \"action\": \"run\",\n     \"flow\": \"http_to_postgres\",\n     \"http\": { \"url\": \"https://example.com/events.jsonl\" },\n     \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n     \"format\": \"jsonl\"\n   }\n   ```\n5. Inspect audit entries: call `mcp_audit` with `action: \"list\"`.\n\n## Index\n\n- **Getting started**\n  - `../README.md` (project overview)\n  - `../mcp_config.md` (MCP client config, profiles/keys, examples)\n- **Reference**\n  - `tools.md` (tool overview + common call patterns)\n- **Architecture**\n  - `architecture.md` (how the server is structured)\n- **Integration**\n  - `../integration/README.md` (Docker targets + smoke test)\n- **Security**\n  - `../SECURITY.md` (vulnerability reporting policy)\n  - `../PUBLIC_RELEASE_CHECKLIST.md` (safe public release checklist)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 335,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/architecture.md": [
      {
        "file_path": "docs/architecture.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# Architecture\n\nSentryFrogg is a stdio-based MCP server built around a small service layer that wires managers to shared services.\n\n## High-level structure\n\n- `sentryfrogg_server.ts`\n  - defines the MCP tool catalog (`tools/list`)\n  - routes `call_tool` requests to manager handlers\n  - writes logs to **stderr** to keep MCP stdout clean\n- `src/bootstrap/ServiceBootstrap.ts`\n  - builds the container and registers services\n- Managers (tool implementations)\n  - `src/managers/PostgreSQLManager.ts`\n  - `src/managers/SSHManager.ts`\n  - `src/managers/APIManager.ts`\n  - `src/managers/StateManager.ts`\n  - `src/managers/ProjectManager.ts`\n  - `src/managers/ContextManager.ts`\n  - `src/managers/CapabilityManager.ts`\n  - `src/managers/IntentManager.ts`\n  - `src/managers/EvidenceManager.ts`\n  - `src/managers/WorkspaceManager.ts`\n  - `src/managers/RunbookManager.ts`\n  - `src/managers/AliasManager.ts`\n  - `src/managers/PresetManager.ts`\n  - `src/managers/AuditManager.ts`\n  - `src/managers/PipelineManager.ts`\n- Shared services\n- `src/services/ProfileService.ts` ‚Äî stores profiles and encrypted secrets\n- `src/services/Security.ts` ‚Äî encryption key lifecycle and crypto helpers\n- `src/services/Validation.ts` ‚Äî canonical input validation\n- `src/services/Logger.ts` ‚Äî minimal logger (stderr)\n- `src/services/StateService.ts` ‚Äî persistent/session state\n- `src/services/ProjectService.ts` ‚Äî project registry",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 358,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/architecture.md",
        "start_line": 39,
        "end_line": 76,
        "content": "- `src/services/ContextService.ts` ‚Äî context detection\n- `src/services/CapabilityService.ts` ‚Äî capability registry\n- `src/services/EvidenceService.ts` ‚Äî evidence bundles\n- `src/services/WorkspaceService.ts` ‚Äî workspace summary/diagnostics\n- `src/services/RunbookService.ts` ‚Äî runbook storage\n- `src/services/AliasService.ts` ‚Äî alias storage\n- `src/services/PresetService.ts` ‚Äî preset storage\n- `src/services/AuditService.ts` ‚Äî audit log persistence\n- `src/services/CacheService.ts` ‚Äî file-backed cache\n- `src/services/ToolExecutor.ts` ‚Äî output shaping + `store_as` + trace metadata\n\n## Profiles, storage, and encryption\n\nLocal state (base directory):\n- Default: `${XDG_STATE_HOME}/sentryfrogg` or `~/.local/state/sentryfrogg`.\n\nBundles:\n- Default `runbooks.json` / `capabilities.json` live in the repository and are safe to ship.\n- Local overrides live in the base directory via `MCP_RUNBOOKS_PATH` / `MCP_CAPABILITIES_PATH`.\n\nStore files:\n- `profiles.json` ‚Äî profile store (data + encrypted secrets)\n- `.mcp_profiles.key` ‚Äî persistent encryption key (created with `0600`)\n- `state.json` ‚Äî persistent state values (session state remains in memory)\n- `projects.json` ‚Äî project registry (targets ‚Üí profile bindings)\n- `context.json` ‚Äî project context cache\n- `capabilities.json` ‚Äî capability registry\n- `runbooks.json` ‚Äî runbook definitions\n- `aliases.json` ‚Äî alias registry\n- `presets.json` ‚Äî preset registry\n- `audit.jsonl` ‚Äî audit log\n- `cache/` ‚Äî HTTP/pipeline cache\n\nProfile shape:\n\n```json\n{\n  \"name\": {",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 387,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/architecture.md",
        "start_line": 77,
        "end_line": 114,
        "content": "    \"type\": \"postgresql\",\n    \"data\": { \"host\": \"db\", \"port\": 5432, \"username\": \"svc\" },\n    \"secrets\": { \"password\": \"<encrypted>\" },\n    \"created_at\": \"...\",\n    \"updated_at\": \"...\"\n  }\n}\n```\n\nEncryption:\n- AES-256-GCM with an auto-generated key (or `ENCRYPTION_KEY`).\n- Secrets are never returned in `profile_list` and only revealed via `profile_get` when explicitly requested.\n\nEnvironment variables:\n- `MCP_PROFILES_DIR` ‚Äî directory for `profiles.json`\n- `MCP_PROFILES_PATH` ‚Äî explicit path to `profiles.json`\n- `MCP_PROFILE_KEY_PATH` ‚Äî explicit path to `.mcp_profiles.key`\n- `MCP_STATE_PATH` ‚Äî explicit path to `state.json`\n- `MCP_PROJECTS_PATH` ‚Äî explicit path to `projects.json`\n- `MCP_RUNBOOKS_PATH` ‚Äî explicit path to `runbooks.json`\n- `MCP_DEFAULT_RUNBOOKS_PATH` ‚Äî explicit path to default runbooks bundle\n- `MCP_CAPABILITIES_PATH` ‚Äî explicit path to `capabilities.json`\n- `MCP_DEFAULT_CAPABILITIES_PATH` ‚Äî explicit path to default capabilities bundle\n- `MCP_ALIASES_PATH` ‚Äî explicit path to `aliases.json`\n- `MCP_PRESETS_PATH` ‚Äî explicit path to `presets.json`\n- `MCP_AUDIT_PATH` ‚Äî explicit path to `audit.jsonl`\n- `MCP_CACHE_DIR` ‚Äî directory for cache files\n- `ENCRYPTION_KEY` ‚Äî supply a stable encryption key (recommended for shared environments)\n- `LOG_LEVEL` ‚Äî `error` / `warn` / `info` / `debug`\n- `SENTRYFROGG_UNSAFE_LOCAL` / `SF_UNSAFE_LOCAL` ‚Äî enable `mcp_local` (local exec + filesystem). Disabled by default.\n\n## Operational model\n\n- Managers accept either `profile_name` or inline connection data per request.\n- PostgreSQL supports direct SQL, batches, transactions, and parameterized CRUD helpers.\n- PostgreSQL also provides select/count/exists/export helpers for structured reads.\n- SSH supports single commands, batches, basic diagnostics, and SFTP operations.\n- HTTP supports profiles, typed bodies, auth providers, retry/backoff, pagination, and downloads.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 479,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/architecture.md",
        "start_line": 115,
        "end_line": 118,
        "content": "- HTTP can optionally cache responses; pipelines provide streaming flows across HTTP, SFTP, and PostgreSQL.\n- State is available for cross-tool workflows, runbooks orchestrate multi-step flows, and audit logs keep a traceable history.\n\nThis project is infrastructure-grade. Run it only in environments you trust.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 78,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/CONTRACT_STANDARD.md": [
      {
        "file_path": "docs/contracts/CONTRACT_STANDARD.md",
        "start_line": 1,
        "end_line": 15,
        "content": " [LEGEND]\nVERSION = A stable identifier (v1, v2, ‚Ä¶) for a contract.\nREQUIRED_SECTIONS = The required headings every contract must include.\n\n[CONTENT]\nContract standard:\n- Every contract is versioned (e.g., `*_v1.md`).\n- The first non-empty line of the contract body starts with `Contract:` and includes the [VERSION].\n- Every contract includes the [REQUIRED_SECTIONS] below (exact heading names):\n  - `## Purpose`\n  - `## Scope`\n  - `## Interface`\n  - `## Errors`\n  - `## Examples` (must include at least one fenced code block)\n  - Optional: `## Compatibility`",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 140,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/README.md": [
      {
        "file_path": "docs/contracts/README.md",
        "start_line": 1,
        "end_line": 11,
        "content": "[LEGEND]\n\n[CONTENT]\nThis directory contains versioned contracts (v1, v2, ...).\n\nStart with:\n- CONTRACT_STANDARD.md\n- docs_format_v1.md\n\nGate behavior:\n- `./tools/gate` validates that every `*_vN.md` contract follows the contract standard.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/cognition_v1.md": [
      {
        "file_path": "docs/contracts/cognition_v1.md",
        "start_line": 1,
        "end_line": 23,
        "content": "[LEGEND]\nCOGNITION = The contract for how reasoning artifacts are stored and linked.\n\n[CONTENT]\nContract: Cognition v1\n\n## Purpose\nDefine [COGNITION]: how reasoning artifacts are recorded, linked, and retrieved.\n\n## Scope\n- In scope: artifact types, linking rules, minimal required fields.\n- Out of scope: UI/visualization and storage backend.\n\n## Interface\nTODO: define artifact envelope and required fields per type.\n\n## Errors\nTODO: define invalid artifact/link errors.\n\n## Examples\n```json\n{\"type\":\"evidence\",\"title\":\"Gate green\",\"links\":[\"decision:use-content-only\"]}\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 144,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/docs_format_v1.md": [
      {
        "file_path": "docs/contracts/docs_format_v1.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\nContract: Documentation format v1\n\n## Purpose\nDefine [DOC_FORMAT]: a deterministic documentation shape that humans and agents can parse without guesswork.\n\n## Scope\n- In scope: required blocks, token rules, and what the gate validates.\n- Out of scope: repository-specific vocabulary (that lives in `LEGEND.md`).\n\n## Interface\nRules:\n- Every Markdown doc (except repo-root `AGENTS.md` and repo-root `README.md`) MUST follow [DOC_FORMAT].\n- The first non-empty line MUST be `[LEGEND]`.\n- A document MUST include exactly one content header: `[CONTENT]`.\n\nToken rules:\n- Definitions live in `[LEGEND]` as `TOKEN = Meaning`.\n- Token names use a constrained vocabulary: uppercase with `_` (recommended) and must be stable.\n- References in content are written as `[TOKEN]` (optionally `[TOKEN|LEGEND.md]`).\n- Local tokens must not redefine global tokens.\n\nContract rules:\n- Versioned contracts in `docs/contracts/*_vN.md` must follow `CONTRACT_STANDARD.md`.\n\n## Errors\nIf a doc violates [DOC_FORMAT] or token rules, the gate fails closed.\n\n## Examples\n```md\n[LEGEND]\nTERM = A locally-defined term for this document.\n\n[CONTENT]\nThis uses [TERM] without repeating the meaning.\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 298,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/event_log_v1.md": [
      {
        "file_path": "docs/contracts/event_log_v1.md",
        "start_line": 1,
        "end_line": 23,
        "content": "[LEGEND]\nEVENT_LOG = The contract for durable events and their schema/versioning.\n\n[CONTENT]\nContract: Event log v1\n\n## Purpose\nDefine [EVENT_LOG]: the durable event envelope and rules for versioning, retention, and replay.\n\n## Scope\n- In scope: event envelope, versioning rules, retention, idempotency.\n- Out of scope: concrete storage implementation.\n\n## Interface\nTODO: define event envelope fields and schema evolution rules.\n\n## Errors\nTODO: define error modes (invalid event, version mismatch, retention violations).\n\n## Examples\n```json\n{\"type\":\"example.event.v1\",\"ts\":\"2026-01-07T00:00:00Z\",\"data\":{\"id\":\"123\"}}\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 155,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/orchestration_v1.md": [
      {
        "file_path": "docs/contracts/orchestration_v1.md",
        "start_line": 1,
        "end_line": 23,
        "content": "[LEGEND]\nORCHESTRATION = The contract for multi-step workflows and execution semantics.\n\n[CONTENT]\nContract: Orchestration v1\n\n## Purpose\nDefine [ORCHESTRATION]: multi-step workflow execution semantics (including rollback and retries).\n\n## Scope\n- In scope: step model, state transitions, retries/timeouts, rollback semantics.\n- Out of scope: concrete worker/runtime implementation.\n\n## Interface\nTODO: define workflow and step schemas.\n\n## Errors\nTODO: define orchestration failures (timeout, non-retryable, rollback-failed).\n\n## Examples\n```json\n{\"workflow\":\"publish_release\",\"steps\":[{\"id\":\"build\",\"retry\":2},{\"id\":\"deploy\",\"timeout_s\":600}]}\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 162,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/policy_v1.md": [
      {
        "file_path": "docs/contracts/policy_v1.md",
        "start_line": 1,
        "end_line": 61,
        "content": "[LEGEND]\nPOLICY = A rule set that constrains agent behavior.\n\n[CONTENT]\nContract: Policy v1\n\n## Purpose\nDefine [POLICY]: the rule set that constrains agent behavior and defines stop conditions.\n\n## Scope\n- In scope: budgets, stop conditions, change protocol invariants, approval rules.\n- Out of scope: project-specific technical architecture decisions.\n\n## Interface\nPolicy object (all fields optional unless noted):\n- mode: \"operatorless\" (required for write intents / repo writes).\n- allow.intents: list of allowed intent types (deny by default when set).\n- allow.merge: boolean (gate for gitops.propose/gitops.release merge=true).\n- repo.allowed_remotes: list of allowed git remotes (e.g. [\"origin\"]).\n- kubernetes.allowed_namespaces: list of allowed namespaces for kubectl write.\n- change_windows: list of UTC windows { days, start, end } (deny outside).\n- lock.enabled, lock.ttl_ms: write lock settings.\n\nPolicy profiles (project-level):\n- project.policy_profiles.{name}: policy object.\n- target.policy: policy object OR profile name.\n- inputs.policy_profile / inputs.policy_profile_name: profile name.\n\n## Errors\n- Missing policy for GitOps write: denied (POLICY_REQUIRED).\n- Non-operatorless mode: denied (POLICY_MODE_REQUIRED).\n- Remote/namespace not allowed: denied (POLICY_DENIED_REMOTE / POLICY_DENIED_NAMESPACE).\n- Outside change window: denied (POLICY_CHANGE_WINDOW).\n\n## Examples\n```text\npolicy:\n  change_protocol: contracts-first\n  stop_conditions:\n    - secrets_required\n    - irreversible_migration\n```\n\nProject policy profiles + target reference:\n```text\nproject:\n  policy_profiles:\n    autonomy:\n      mode: operatorless\n      repo:\n        allowed_remotes: [origin]\n  targets:\n    prod:\n      policy: autonomy\n```\n\nIntent input selecting a profile:\n```text\ninputs:\n  policy_profile_name: autonomy\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 455,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/team_cognition_v1.md": [
      {
        "file_path": "docs/contracts/team_cognition_v1.md",
        "start_line": 1,
        "end_line": 25,
        "content": "[LEGEND]\nTEAM_COGNITION = The contract for multi-agent coordination and shared context.\n\n[CONTENT]\nContract: Team cognition v1\n\n## Purpose\nDefine [TEAM_COGNITION]: coordination rules for multiple agents working on the same codebase.\n\n## Scope\n- In scope: lanes, ownership, handoffs, shared artifacts, sync rules.\n- Out of scope: org structure and staffing.\n\n## Interface\nTODO: define lane model and minimal shared artifact set.\n\n## Errors\nTODO: define conflict cases (two owners, stale decisions, missing evidence).\n\n## Examples\n```text\nlane: \"core\"\nowner: \"agent-A\"\nhandoff: \"agent-B\"\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 147,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/tool_bus_v1.md": [
      {
        "file_path": "docs/contracts/tool_bus_v1.md",
        "start_line": 1,
        "end_line": 23,
        "content": "[LEGEND]\nTOOL_BUS = The contract for how tools are invoked and reported.\n\n[CONTENT]\nContract: Tool bus v1\n\n## Purpose\nDefine [TOOL_BUS]: how tools are invoked, how results are returned, and how failures are represented.\n\n## Scope\n- In scope: request/response envelopes, streaming semantics (if any), error taxonomy.\n- Out of scope: tool-specific payload schemas (those are per-tool contracts).\n\n## Interface\nTODO: define request/response envelopes.\n\n## Errors\nTODO: define error taxonomy (typed errors, retryability, timeouts).\n\n## Examples\n```json\n{\"tool\":\"example_tool\",\"input\":{\"q\":\"ping\"}}\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 149,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/ui_recipe_v1.md": [
      {
        "file_path": "docs/contracts/ui_recipe_v1.md",
        "start_line": 1,
        "end_line": 29,
        "content": "[LEGEND]\nUI_RECIPE = The contract for UI flows and acceptance checks.\n\n[CONTENT]\nContract: UI recipe v1\n\n## Purpose\nDefine [UI_RECIPE]: a minimal format for describing UI flows and acceptance checks.\n\n## Scope\n- In scope: flow steps, acceptance checks, regression checklist.\n- Out of scope: implementation details (framework/components).\n\n## Interface\nTODO: define a UI recipe schema (steps, asserts, fixtures).\n\n## Errors\nTODO: define invalid flow/step errors.\n\n## Examples\n```yaml\nflow:\n  name: \"Create item\"\n  steps:\n    - action: \"click\"\n      target: \"New\"\n    - action: \"assert\"\n      text: \"Item created\"\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 153,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/contracts/workflow_v1.md": [
      {
        "file_path": "docs/contracts/workflow_v1.md",
        "start_line": 1,
        "end_line": 25,
        "content": "[LEGEND]\nWORKFLOW = The contract for recurring engineering workflows and gates.\n\n[CONTENT]\nContract: Workflow v1\n\n## Purpose\nDefine [WORKFLOW]: recurring engineering workflows and what ‚Äúdone‚Äù means for each.\n\n## Scope\n- In scope: workflow states, gates, definition-of-done, rollback hooks.\n- Out of scope: tool choice (CI vendor, tracker).\n\n## Interface\nTODO: define workflow state machine and gate hooks.\n\n## Errors\nTODO: define invalid state transitions and missing gate evidence.\n\n## Examples\n```text\nworkflow: \"change\"\nstates: [draft, review, merged]\ngate: [\"doctor\", \"gate\"]\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 146,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "docs/tools.md": [
      {
        "file_path": "docs/tools.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# Tool Reference\n\nSentryFrogg exposes a small set of MCP tools over stdio.\n\nSource of truth:\n- `tools/list` returns the current tool schema (names, descriptions, JSON schemas).\n- `help` provides a short overview from the server itself.\n\nAll managers accept either a stored `profile_name` or an inline `connection` object per call.\nIf only one profile exists for a tool, `profile_name` can be omitted.\n\nTool responses are wrapped in a consistent envelope:\n\n```json\n{\n  \"ok\": true,\n  \"result\": { \"...\": \"...\" },\n  \"meta\": { \"tool\": \"mcp_psql_manager\", \"action\": \"query\", \"trace_id\": \"...\", \"span_id\": \"...\", \"duration_ms\": 12 }\n}\n```\n\n## Global fields\n\nAll tools accept optional fields for output shaping and state capture:\n- `output`: `{ path, pick, omit, map, missing, default }`\n- `store_as`: string key or `{ key, scope }`\n- `store_scope`: `session` | `persistent` (when `store_as` is a string)\n- `trace_id`: propagate a trace identifier through logs and responses\n- `span_id` / `parent_span_id`: span correlation for distributed traces\n- `preset` / `preset_name`: apply a stored preset before merging call arguments\n\n`store_as` defaults to `session` scope unless `store_scope` is provided.\n\nExample:\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 306,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 39,
        "end_line": 76,
        "content": "```json\n{\n  \"action\": \"query\",\n  \"profile_name\": \"default\",\n  \"sql\": \"SELECT id, status FROM orders\",\n  \"output\": { \"path\": \"rows\", \"pick\": [\"id\", \"status\"] },\n  \"store_as\": \"orders_snapshot\",\n  \"store_scope\": \"session\"\n}\n```\n\n## Quick start: `project` ‚Üí `target`\n\nThe intended UX is: **bind profiles to a project target once ‚Üí then call tools with only `target`**.\n\n1) Create profiles (`mcp_ssh_manager`, `mcp_env`, `mcp_psql_manager`, `mcp_api_client`)  \n2) Bind them under a project target (`mcp_project.project_upsert`)  \n3) Activate the project (`mcp_project.project_use`, `scope: \"persistent\"`)  \n4) Use `ssh`/`env`/`psql`/`api` with just `target` (and an action-specific payload)\n\nMinimal flow example:\n\n```json\n{ \"action\": \"project_use\", \"name\": \"myapp\", \"scope\": \"persistent\" }\n```\n\n```json\n{ \"action\": \"exec\", \"target\": \"prod\", \"command\": \"uname -a\" }\n```\n\n```json\n{ \"action\": \"write_remote\", \"target\": \"prod\" }\n```\n\n```json\n{ \"action\": \"query\", \"target\": \"prod\", \"sql\": \"SELECT 1\" }\n```\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 250,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 77,
        "end_line": 114,
        "content": "```json\n{ \"action\": \"request\", \"target\": \"prod\", \"method\": \"GET\", \"url\": \"/health\" }\n```\n\nNotes:\n- When a project is active, `project` is optional (tools will pick it up from state).\n- When a target is resolvable, `profile_name` can often be omitted (it is inferred from `project target.*_profile`).\n- If you use `ref:vault:kv2:*` secrets, select Vault via `vault_profile_name` / `vault_profile` or configure `project target.vault_profile`.\n- Local filesystem path arguments support `~` expansion to `$HOME` (where applicable).\n\n## `help`\n\nPurpose: discover available tools and their intended usage.\n\nExample:\n\n```json\n{ \"tool\": \"mcp_psql_manager\" }\n```\n\nDrill down into a specific action:\n\n```json\n{ \"tool\": \"mcp_ssh_manager\", \"action\": \"exec\" }\n```\n\n## `mcp_state`\n\nSession/persistent key-value store for cross-tool workflows.\n\nKey actions:\n- `set` / `get` / `list` / `unset` / `clear` / `dump`\n\nExample:\n\n```json\n{\n  \"action\": \"set\",",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 234,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 115,
        "end_line": 152,
        "content": "  \"key\": \"token\",\n  \"value\": \"abc123\",\n  \"scope\": \"session\"\n}\n```\n\n## `mcp_project`\n\nProjects are the **highest-level UX primitive** in SentryFrogg: one named project can describe multiple environments (targets)\nand bind each target to SSH/Env/Postgres/API profiles.\n\nKey actions:\n- `project_upsert` / `project_get` / `project_list` / `project_delete`\n- `project_use` / `project_active` / `project_unuse`\n\nProject example:\n\n```json\n{\n  \"action\": \"project_upsert\",\n  \"name\": \"myapp\",\n  \"project\": {\n    \"description\": \"MyApp infra bindings\",\n    \"default_target\": \"prod\",\n    \"targets\": {\n      \"prod\": {\n        \"description\": \"Production\",\n        \"ssh_profile\": \"myapp-prod-ssh\",\n        \"env_profile\": \"myapp-prod-env\",\n        \"postgres_profile\": \"myapp-prod-db\",\n        \"api_profile\": \"myapp-prod-api\",\n        \"vault_profile\": \"myapp-vault\",\n        \"cwd\": \"/opt/myapp\",\n        \"env_path\": \"/opt/myapp/.env\"\n      }\n    }\n  }\n}",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 233,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 153,
        "end_line": 190,
        "content": "```\n\nPolicy profiles (autonomy-ready, optional):\n\n```json\n{\n  \"action\": \"project_upsert\",\n  \"name\": \"myapp\",\n  \"project\": {\n    \"policy_profiles\": {\n      \"autonomy\": {\n        \"mode\": \"operatorless\",\n        \"repo\": { \"allowed_remotes\": [\"origin\"] },\n        \"lock\": { \"enabled\": false }\n      }\n    },\n    \"targets\": {\n      \"prod\": {\n        \"ssh_profile\": \"myapp-prod-ssh\",\n        \"env_profile\": \"myapp-prod-env\",\n        \"policy\": \"autonomy\"\n      }\n    }\n  }\n}\n```\n\nNotes:\n- `target.policy` can be an inline policy object or a profile name (`policy_profiles.<name>`).\n- You can also select a profile per intent: `inputs.policy_profile_name: \"autonomy\"`.\n- Explicit global opt-in is supported via `SENTRYFROGG_AUTONOMY_POLICY=operatorless`.\n\nActivate project (persists across restarts):\n\n```json\n{ \"action\": \"project_use\", \"name\": \"myapp\", \"scope\": \"persistent\" }\n```\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 218,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 191,
        "end_line": 228,
        "content": "Notes:\n- If a project has multiple targets, `target` is required unless `default_target` is set.\n- Many tools accept `project`/`target` directly, and will also pick up the active project automatically.\n\n## `mcp_context`\n\nProject context cache: detects runtime signals (stack hints) without reading secret contents.\n\nKey actions:\n- `get` / `refresh` / `summary` / `list` / `stats`\n\nExample (summary):\n\n```json\n{ \"action\": \"summary\", \"project\": \"myapp\", \"target\": \"prod\" }\n```\n\nNotes:\n- Context is stored in `context.json` under the profiles directory (`MCP_CONTEXT_PATH` overrides).\n- Context only contains safe metadata (paths + detected tags), not secrets.\n\n## `mcp_workspace`\n\nUnified workspace UX: one-call summary, suggestions, and diagnostics.\n\nKey actions:\n- `summary` / `suggest` / `diagnose`\n- `run` (execute runbook by name)\n- `store_status`\n- `stats`\n\nSummary example:\n\n```json\n{ \"action\": \"summary\", \"project\": \"myapp\", \"target\": \"prod\" }\n```\n\nActions-only summary (UX hints + call templates):",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 251,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 229,
        "end_line": 304,
        "content": "\n```json\n{ \"action\": \"summary\", \"project\": \"myapp\", \"target\": \"prod\", \"format\": \"actions\" }\n```\n\nDiagnostics example:\n\n```json\n{ \"action\": \"diagnose\" }\n```\n\nRun example:\n\n```json\n{ \"action\": \"run\", \"name\": \"k8s.diff\", \"input\": { \"overlay\": \"/repo/overlays/prod\", \"kubeconfig\": \"/path/kubeconfig\" } }\n```\n\nIntent example (dry-run by default):\n\n```json\n{ \"action\": \"run\", \"intent_type\": \"k8s.diff\", \"inputs\": { \"overlay\": \"/repo/overlays/prod\" } }\n```\n\nIntent apply (write/mixed):\n\n```json\n{ \"action\": \"run\", \"intent_type\": \"k8s.apply\", \"inputs\": { \"overlay\": \"/repo/overlays/prod\" }, \"apply\": true }\n```\n\nNotes:\n- Suggestions are derived from context tags and available runbooks/capabilities.\n- `summary`/`suggest` accept `format` (`full` | `compact` | `actions`) and `include_call` (default true).\n\n## `mcp_capability`\n\nCapability registry ties intents to runbooks (with optional `when` filters).\n\nKey actions:\n- `list` / `get` / `resolve` / `set` / `delete`\n- `suggest` (filter by context)\n- `graph` / `stats`\n\nSuggest example:\n\n```json\n{ \"action\": \"suggest\", \"project\": \"myapp\", \"target\": \"prod\" }\n```\n\nCapability example:\n\n```json\n{\n  \"action\": \"set\",\n  \"name\": \"k8s.diff\",\n  \"capability\": {\n    \"intent\": \"k8s.diff\",\n    \"runbook\": \"k8s.diff\",\n    \"effects\": { \"kind\": \"read\" },\n    \"inputs\": { \"required\": [\"overlay\"] },\n    \"when\": { \"tags_any\": [\"k8s\"] }\n  }\n}\n```\n\n## `mcp_intent`\n\nIntent compiler/executor: `intent` ‚Üí plan ‚Üí runbook execution (dry-run by default).\n\nKey actions:\n- `compile` / `explain` / `dry_run` / `execute`\n\nDry-run example:\n\n```json\n{\n  \"action\": \"dry_run\",",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 397,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 305,
        "end_line": 342,
        "content": "  \"intent\": { \"type\": \"k8s.diff\", \"inputs\": { \"overlay\": \"/repo/overlays/prod\" } }\n}\n```\n\nNotes:\n- `execute` for write/mixed effects requires `apply: true`.\n- When available, `context` is injected into inputs for template mapping.\n\n## `mcp_evidence`\n\nEvidence bundle registry from intent executions.\n\nKey actions:\n- `list` / `get`\n\n## `mcp_env`\n\nEncrypted environment bundles stored as `env` profiles. Useful for safely shipping secrets into remote `.env` files\nand for running remote commands with a controlled env payload.\n\nKey actions:\n- `profile_upsert` / `profile_get` / `profile_list` / `profile_delete`\n- `write_remote` / `run_remote`\n\nCreate/update env bundle:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"myapp-prod-env\",\n  \"secrets\": {\n    \"DATABASE_URL\": \"postgres://...\",\n    \"API_TOKEN\": \"...\"\n  }\n}\n```\n\nWrite remote `.env` (safe by default):",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 217,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 343,
        "end_line": 380,
        "content": "\n```json\n{\n  \"action\": \"write_remote\",\n  \"target\": \"prod\",\n  \"ssh_profile_name\": \"myapp-prod-ssh\",\n  \"profile_name\": \"myapp-prod-env\",\n  \"remote_path\": \"/opt/myapp/.env\",\n  \"overwrite\": true,\n  \"backup\": true,\n  \"mode\": 384,\n  \"mkdirs\": true\n}\n```\n\nProject-aware example (uses `project target.ssh_profile` + `project target.env_profile` + `target.env_path` defaults):\n\n```json\n{ \"action\": \"write_remote\", \"target\": \"prod\", \"overwrite\": true, \"backup\": true }\n```\n\nNotes:\n- `write_remote` is atomic (temp + rename).\n- `overwrite` defaults to `false` and refuses to replace an existing file unless enabled.\n- If `remote_path` is omitted, it can default from `project target.env_path` or `project target.cwd + '/.env'`.\n- `run_remote` can default `cwd` from `project target.cwd`.\n- `profile_name` refers to the env profile; `ssh_profile_name` refers to the SSH profile (they can be inferred from project bindings).\n- `profile_get` only reveals secret values when `include_secrets: true` **and** `SENTRYFROGG_ALLOW_SECRET_EXPORT=1` (or `SF_ALLOW_SECRET_EXPORT=1`) is set.\n\n## `mcp_vault`\n\nVault profile store + diagnostics. Useful as a safe backend for resolving secrets at execution time.\n\nKey actions:\n- `profile_upsert` / `profile_get` / `profile_list` / `profile_delete` / `profile_test`\n\nProfile example (AppRole; token is acquired on demand and persisted encrypted):\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 342,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 381,
        "end_line": 418,
        "content": "```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"corp-vault\",\n  \"addr\": \"https://vault.example.com\",\n  \"namespace\": \"team-a\",\n  \"auth_type\": \"approle\",\n  \"role_id\": \"<role_id>\",\n  \"secret_id\": \"<secret_id>\"\n}\n```\n\nProfile example (static token):\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"corp-vault\",\n  \"addr\": \"https://vault.example.com\",\n  \"namespace\": \"team-a\",\n  \"auth_type\": \"token\",\n  \"token\": \"<token>\"\n}\n```\n\nTest connectivity (and auth validity):\n\n```json\n{ \"action\": \"profile_test\", \"profile_name\": \"corp-vault\" }\n```\n\nUsing Vault KV v2 in env profiles (resolved on `write_remote` / `run_remote`):\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"myapp-prod-env\",\n  \"secrets\": {",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 181,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 419,
        "end_line": 456,
        "content": "    \"DATABASE_URL\": \"ref:vault:kv2:secret/myapp/prod#DATABASE_URL\"\n  }\n}\n```\n\nNotes:\n- `ref:vault:kv2:<mount>/<path>#<key>` reads from Vault KV v2 (`/v1/<mount>/data/<path>`).\n- Vault profile is selected via `vault_profile_name` / `vault_profile`, or `project target.vault_profile`, or auto-pick when only one vault profile exists.\n- For AppRole profiles, `client_token` is fetched on-demand and saved into the profile (encrypted). To clear it, call `profile_upsert` with `\"token\": null`.\n- SecretRefs work across `mcp_env`, `mcp_ssh_manager`, `mcp_psql_manager`, and `mcp_api_client` (wherever secret fields are used).\n- `profile_get` only reveals secret values when `include_secrets: true` **and** `SENTRYFROGG_ALLOW_SECRET_EXPORT=1` (or `SF_ALLOW_SECRET_EXPORT=1`) is set.\n\n## `mcp_runbook`\n\nRunbooks store and execute multi-step workflows with templating, `when`, and `foreach`.\n\nKey actions:\n- `runbook_upsert` / `runbook_upsert_dsl` / `runbook_get` / `runbook_list` / `runbook_delete`\n- `runbook_run` / `runbook_run_dsl`\n- `runbook_compile` (DSL ‚Üí JSON)\n\nRunbook example:\n\n```json\n{\n  \"action\": \"runbook_upsert\",\n  \"name\": \"fetch-orders\",\n  \"runbook\": {\n    \"steps\": [\n      {\n        \"id\": \"token\",\n        \"tool\": \"mcp_api_client\",\n        \"args\": {\n          \"action\": \"request\",\n          \"method\": \"POST\",\n          \"url\": \"https://auth.example.com/token\",\n          \"form\": { \"client_id\": \"svc\", \"client_secret\": \"{{input.secret}}\" },\n          \"output\": { \"path\": \"data.access_token\" },",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 375,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 457,
        "end_line": 532,
        "content": "          \"store_as\": \"api_token\",\n          \"store_scope\": \"session\"\n        }\n      },\n      {\n        \"id\": \"orders\",\n        \"tool\": \"mcp_api_client\",\n        \"args\": {\n          \"action\": \"request\",\n          \"method\": \"GET\",\n          \"url\": \"https://api.example.com/orders\",\n          \"auth\": \"{{state.api_token}}\"\n        }\n      }\n    ]\n  }\n}\n```\n\nNotes:\n- Templates support `{{input.*}}`, `{{state.*}}`, `{{steps.<id>.*}}`, plus `{{item}}` inside `foreach`.\n- `when` supports `path/equals/not_equals/in/contains` and boolean logic (`and`/`or`/`not`).\n\nDSL example:\n\n```text\nrunbook fetch-orders\nstep token mcp_api_client request\narg url=https://auth.example.com/token\narg form.client_id=svc\narg form.client_secret={{input.secret}}\nstep orders mcp_api_client request\narg url=https://api.example.com/orders\narg auth={{state.api_token}}\n```\n\n## `mcp_alias`\nAliases provide short names that resolve to a tool + optional args.\n\nKey actions:\n- `alias_upsert` / `alias_get` / `alias_list` / `alias_delete` / `alias_resolve`\n\nExample:\n\n```json\n{\n  \"action\": \"alias_upsert\",\n  \"name\": \"gh\",\n  \"alias\": {\n    \"tool\": \"mcp_api_client\",\n    \"args\": { \"action\": \"request\", \"base_url\": \"https://api.github.com\" }\n  }\n}\n```\n\n## `mcp_preset`\n\nPresets store reusable argument bundles for any tool.\n\nKey actions:\n- `preset_upsert` / `preset_get` / `preset_list` / `preset_delete`\n\nExample:\n\n```json\n{\n  \"action\": \"preset_upsert\",\n  \"tool\": \"mcp_api_client\",\n  \"name\": \"github\",\n  \"preset\": {\n    \"headers\": { \"Accept\": \"application/vnd.github+json\" }\n  }\n}\n```\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 388,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 533,
        "end_line": 608,
        "content": "## `mcp_psql_manager`\n\nPostgreSQL toolchain with profiles, queries, transactions, and CRUD helpers.\n\nKey actions:\n- `profile_upsert` / `profile_get` / `profile_list` / `profile_delete` / `profile_test`\n- `query` / `batch` / `transaction`\n- `insert` / `insert_bulk` / `update` / `delete`\n- `select` / `count` / `exists` / `export`\n- `catalog_tables` / `catalog_columns` / `database_info`\n\nProfile example:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 5432,\n    \"username\": \"user\",\n    \"password\": \"pass\",\n    \"database\": \"dbname\",\n    \"ssl\": false\n  }\n}\n```\n\nProject-aware example (uses `project target.postgres_profile` or active project):\n\n```json\n{ \"action\": \"query\", \"target\": \"prod\", \"sql\": \"SELECT 1 AS ok\" }\n```\n\nQuery example:\n\n```json\n{\n  \"action\": \"query\",\n  \"profile_name\": \"default\",\n  \"sql\": \"SELECT $1::int AS ok\",\n  \"params\": [1]\n}\n```\n\nTransaction example:\n\n```json\n{\n  \"action\": \"transaction\",\n  \"profile_name\": \"default\",\n  \"statements\": [\n    { \"sql\": \"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", \"params\": [100, 1] },\n    { \"sql\": \"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", \"params\": [100, 2] }\n  ]\n}\n```\n\nCRUD example:\n\n```json\n{\n  \"action\": \"update\",\n  \"profile_name\": \"default\",\n  \"table\": \"orders\",\n  \"data\": { \"status\": \"paid\" },\n  \"filters\": { \"id\": 42 },\n  \"returning\": true\n}\n```\n\nBulk insert example:\n\n```json\n{\n  \"action\": \"insert_bulk\",",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 369,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 609,
        "end_line": 646,
        "content": "  \"profile_name\": \"default\",\n  \"table\": \"events\",\n  \"rows\": [\n    { \"name\": \"signup\", \"source\": \"web\" },\n    { \"name\": \"purchase\", \"source\": \"api\" }\n  ]\n}\n```\n\nNotes:\n- `update`/`delete` without `filters` or `where_sql` will affect **all** rows in the table.\n- `connection.password` and SSL secret fields can be SecretRefs (`ref:vault:kv2:*` / `ref:env:*`) and are resolved at execution time.\n- Vault profile is selected via `vault_profile_name` / `vault_profile`, or `project target.vault_profile`, or auto-pick when only one vault profile exists.\n- `profile_get` only reveals secret values when `include_secrets: true` **and** `SENTRYFROGG_ALLOW_SECRET_EXPORT=1` (or `SF_ALLOW_SECRET_EXPORT=1`) is set.\n\nSelect example:\n\n```json\n{\n  \"action\": \"select\",\n  \"profile_name\": \"default\",\n  \"table\": \"orders\",\n  \"columns\": [\"id\", \"status\"],\n  \"filters\": { \"status\": \"paid\" },\n  \"order_by\": { \"column\": \"id\", \"direction\": \"DESC\" },\n  \"limit\": 25\n}\n```\n\nExport example:\n\n```json\n{\n  \"action\": \"export\",\n  \"profile_name\": \"default\",\n  \"table\": \"orders\",\n  \"format\": \"csv\",\n  \"file_path\": \"/tmp/orders.csv\",",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 274,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 647,
        "end_line": 684,
        "content": "  \"overwrite\": true,\n  \"batch_size\": 1000\n}\n```\n\nNote:\n- `export` refuses to overwrite an existing `file_path` unless `overwrite: true`.\n\n## `mcp_ssh_manager`\n\nSSH executor with profiles, single exec, batch runs, and diagnostics.\n\nKey actions:\n- `profile_upsert` / `profile_get` / `profile_list` / `profile_delete` / `profile_test`\n- `authorized_keys_add`\n- `exec` / `batch` / `system_info` / `check_host`\n- `sftp_list` / `sftp_upload` / `sftp_download`\n\nProfile example:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 22,\n    \"username\": \"mcp\",\n    \"password\": \"mcp_pass\"\n  }\n}\n```\n\nNotes:\n- `connection.password` / `connection.private_key` / `connection.passphrase` can be SecretRefs (`ref:vault:kv2:*` / `ref:env:*`) and are resolved at execution time.\n- SSH host key verification:\n  - `host_key_policy`: `accept` (default), `tofu` (trust-on-first-use), `pin` (strict match).\n  - `host_key_fingerprint_sha256`: expected fingerprint (`SHA256:<base64>` or `<base64>`). If fingerprint is present and policy is omitted, policy defaults to `pin`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 280,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 685,
        "end_line": 760,
        "content": "  - In `tofu` mode, the first successful connection stores the observed fingerprint into the SSH profile (`host_key_fingerprint_sha256`).\n  - To reset after a legitimate host key rotation, set `connection.host_key_fingerprint_sha256: null` in `profile_upsert` (clears stored fingerprint).\n- Vault profile is selected via `vault_profile_name` / `vault_profile`, or `project target.vault_profile`, or auto-pick when only one vault profile exists.\n- `profile_get` only reveals secret values when `include_secrets: true` **and** `SENTRYFROGG_ALLOW_SECRET_EXPORT=1` (or `SF_ALLOW_SECRET_EXPORT=1`) is set.\n\nProject-aware example (uses `project target.ssh_profile` or active project):\n\n```json\n{ \"action\": \"exec\", \"target\": \"prod\", \"command\": \"uname -a\" }\n```\n\nBootstrap: add local `.pub` to remote `authorized_keys` (idempotent):\n\n```json\n{\n  \"action\": \"authorized_keys_add\",\n  \"profile_name\": \"default\",\n  \"public_key_path\": \"/home/user/.ssh/id_ed25519.pub\"\n}\n```\n\nThen switch to key-based auth (private key stays on your machine):\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default-key\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 22,\n    \"username\": \"mcp\",\n    \"private_key_path\": \"/home/user/.ssh/id_ed25519\",\n    \"passphrase\": \"<optional>\"\n  }\n}\n```\n\nExec example:\n\n```json\n{\n  \"action\": \"exec\",\n  \"profile_name\": \"default\",\n  \"command\": \"uname -a\"\n}\n```\n\nBatch example:\n\n```json\n{\n  \"action\": \"batch\",\n  \"profile_name\": \"default\",\n  \"commands\": [\n    { \"command\": \"whoami\" },\n    { \"command\": \"uptime\" }\n  ]\n}\n```\n\nSFTP upload example:\n\n```json\n{\n  \"action\": \"sftp_upload\",\n  \"profile_name\": \"default\",\n  \"local_path\": \"/tmp/report.csv\",\n  \"remote_path\": \"/var/tmp/report.csv\",\n  \"mkdirs\": true\n}\n```\n\n## `mcp_api_client`\n\nHTTP client with profiles, flexible bodies, and response parsing.\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 454,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 761,
        "end_line": 836,
        "content": "Key actions:\n- `profile_upsert` / `profile_get` / `profile_list` / `profile_delete`\n- `request` / `paginate` / `download` / `check`\n\nProfile example:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default\",\n  \"base_url\": \"https://api.example.com\",\n  \"auth\": { \"type\": \"bearer\", \"token\": \"<token>\" }\n}\n```\n\nNotes:\n- `auth` and `auth_provider` secret fields can be SecretRefs (`ref:vault:kv2:*` / `ref:env:*`) and are resolved at execution time.\n- Vault profile is selected via `vault_profile_name` / `vault_profile`, or `project target.vault_profile`, or auto-pick when only one vault profile exists.\n- `profile_get` only reveals secret values when `include_secrets: true` **and** `SENTRYFROGG_ALLOW_SECRET_EXPORT=1` (or `SF_ALLOW_SECRET_EXPORT=1`) is set.\n\nProject-aware example (uses `project target.api_profile` or active project):\n\n```json\n{ \"action\": \"request\", \"target\": \"prod\", \"path\": \"/v1/health\" }\n```\n\nRequest example:\n\n```json\n{\n  \"action\": \"request\",\n  \"profile_name\": \"default\",\n  \"method\": \"GET\",\n  \"path\": \"/v1/health\"\n}\n```\n\nRetry/backoff example:\n\n```json\n{\n  \"action\": \"request\",\n  \"method\": \"GET\",\n  \"url\": \"https://api.example.com/orders\",\n  \"retry\": { \"max_attempts\": 4, \"base_delay_ms\": 300 }\n}\n```\n\nCache example:\n\n```json\n{\n  \"action\": \"request\",\n  \"method\": \"GET\",\n  \"url\": \"https://api.example.com/orders\",\n  \"cache\": { \"ttl_ms\": 60000 }\n}\n```\n\nPagination example:\n\n```json\n{\n  \"action\": \"paginate\",\n  \"method\": \"GET\",\n  \"url\": \"https://api.example.com/orders\",\n  \"pagination\": {\n    \"type\": \"page\",\n    \"param\": \"page\",\n    \"size_param\": \"limit\",\n    \"size\": 50,\n    \"item_path\": \"data.items\"\n  }\n}\n```\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 410,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 837,
        "end_line": 912,
        "content": "Download example:\n\n```json\n{\n  \"action\": \"download\",\n  \"method\": \"GET\",\n  \"url\": \"https://example.com/report.csv\",\n  \"download_path\": \"/tmp/report.csv\",\n  \"overwrite\": true\n}\n```\n\nNote:\n- `download` refuses to overwrite an existing `download_path` unless `overwrite: true`.\n\nAuth provider (exec) example:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"example\",\n  \"base_url\": \"https://api.example.com\",\n  \"auth_provider\": {\n    \"type\": \"exec\",\n    \"command\": \"security-token\",\n    \"args\": [\"--json\"],\n    \"format\": \"json\",\n    \"token_path\": \"access_token\"\n  }\n}\n```\n\nSafety notes:\n- This tool can reach any HTTP endpoint. Treat it as privileged in production environments.\n\n## `mcp_audit`\n\nAudit log access for tool execution events.\n\nKey actions:\n- `audit_list` / `audit_tail` / `audit_stats` / `audit_clear`\n\nExample:\n\n```json\n{\n  \"action\": \"audit_list\",\n  \"trace_id\": \"<trace-id>\",\n  \"limit\": 50\n}\n```\n\n## `mcp_pipeline`\n\nStreaming pipelines between HTTP, SFTP, and PostgreSQL.\n\nKey actions:\n- `run` / `describe`\n\nAvailable flows:\n- `http_to_sftp`\n- `sftp_to_http`\n- `http_to_postgres`\n- `sftp_to_postgres`\n- `postgres_to_sftp`\n- `postgres_to_http`\n\nProject-aware note:\n- If `project`/`target` (or active project + `target`) is provided, the pipeline will default `http.profile_name`, `postgres.profile_name`, and `sftp.profile_name`\n  from the configured project target bindings when those fields are missing.\n- `vault_profile_name` / `vault_profile` at pipeline root is propagated into `http`/`postgres`/`sftp` configs (so SecretRefs resolve without repeating it).\n\nPostgres export options (for `postgres_*` flows): `format`, `batch_size`, `limit`, `offset`,\n`columns`/`columns_sql`, `order_by`/`order_by_sql`, `filters`/`where_sql`/`where_params`,\n`csv_header`, `csv_delimiter`, `timeout_ms`.\n",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 453,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 913,
        "end_line": 950,
        "content": "HTTP ‚Üí Postgres example:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"http_to_postgres\",\n  \"http\": { \"url\": \"https://example.com/data.jsonl\" },\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"jsonl\",\n  \"batch_size\": 500\n}\n```\n\nHTTP ‚Üí SFTP example:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"http_to_sftp\",\n  \"http\": { \"url\": \"https://example.com/report.csv\" },\n  \"sftp\": { \"profile_name\": \"default\", \"remote_path\": \"/tmp/report.csv\", \"mkdirs\": true }\n}\n```\n\nPostgres ‚Üí SFTP example:\n\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"postgres_to_sftp\",\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"csv\",\n  \"order_by\": [\"id\"],\n  \"sftp\": { \"profile_name\": \"default\", \"remote_path\": \"/tmp/events.csv\", \"overwrite\": true }\n}\n```\n\nPostgres ‚Üí HTTP example:",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 200,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "docs/tools.md",
        "start_line": 951,
        "end_line": 992,
        "content": "\n```json\n{\n  \"action\": \"run\",\n  \"flow\": \"postgres_to_http\",\n  \"postgres\": { \"profile_name\": \"default\", \"table\": \"events\" },\n  \"format\": \"jsonl\",\n  \"http\": { \"url\": \"https://example.com/ingest\", \"method\": \"POST\" }\n}\n```\n\n## `mcp_local` (unsafe)\n\nThis tool provides **local machine access** (exec + filesystem). It is **disabled by default** and is only exposed in `tools/list` when you set:\n\n- `SENTRYFROGG_UNSAFE_LOCAL=1` (preferred), or\n- `SF_UNSAFE_LOCAL=1`\n\nKey actions:\n- `exec` / `batch`\n- `fs_read` / `fs_write` / `fs_list` / `fs_stat` / `fs_mkdir` / `fs_rm`\n\nExec example (also available via alias `local`):\n\n```json\n{\n  \"action\": \"exec\",\n  \"command\": \"git\",\n  \"args\": [\"status\", \"--porcelain\"],\n  \"inline\": true\n}\n```\n\nFilesystem example:\n\n```json\n{ \"action\": \"fs_write\", \"path\": \"/tmp/hello.txt\", \"content\": \"hello\", \"overwrite\": true }\n```\n\n```json\n{ \"action\": \"fs_read\", \"path\": \"/tmp/hello.txt\" }\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 228,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "integration/README.md": [
      {
        "file_path": "integration/README.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# Integration Stacks\n\nThis directory provides local Docker targets for integration testing of the MCP tools.\n\n## Quick run (EN)\n\n- Start: `docker compose -f integration/docker-compose.yml up -d --build`\n- Smoke check: `npm run smoke`\n- Stop: `docker compose -f integration/docker-compose.yml down -v`\n\n### Smoke environment overrides\n\n`integration/smoke.ts` supports:\n- `SF_PG_URI` (default: `postgresql://mcp_user:mcp_pass@127.0.0.1:5432/mcp_demo`)\n- `SF_SSH_HOST` (default: `127.0.0.1`)\n- `SF_SSH_PORT` (default: `2222`)\n- `SF_SSH_USER` (default: `mcp`)\n- `SF_SSH_PASSWORD` (default: `mcp_pass`)\n\n### Port conflicts\n\nIf `5432` or `2222` are already in use on your machine, change the `ports:` mappings in `integration/docker-compose.yml` and set `SF_PG_URI` / `SF_SSH_PORT` accordingly for `npm run smoke`.\n\n---\n\n## –†—É—Å—Å–∫–∏–π\n\n–≠—Ç–æ—Ç –∫–∞—Ç–∞–ª–æ–≥ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–µ —Å—Ç–µ–Ω–¥—ã –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è MCP-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.\n\n## –°–µ—Ä–≤–∏—Å—ã\n\n- **PostgreSQL** (`postgres:16-alpine`): –±–∞–∑–∞ `mcp_demo`, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å `mcp_user`, –ø–∞—Ä–æ–ª—å `mcp_pass`, –ø–æ—Ä—Ç `5432`.\n- **SSH** (–∫–∞—Å—Ç–æ–º–Ω—ã–π Alpine OpenSSH): –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å `mcp`, –ø–∞—Ä–æ–ª—å `mcp_pass`, –ø–æ—Ä—Ç `2222`.\n\n## –ó–∞–ø—É—Å–∫",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 332,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "integration/README.md",
        "start_line": 39,
        "end_line": 96,
        "content": "\n```bash\ndocker compose -f integration/docker-compose.yml up -d --build\n```\n\n–ü–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π smoke-–ø—Ä–æ–≥–æ–Ω:\n\n```bash\nnpm run smoke\n```\n\n## –û—Å—Ç–∞–Ω–æ–≤–∫–∞\n\n```bash\ndocker compose -f integration/docker-compose.yml down -v\n```\n\n## –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏\n\n- PostgreSQL: `psql postgresql://mcp_user:mcp_pass@127.0.0.1:5432/mcp_demo`\n- SSH: `ssh mcp@127.0.0.1 -p 2222` (–ø–∞—Ä–æ–ª—å `mcp_pass`)\n\n## –ï—Å–ª–∏ –ø–æ—Ä—Ç—ã –∑–∞–Ω—è—Ç—ã\n\n–ï—Å–ª–∏ –Ω–∞ –º–∞—à–∏–Ω–µ —É–∂–µ –∑–∞–Ω—è—Ç `5432` –∏–ª–∏ `2222`, –ø–æ–º–µ–Ω—è–π—Ç–µ –ø—Ä–æ–±—Ä–æ—Å `ports:` –≤ `integration/docker-compose.yml` –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ `SF_PG_URI` / `SF_SSH_PORT` –¥–ª—è `npm run smoke`.\n\n## –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å MCP –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏\n\n–ü–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ —Å—Ç–µ–Ω–¥–∞ –º–æ–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å `profile_upsert` —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏:\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"integration\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 5432,\n    \"username\": \"mcp_user\",\n    \"password\": \"mcp_pass\",\n    \"database\": \"mcp_demo\"\n  }\n}\n```\n\n–∏\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"integration-ssh\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 2222,\n    \"username\": \"mcp\",\n    \"password\": \"mcp_pass\"\n  }\n}\n```",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 346,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "integration/smoke.ts": [
      {
        "file_path": "integration/smoke.ts",
        "start_line": 14,
        "end_line": 30,
        "content": "async function retry(label, attempts, task, backoffMs = 2000) {\n  let lastError;\n  for (let attempt = 1; attempt <= attempts; attempt += 1) {\n    try {\n      return await task();\n    } catch (error) {\n      lastError = error;\n      if (attempt < attempts) {\n        process.stderr.write(\n          `[smoke] ${label} attempt ${attempt} failed: ${error.message}. Retrying in ${backoffMs}ms\\n`\n        );\n        await delay(backoffMs);\n      }\n    }\n  }\n  throw lastError;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "retry",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 118,
          "qualified_name": "retry",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "integration/smoke.ts",
        "start_line": 32,
        "end_line": 47,
        "content": "async function checkPostgres() {\n  return retry('postgres', 15, async () => {\n    const client = new PgClient({ connectionString: PG_URI });\n    await client.connect();\n    try {\n      const res = await client.query('SELECT current_database() AS db, current_user AS usr, 1 AS ok');\n      const row = res.rows[0];\n      if (!row || row.ok !== 1) {\n        throw new Error('Unexpected response from PostgreSQL');\n      }\n      process.stdout.write(`[smoke] PostgreSQL ready (db=${row.db}, user=${row.usr})\\n`);\n    } finally {\n      await client.end();\n    }\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "checkPostgres",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 141,
          "qualified_name": "checkPostgres",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "integration/smoke.ts",
        "start_line": 49,
        "end_line": 91,
        "content": "async function execSSH(command) {\n  return new Promise((resolve, reject) => {\n    const client = new SSHClient();\n    client\n      .on('ready', () => {\n        client.exec(command, (err, stream) => {\n          if (err) {\n            client.end();\n            reject(err);\n            return;\n          }\n\n          let stdout = '';\n          let stderr = '';\n\n          stream\n            .on('close', (code) => {\n              client.end();\n              if (code === 0) {\n                resolve({ stdout: stdout.trim(), stderr: stderr.trim() });\n              } else {\n                reject(new Error(`SSH command exited with code ${code}: ${stderr.trim()}`));\n              }\n            })\n            .on('data', (data) => {\n              stdout += data.toString();\n            });\n\n          stream.stderr.on('data', (data) => {\n            stderr += data.toString();\n          });\n        });\n      })\n      .on('error', reject)\n      .connect({\n        host: SSH_HOST,\n        port: SSH_PORT,\n        username: SSH_USER,\n        password: SSH_PASSWORD,\n        readyTimeout: 10000,\n      });\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "execSSH",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 277,
          "qualified_name": "execSSH",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "integration/smoke.ts",
        "start_line": 93,
        "end_line": 101,
        "content": "async function checkSsh() {\n  await retry('ssh', 15, async () => {\n    const result = await execSSH('printf \"integration:%s\\n\" \"$(uname -s)\"');\n    if (!result.stdout.startsWith('integration:')) {\n      throw new Error('Unexpected SSH response');\n    }\n    process.stdout.write(`[smoke] SSH ready (${result.stdout})\\n`);\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "checkSsh",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 82,
          "qualified_name": "checkSsh",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "integration/smoke.ts",
        "start_line": 103,
        "end_line": 107,
        "content": "async function main() {\n  await checkPostgres();\n  await checkSsh();\n  process.stdout.write('[smoke] Integration targets healthy\\n');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "main",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 33,
          "qualified_name": "main",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "mcp_config.md": [
      {
        "file_path": "mcp_config.md",
        "start_line": 1,
        "end_line": 38,
        "content": " [LEGEND]\n\n[CONTENT]\n# MCP Configuration\n\nSentryFrogg is a **stdio-based** Model Context Protocol (MCP) server. Your MCP client should spawn `node` and point it at `dist/sentryfrogg_server.js`.\n\nSee also:\n- `docs/tools.md` (tool reference + examples)\n- `docs/architecture.md` (architecture overview)\n\n## Minimal client config (stdio)\n\n```json\n{\n  \"mcpServers\": {\n    \"sentryfrogg\": {\n      \"command\": \"node\",\n      \"args\": [\"/absolute/path/to/dist/sentryfrogg_server.js\"]\n    }\n  }\n}\n```\n\nNotes:\n- Use an **absolute** path to avoid working-directory surprises.\n- PostgreSQL and SSH can use `profile_*` actions or inline connection per request.\n\n## Where profiles and keys are stored\n\nBy default, SentryFrogg stores local state in an OS-friendly location:\n- `${XDG_STATE_HOME}/sentryfrogg` when `XDG_STATE_HOME` is set, otherwise\n- `~/.local/state/sentryfrogg` (HOME fallback).\n\nStore files:\n- `profiles.json` (encrypted profile store)\n- `.mcp_profiles.key` (persistent encryption key, created with `0600` permissions)\n- `state.json` (persistent state store)",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 264,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "mcp_config.md",
        "start_line": 39,
        "end_line": 76,
        "content": "- `projects.json` (project registry)\n- `context.json` (project context cache)\n- `runbooks.json` (runbook definitions)\n- `capabilities.json` (capability registry)\n- `aliases.json` (alias registry)\n- `presets.json` (preset registry)\n- `audit.jsonl` (audit log)\n- `cache/` (HTTP/pipeline cache)\n\nRecommended environment variables:\n- `MCP_PROFILES_DIR`: directory for `profiles.json` (keep it **outside** the repository)\n- `MCP_PROFILES_PATH`: explicit path to `profiles.json`\n- `MCP_PROFILE_KEY_PATH`: explicit path to `.mcp_profiles.key`\n- `MCP_STATE_PATH`: explicit path to `state.json`\n- `MCP_PROJECTS_PATH`: explicit path to `projects.json`\n- `MCP_RUNBOOKS_PATH`: explicit path to `runbooks.json`\n- `MCP_DEFAULT_RUNBOOKS_PATH`: explicit path to default runbooks bundle\n- `MCP_CAPABILITIES_PATH`: explicit path to `capabilities.json`\n- `MCP_DEFAULT_CAPABILITIES_PATH`: explicit path to default capabilities bundle\n- `MCP_CONTEXT_PATH`: explicit path to `context.json`\n- `MCP_ALIASES_PATH`: explicit path to `aliases.json`\n- `MCP_PRESETS_PATH`: explicit path to `presets.json`\n- `MCP_AUDIT_PATH`: explicit path to `audit.jsonl`\n- `MCP_CACHE_DIR`: directory for cache files\n- `ENCRYPTION_KEY`: provide a stable key (recommended for shared/team environments)\n  - accepted formats: **64 hex chars** (32 bytes) / **32 raw chars** / base64 (decoded as bytes)\n- `LOG_LEVEL`: server logging level (`error`, `warn`, `info`, `debug`); logs are written to **stderr** to keep MCP stdout clean\n\nImportant:\n- Never commit local state (`profiles.json`, `state.json`, `projects.json`, `context.json`, `aliases.json`, `presets.json`, `audit.jsonl`, `cache/`, `.mcp_profiles.key`) to git.\n- Default capability/runbook bundles are safe to ship in the repository; local overrides should live outside the repo via `MCP_RUNBOOKS_PATH` / `MCP_CAPABILITIES_PATH`.\n- If these files were ever committed in history: rotate credentials, change `ENCRYPTION_KEY`, and purge git history (e.g., `git filter-repo` / BFG) before making the repository public.\n- Profile format is **not** backward-compatible with pre-5.0 releases. Recreate profiles if upgrading.\n\n## Tool bootstrap flow\n\n1. Call `help` to discover tools and usage.\n2. For PostgreSQL/SSH, optionally persist credentials with `profile_upsert`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 568,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "mcp_config.md",
        "start_line": 77,
        "end_line": 144,
        "content": "3. Run operational actions (`query`, `exec`, `request`, etc.).\n4. Use `mcp_state` + `mcp_runbook` for multi-step workflows if needed.\n\n### PostgreSQL example\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 5432,\n    \"username\": \"user\",\n    \"password\": \"pass\",\n    \"database\": \"dbname\",\n    \"ssl\": false\n  }\n}\n```\n\nThen:\n\n```json\n{\n  \"action\": \"query\",\n  \"profile_name\": \"default\",\n  \"sql\": \"SELECT 1 AS ok\"\n}\n```\n\n### SSH example\n\n```json\n{\n  \"action\": \"profile_upsert\",\n  \"profile_name\": \"default\",\n  \"connection\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 22,\n    \"username\": \"root\",\n    \"password\": \"secret\"\n  }\n}\n```\n\nThen:\n\n```json\n{\n  \"action\": \"exec\",\n  \"profile_name\": \"default\",\n  \"command\": \"uname -a\"\n}\n```\n\n### HTTP example\n\n```json\n{\n  \"action\": \"request\",\n  \"method\": \"GET\",\n  \"url\": \"https://example.com/health\"\n}\n```\n\n## Local integration targets\n\nSee `integration/README.md` for Docker-backed PostgreSQL/SSH targets and the `npm run smoke` script.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 259,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "package.json": [
      {
        "file_path": "package.json",
        "start_line": 1,
        "end_line": 38,
        "content": "{\n  \"name\": \"sentryfrogg-mcp\",\n  \"version\": \"6.4.0\",\n  \"description\": \"Enterprise MCP server for PostgreSQL, SSH and HTTP operations under the SentryFrogg brand\",\n  \"main\": \"dist/sentryfrogg_server.js\",\n  \"type\": \"commonjs\",\n  \"scripts\": {\n    \"build\": \"tsc -p tsconfig.json\",\n    \"build:test\": \"tsc -p tsconfig.test.json\",\n    \"ensure:build\": \"node -e \\\"const fs=require('node:fs'); const path=require('node:path'); const { spawnSync }=require('node:child_process'); const dist=path.join(process.cwd(),'dist','sentryfrogg_server.js'); if (fs.existsSync(dist)) process.exit(0); const res=spawnSync('npm',['run','build'],{stdio:'inherit'}); process.exit(res.status===null?1:res.status);\\\"\",\n    \"prestart\": \"npm run ensure:build\",\n    \"start\": \"node dist/sentryfrogg_server.js\",\n    \"predev\": \"npm run ensure:build\",\n    \"dev\": \"node dist/sentryfrogg_server.js\",\n    \"check\": \"tsc -p tsconfig.json --noEmit\",\n    \"test\": \"npm run build:test && node --test dist/tests/index.js\",\n    \"smoke\": \"npm run build:test && node dist/integration/smoke.js\",\n    \"prepack\": \"npm run build\",\n    \"postinstall\": \"npm run ensure:build\"\n  },\n  \"keywords\": [\n    \"mcp\",\n    \"model-context-protocol\",\n    \"postgresql\",\n    \"postgres\",\n    \"database\",\n    \"sql\",\n    \"api\",\n    \"rest-api\",\n    \"ssh\",\n    \"cursor\",\n    \"claude\",\n    \"ai\",\n    \"artificial-intelligence\",\n    \"database-management\",\n    \"server-management\",\n    \"migration\",\n    \"schema\",",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 358,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "package.json",
        "start_line": 39,
        "end_line": 107,
        "content": "    \"analytics\",\n    \"security\",\n    \"validation\"\n  ],\n  \"author\": \"AmirTlinov\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.25.1\",\n    \"ajv\": \"^8.17.1\",\n    \"node-fetch\": \"^3.3.2\",\n    \"pg\": \"^8.11.3\",\n    \"ssh2\": \"^1.15.0\",\n    \"zod\": \"^3.23.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^18.19.0\",\n    \"@types/pg\": \"^8.11.6\",\n    \"@types/ssh2\": \"^1.15.0\",\n    \"typescript\": \"^5.4.5\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\",\n    \"npm\": \">=8.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/AmirTlinov/sentryfrogg-mcp.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/AmirTlinov/sentryfrogg-mcp/issues\"\n  },\n  \"homepage\": \"https://github.com/AmirTlinov/sentryfrogg-mcp#readme\",\n  \"files\": [\n    \"sentryfrogg_server.ts\",\n    \"dist/\",\n    \"src/\",\n    \"scripts/\",\n    \"package.json\",\n    \"README.md\",\n    \"CHANGELOG.md\",\n    \"LICENSE\",\n    \"profiles.example.json\",\n    \"projects.example.json\",\n    \"runbooks.json\",\n    \"capabilities.json\"\n  ],\n  \"os\": [\n    \"darwin\",\n    \"linux\",\n    \"win32\"\n  ],\n  \"cpu\": [\n    \"x64\",\n    \"arm64\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"registry\": \"https://registry.npmjs.org/\"\n  },\n  \"config\": {\n    \"mcp_version\": \"1.0\",\n    \"supported_protocols\": [\n      \"mcp\",\n      \"postgresql\",\n      \"ssh\",\n      \"http\"\n    ]\n  }\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 336,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "profiles.example.json": [
      {
        "file_path": "profiles.example.json",
        "start_line": 1,
        "end_line": 17,
        "content": "{\n  \"example-postgres\": {\n    \"type\": \"postgresql\",\n    \"data\": {\n      \"host\": \"db.internal\",\n      \"port\": 5432,\n      \"username\": \"service\",\n      \"database\": \"core\",\n      \"ssl\": { \"enabled\": true }\n    },\n    \"secrets\": {\n      \"password\": \"<encrypted-placeholder>\"\n    },\n    \"created_at\": \"2025-01-01T00:00:00.000Z\",\n    \"updated_at\": \"2025-01-01T00:00:00.000Z\"\n  }\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 93,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "projects.example.json": [
      {
        "file_path": "projects.example.json",
        "start_line": 1,
        "end_line": 21,
        "content": "{\n  \"demo\": {\n    \"description\": \"Demo project for SentryFrogg.\",\n    \"default_target\": \"prod\",\n    \"targets\": {\n      \"prod\": {\n        \"description\": \"Production cluster\",\n        \"ssh_profile\": \"demo-prod-ssh\",\n        \"env_profile\": \"demo-prod-env\",\n        \"postgres_profile\": \"demo-prod-db\",\n        \"api_profile\": \"demo-prod-api\",\n        \"vault_profile\": \"demo-prod-vault\",\n        \"cwd\": \"/srv/demo\",\n        \"env_path\": \"/srv/demo/.env\",\n        \"kubeconfig\": \"/home/user/.kube/demo-prod\",\n        \"sops_age_key_file\": \"/home/user/.agekey\",\n        \"api_base_url\": \"https://api.example.com\"\n      }\n    }\n  }\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 155,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/bootstrap/manifest.v2.json": [
      {
        "file_path": "reports/bootstrap/manifest.v2.json",
        "start_line": 1,
        "end_line": 27,
        "content": "{\n  \"version\": 2,\n  \"files\": {\n    \"bootstrap/flagship/.clang-format\": \"55da651c09e391c5bba3e112f607f7d1cf7acfee584b97678b8bf04c30ef441d\",\n    \"bootstrap/flagship/.clang-tidy\": \"03db47e161043c4b78e237bbd8c81b8f276faa4efa1490ec610153d9e44a6b98\",\n    \"bootstrap/flagship/.jscpdignore\": \"9bf6154b9bb161e1dd29960adde5937b695facc7e00cdfd029be2c667bad6bf5\",\n    \"bootstrap/flagship/.prettierignore\": \"d807252e1a01045f2c7814166d512f36acefa008d9b48d07b6ad8d72c9f6e5ca\",\n    \"bootstrap/flagship/Makefile\": \"dfa378e9fe1c89d56fbfa355825f67fc6d1f4ece17ac9387ddbb44aedc8c2a30\",\n    \"bootstrap/flagship/clippy.toml\": \"45b78cdac444546d03411bf607b776b2627ec5d043a255765d13cbd670a0606c\",\n    \"bootstrap/flagship/configs/guardrails.json\": \"97084aaf77913c0040650c70d34a708a87375d77762c024130636289c30f786a\",\n    \"bootstrap/flagship/eslint.config.mjs\": \"ec3dbde3037c4f623ea3be234855b69ed64998dde951606a57a085a1d8c18b15\",\n    \"bootstrap/flagship/package-lock.json\": \"75827a6faa9ab72cb26ae33c73eaa9ec7b37df3a10616209eb4d845be22ad507\",\n    \"bootstrap/flagship/package.json\": \"0a9c467dc38fc882d04bcd16435f34e600c2a756656c3cfbd920484189c7d063\",\n    \"bootstrap/flagship/scripts/bench/generate_baseline.py\": \"6862b3b8e733d98db86f67c5975470cb59b1e78e07cedbfc3f9d30bda9c5c1e4\",\n    \"bootstrap/flagship/scripts/bench/parse_p95_p99.sh\": \"ba35f74d3cc0d7c8f90b6ffcafa93692af8e62907d93bb337d20a5141684a28d\",\n    \"bootstrap/flagship/scripts/bootstrap/install_node.sh\": \"9f87ff90547c5860072b3cf2ae16b488141dce195e152297429ce9be62c99f92\",\n    \"bootstrap/flagship/scripts/bootstrap/install_syft.sh\": \"f2cede4def77bb18508d5f159acaa5e2eadbce90f441cee96306517cec8a2ff7\",\n    \"bootstrap/flagship/scripts/cpp/generate_compile_commands.sh\": \"65aaaba9bc6bd78582017914d216e1e1beb9fa38493d4a834589ab10e2e67715\",\n    \"bootstrap/flagship/scripts/quality/complexity.py\": \"ba20090b282932ddbb449a8b2545aa9c29288da8d20286f5af0414337b6b268d\",\n    \"bootstrap/flagship/scripts/quality/complexity.sh\": \"5709f24ec16cf87da04ee10597f020fdb90ad54db722c25d1f0a2b7cb1310226\",\n    \"bootstrap/flagship/scripts/quality/guard.py\": \"8e074822770e154ec45dc22b74b829f9a9d9bb512813cc4421e40375b3bc3a21\",\n    \"bootstrap/flagship/scripts/quality/merge_cyclonedx.py\": \"f3f54d8f83f1a0cfc30e1cb9a9976ac4b859ed819b1e8de7468ea2cb22a45423\",\n    \"bootstrap/flagship/scripts/security/aggregate.py\": \"ce9efdc4f545f3c9f9480081e0a10a7ae1740fe3cf164ee7ceea86249b733cfd\",\n    \"bootstrap/flagship/scripts/security/patch_pip.py\": \"5bcd2816397dbacce8c207c5e0d2c057fd7162142b751c37474f4c7fdd3b6c2b\",\n    \"bootstrap/flagship/stylelint.config.mjs\": \"301775871d8067584e792010d3954658fe4e7eed81113c4654d9d6f943630c40\"\n  }\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 657,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/metrics.json": [
      {
        "file_path": "reports/metrics.json",
        "start_line": 1,
        "end_line": 33,
        "content": "{\n  \"generated_at\": \"2025-10-13T11:18:45Z\",\n  \"entries\": [\n    {\n      \"file\": \"src/services/Validation.ts\",\n      \"symbol\": \"ensureString\",\n      \"cyclomatic\": 3,\n      \"cognitive\": 3,\n      \"notes\": \"Trim flag added; two guard branches.\"\n    },\n    {\n      \"file\": \"src/services/Validation.ts\",\n      \"symbol\": \"ensureOptionalString\",\n      \"cyclomatic\": 2,\n      \"cognitive\": 2,\n      \"notes\": \"Delegates to ensureString with preserved options.\"\n    },\n    {\n      \"file\": \"src/services/Validation.ts\",\n      \"symbol\": \"ensureConnectionProfile\",\n      \"cyclomatic\": 5,\n      \"cognitive\": 5,\n      \"notes\": \"Password path updated without structural change; limits remain ‚â§10/‚â§15.\"\n    },\n    {\n      \"file\": \"tests/validation.test.ts\",\n      \"symbol\": \"module\",\n      \"cyclomatic\": 1,\n      \"cognitive\": 1,\n      \"notes\": \"Three declarative node:test cases.\"\n    }\n  ]\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 219,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/latest.json": [
      {
        "file_path": "reports/releases/latest.json",
        "start_line": 1,
        "end_line": 13,
        "content": "{\n  \"timestamp\": \"2025-10-13T12:28:26Z\",\n  \"runtime_commit\": \"7cc757ff8954ef85cbb140535f9cbaf23c10dc2c\",\n  \"runtime_commit_short\": \"7cc757ff\",\n  \"artifact\": \"flagship-universal-bootstrap_v7_1.tar.gz\",\n  \"artifact_sha\": \"e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d\",\n  \"artifact_sha_paths\": [\n    \"/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\",\n    \"reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\"\n  ],\n  \"metrics\": {},\n  \"cli_version\": \"0.3.6\"\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 138,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/latest.md": [
      {
        "file_path": "reports/releases/latest.md",
        "start_line": 1,
        "end_line": 26,
        "content": " [LEGEND]\n\n[CONTENT]\n## Release Summary (2025-10-13T12:28:26Z)\n\n- Runtime commit: `7cc757ff` (7cc757ff8954ef85cbb140535f9cbaf23c10dc2c)\n- CLI version: `0.3.6`\n- Artifact: `flagship-universal-bootstrap_v7_1.tar.gz`\n- SHA256: `e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d`\n- SHA reports: `/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256` / `reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n\n## Checklist\n- [x] make bootstrap-sync\n- [x] make bootstrap-test\n- [x] make bootstrap-dist\n- [x] make bootstrap-clean-all\n- [ ] Publish artifacts to release\n- [ ] Announce release\n\n## Upload Instructions\n1. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz`\n2. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n3. Copy SHA256 above into release description\n\n---\nGenerated via `make bootstrap-release-notes`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 231,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/release-2025-10-13T11:17:54Z.json": [
      {
        "file_path": "reports/releases/release-2025-10-13T11:17:54Z.json",
        "start_line": 1,
        "end_line": 13,
        "content": "{\n  \"timestamp\": \"2025-10-13T11:17:54Z\",\n  \"runtime_commit\": \"7cc757ff8954ef85cbb140535f9cbaf23c10dc2c\",\n  \"runtime_commit_short\": \"7cc757ff\",\n  \"artifact\": \"flagship-universal-bootstrap_v7_1.tar.gz\",\n  \"artifact_sha\": \"e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d\",\n  \"artifact_sha_paths\": [\n    \"/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\",\n    \"reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\"\n  ],\n  \"metrics\": {},\n  \"cli_version\": \"0.3.6\"\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 138,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/release-2025-10-13T11:17:54Z.md": [
      {
        "file_path": "reports/releases/release-2025-10-13T11:17:54Z.md",
        "start_line": 1,
        "end_line": 26,
        "content": " [LEGEND]\n\n[CONTENT]\n## Release Summary (2025-10-13T11:17:54Z)\n\n- Runtime commit: `7cc757ff` (7cc757ff8954ef85cbb140535f9cbaf23c10dc2c)\n- CLI version: `0.3.6`\n- Artifact: `flagship-universal-bootstrap_v7_1.tar.gz`\n- SHA256: `e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d`\n- SHA reports: `/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256` / `reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n\n## Checklist\n- [x] make bootstrap-sync\n- [x] make bootstrap-test\n- [x] make bootstrap-dist\n- [x] make bootstrap-clean-all\n- [ ] Publish artifacts to release\n- [ ] Announce release\n\n## Upload Instructions\n1. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz`\n2. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n3. Copy SHA256 above into release description\n\n---\nGenerated via `make bootstrap-release-notes`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 231,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/release-2025-10-13T12:28:26Z.json": [
      {
        "file_path": "reports/releases/release-2025-10-13T12:28:26Z.json",
        "start_line": 1,
        "end_line": 13,
        "content": "{\n  \"timestamp\": \"2025-10-13T12:28:26Z\",\n  \"runtime_commit\": \"7cc757ff8954ef85cbb140535f9cbaf23c10dc2c\",\n  \"runtime_commit_short\": \"7cc757ff\",\n  \"artifact\": \"flagship-universal-bootstrap_v7_1.tar.gz\",\n  \"artifact_sha\": \"e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d\",\n  \"artifact_sha_paths\": [\n    \"/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\",\n    \"reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256\"\n  ],\n  \"metrics\": {},\n  \"cli_version\": \"0.3.6\"\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 138,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "reports/releases/release-2025-10-13T12:28:26Z.md": [
      {
        "file_path": "reports/releases/release-2025-10-13T12:28:26Z.md",
        "start_line": 1,
        "end_line": 26,
        "content": " [LEGEND]\n\n[CONTENT]\n## Release Summary (2025-10-13T12:28:26Z)\n\n- Runtime commit: `7cc757ff` (7cc757ff8954ef85cbb140535f9cbaf23c10dc2c)\n- CLI version: `0.3.6`\n- Artifact: `flagship-universal-bootstrap_v7_1.tar.gz`\n- SHA256: `e84fe1f4f058202750a4a79c3c55ff38cda002a61a80777e22a17c1933d8954d`\n- SHA reports: `/home/amir/–î–æ–∫—É–º–µ–Ω—Ç—ã/PROJECTS/mcp/SentryFrogg/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256` / `reports/artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n\n## Checklist\n- [x] make bootstrap-sync\n- [x] make bootstrap-test\n- [x] make bootstrap-dist\n- [x] make bootstrap-clean-all\n- [ ] Publish artifacts to release\n- [ ] Announce release\n\n## Upload Instructions\n1. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz`\n2. Attach `artifacts/flagship-universal-bootstrap_v7_1.tar.gz.sha256`\n3. Copy SHA256 above into release description\n\n---\nGenerated via `make bootstrap-release-notes`.",
        "metadata": {
          "language": "markdown",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 231,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "scripts/start-mcp-server.sh": [
      {
        "file_path": "scripts/start-mcp-server.sh",
        "start_line": 1,
        "end_line": 38,
        "content": "#!/usr/bin/env bash\nset -euo pipefail\n\nROOT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" && pwd)\"\nLOCK_FILE=\"$ROOT_DIR/package-lock.json\"\nSTAMP_FILE=\"$ROOT_DIR/.npm-install.checksum\"\nLOG_PREFIX=\"[sentryfrogg-setup]\"\n\nhash_file() {\n  sha256sum \"$1\" | awk '{print $1}'\n}\n\nif [[ ! -f \"$LOCK_FILE\" ]]; then\n  echo \"$LOG_PREFIX package-lock.json –Ω–µ –Ω–∞–π–¥–µ–Ω\" >&2\n  exit 1\nfi\n\nDESIRED_HASH=\"$(hash_file \"$LOCK_FILE\")\"\nCURRENT_HASH=\"\"\nif [[ -f \"$STAMP_FILE\" ]]; then\n  CURRENT_HASH=\"$(cat \"$STAMP_FILE\")\"\nfi\n\nif [[ ! -d \"$ROOT_DIR/node_modules\" || \"$CURRENT_HASH\" != \"$DESIRED_HASH\" ]]; then\n  echo \"$LOG_PREFIX –∑–∞–ø—É—Å–∫–∞—é npm ci (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π)\" >&2\n  (cd \"$ROOT_DIR\" && npm ci --include=dev)\n  printf '%s' \"$DESIRED_HASH\" > \"$STAMP_FILE\"\n  echo \"$LOG_PREFIX –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≥–æ—Ç–æ–≤—ã\" >&2\nfi\n\ncd \"$ROOT_DIR\"\nif [[ -f \"$ROOT_DIR/dist/sentryfrogg_server.js\" ]]; then\n  exec node dist/sentryfrogg_server.js \"$@\"\nfi\n\necho \"$LOG_PREFIX dist –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–±–∏—Ä–∞—é TypeScript\" >&2\nnpm run build\nexec node dist/sentryfrogg_server.js \"$@\"",
        "metadata": {
          "language": "shell",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 272,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "sentryfrogg_server.ts": [
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 70,
        "end_line": 75,
        "content": "function resolveToolTier() {\n  const raw = String(process.env.SENTRYFROGG_TOOL_TIER || process.env.SF_TOOL_TIER || 'full')\n    .trim()\n    .toLowerCase();\n  return raw === 'core' ? 'core' : 'full';\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveToolTier",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 49,
          "qualified_name": "resolveToolTier",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 77,
        "end_line": 82,
        "content": "function filterToolCatalogForTier(tools, tier) {\n  if (tier !== 'core') {\n    return tools;\n  }\n  return tools.filter((tool) => CORE_TOOL_NAMES.has(tool.name));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "filterToolCatalogForTier",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 40,
          "qualified_name": "filterToolCatalogForTier",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 937,
        "end_line": 956,
        "content": "function formatSchemaErrors(errors) {\n  if (!Array.isArray(errors) || errors.length === 0) {\n    return 'Invalid arguments';\n  }\n\n  const rendered = errors.slice(0, 8).map((err) => {\n    const at = err.instancePath ? err.instancePath : '(root)';\n    if (err.keyword === 'additionalProperties' && err.params && err.params.additionalProperty) {\n      return `${at}: unknown field '${err.params.additionalProperty}'`;\n    }\n    if (err.keyword === 'type' && err.params && err.params.type) {\n      return `${at}: expected ${err.params.type}`;\n    }\n    return `${at}: ${err.message || err.keyword}`;\n  });\n\n  return errors.length > rendered.length\n    ? `${rendered.join('; ')} (+${errors.length - rendered.length} more)`\n    : rendered.join('; ');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatSchemaErrors",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 186,
          "qualified_name": "formatSchemaErrors",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 958,
        "end_line": 976,
        "content": "function assertToolArgsValid(toolName, args) {\n  const canonical = HELP_TOOL_ALIASES[toolName] || toolName;\n  const tool = toolByName[canonical];\n  if (!tool || !tool.inputSchema) {\n    return;\n  }\n\n  const payload = args && typeof args === 'object' && !Array.isArray(args) ? args : {};\n\n  let validate = validatorByTool.get(canonical);\n  if (!validate) {\n    validate = ajv.compile(tool.inputSchema);\n    validatorByTool.set(canonical, validate);\n  }\n\n  if (!validate(payload)) {\n    throw new McpError(ErrorCode.InvalidParams, formatSchemaErrors(validate.errors));\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "assertToolArgsValid",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 143,
          "qualified_name": "assertToolArgsValid",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 978,
        "end_line": 1034,
        "content": "function normalizeJsonSchemaForOpenAI(schema) {\n  if (schema === null || schema === undefined) {\n    return schema;\n  }\n  if (typeof schema !== 'object') {\n    return schema;\n  }\n  if (Array.isArray(schema)) {\n    return schema.map((item) => normalizeJsonSchemaForOpenAI(item));\n  }\n\n  const out = { ...schema };\n\n  if (out.properties && typeof out.properties === 'object') {\n    out.properties = Object.fromEntries(\n      Object.entries(out.properties).map(([key, value]) => [key, normalizeJsonSchemaForOpenAI(value)])\n    );\n  }\n\n  if (out.items !== undefined) {\n    out.items = normalizeJsonSchemaForOpenAI(out.items);\n  }\n\n  if (out.additionalProperties && typeof out.additionalProperties === 'object') {\n    out.additionalProperties = normalizeJsonSchemaForOpenAI(out.additionalProperties);\n  }\n\n  for (const keyword of ['anyOf', 'oneOf', 'allOf']) {\n    if (Array.isArray(out[keyword])) {\n      out[keyword] = out[keyword].map((sub) => normalizeJsonSchemaForOpenAI(sub));\n    }\n  }\n\n  if (Array.isArray(out.type)) {\n    const types = out.type.slice();\n    delete out.type;\n\n    const shared = { ...out };\n    delete shared.items;\n\n    return {\n      ...shared,\n      anyOf: types.map((t) => {\n        if (t === 'array') {\n          return { type: 'array', items: out.items ?? {} };\n        }\n        return { type: t };\n      }),\n    };\n  }\n\n  if (out.type === 'array' && out.items === undefined) {\n    out.items = {};\n  }\n\n  return out;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeJsonSchemaForOpenAI",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 361,
          "qualified_name": "normalizeJsonSchemaForOpenAI",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1047,
        "end_line": 1066,
        "content": "function stripToolSemanticFields(schema) {\n  if (!schema || typeof schema !== 'object') {\n    return schema;\n  }\n\n  if (!schema.properties || typeof schema.properties !== 'object') {\n    return schema;\n  }\n\n  const out = { ...schema, properties: { ...schema.properties } };\n  for (const key of TOOL_SEMANTIC_FIELDS) {\n    delete out.properties[key];\n  }\n\n  if (Array.isArray(out.required)) {\n    out.required = out.required.filter((key) => !TOOL_SEMANTIC_FIELDS.has(key));\n  }\n\n  return out;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "stripToolSemanticFields",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 123,
          "qualified_name": "stripToolSemanticFields",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1070,
        "end_line": 1079,
        "content": "function isDirectory(candidate) {\n  if (!candidate) {\n    return false;\n  }\n  try {\n    return fsSync.existsSync(candidate) && fsSync.statSync(candidate).isDirectory();\n  } catch (error) {\n    return false;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isDirectory",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 53,
          "qualified_name": "isDirectory",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1081,
        "end_line": 1087,
        "content": "function resolveContextRepoRoot() {\n  const explicit = process.env.SENTRYFROGG_CONTEXT_REPO_ROOT || process.env.SF_CONTEXT_REPO_ROOT;\n  if (explicit) {\n    return isDirectory(explicit) ? explicit : null;\n  }\n  return isDirectory(DEFAULT_CONTEXT_REPO_ROOT) ? DEFAULT_CONTEXT_REPO_ROOT : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveContextRepoRoot",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 73,
          "qualified_name": "resolveContextRepoRoot",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1089,
        "end_line": 1112,
        "content": "function asString(value) {\n  if (value === null || value === undefined) {\n    return String(value);\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n  if (Buffer.isBuffer(value)) {\n    return `[buffer:${value.length}]`;\n  }\n  if (Array.isArray(value)) {\n    return `[array:${value.length}]`;\n  }\n  if (typeof value === 'object') {\n    const keys = Object.keys(value);\n    const shown = keys.slice(0, 6);\n    const suffix = keys.length > shown.length ? ', ...' : '';\n    return `{${shown.join(', ')}${suffix}}`;\n  }\n  return String(value);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "asString",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 161,
          "qualified_name": "asString",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1114,
        "end_line": 1155,
        "content": "function compactValue(value, options = {}, depth = 0) {\n  const config = {\n    maxDepth: Number.isFinite(options.maxDepth) ? options.maxDepth : 6,\n    maxArray: Number.isFinite(options.maxArray) ? options.maxArray : 50,\n    maxKeys: Number.isFinite(options.maxKeys) ? options.maxKeys : 50,\n  };\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n  if (typeof value !== 'object') {\n    return value;\n  }\n  if (Buffer.isBuffer(value)) {\n    return `[buffer:${value.length}]`;\n  }\n  if (depth >= config.maxDepth) {\n    if (Array.isArray(value)) {\n      return `[array:${value.length}]`;\n    }\n    return '[object]';\n  }\n\n  if (Array.isArray(value)) {\n    const slice = value.slice(0, config.maxArray).map((item) => compactValue(item, config, depth + 1));\n    if (value.length > config.maxArray) {\n      slice.push(`[... +${value.length - config.maxArray} more]`);\n    }\n    return slice;\n  }\n\n  const keys = Object.keys(value);\n  const limited = keys.slice(0, config.maxKeys);\n  const out = {};\n  for (const key of limited) {\n    out[key] = compactValue(value[key], config, depth + 1);\n  }\n  if (keys.length > config.maxKeys) {\n    out.__more_keys__ = keys.length - config.maxKeys;\n  }\n  return out;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "compactValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 304,
          "qualified_name": "compactValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1157,
        "end_line": 1203,
        "content": "function collectArtifactRefs(value, options = {}) {\n  const maxRefs = Number.isFinite(options.maxRefs) ? options.maxRefs : 25;\n  const maxDepth = Number.isFinite(options.maxDepth) ? options.maxDepth : 10;\n  const refs = [];\n  const seen = new Set();\n  const stack = [{ value, depth: 0 }];\n\n  while (stack.length > 0 && refs.length < maxRefs) {\n    const current = stack.pop();\n    if (!current) {\n      continue;\n    }\n    const node = current.value;\n    const depth = current.depth;\n\n    if (typeof node === 'string') {\n      const trimmed = node.trim();\n      if (trimmed.startsWith('artifact://') && !seen.has(trimmed)) {\n        seen.add(trimmed);\n        refs.push(trimmed);\n      }\n      continue;\n    }\n\n    if (!node || typeof node !== 'object' || Buffer.isBuffer(node)) {\n      continue;\n    }\n\n    if (depth >= maxDepth) {\n      continue;\n    }\n\n    if (Array.isArray(node)) {\n      for (let idx = node.length - 1; idx >= 0; idx -= 1) {\n        stack.push({ value: node[idx], depth: depth + 1 });\n      }\n      continue;\n    }\n\n    const values = Object.values(node);\n    for (let idx = values.length - 1; idx >= 0; idx -= 1) {\n      stack.push({ value: values[idx], depth: depth + 1 });\n    }\n  }\n\n  return refs;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "collectArtifactRefs",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 306,
          "qualified_name": "collectArtifactRefs",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1205,
        "end_line": 1216,
        "content": "function buildContextHeaderLegend() {\n  return [\n    '[LEGEND]',\n    'A = Answer line (1‚Äì3 lines max).',\n    'R = Reference anchor.',\n    'C = Command to verify/reproduce.',\n    'E = Error (typed, actionable).',\n    'M = Continuation marker (cursor/more).',\n    'N = Note.',\n    '',\n  ];\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildContextHeaderLegend",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 72,
          "qualified_name": "buildContextHeaderLegend",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1218,
        "end_line": 1220,
        "content": "function formatContextDoc(lines) {\n  return `${lines.join('\\n').trim()}\\n`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatContextDoc",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 19,
          "qualified_name": "formatContextDoc",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1222,
        "end_line": 1235,
        "content": "function formatToolErrorMessage(tool, error) {\n  const lines = [\n    'SentryFroggError',\n    `tool: ${tool}`,\n    `kind: ${error.kind}`,\n    `code: ${error.code}`,\n    `retryable: ${error.retryable === true}`,\n    `message: ${error.message}`,\n  ];\n  if (error.hint) {\n    lines.push(`hint: ${error.hint}`);\n  }\n  return lines.join('\\n');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatToolErrorMessage",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 84,
          "qualified_name": "formatToolErrorMessage",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1237,
        "end_line": 1259,
        "content": "function mapToolErrorToMcpError(tool, error) {\n  if (!ToolError.isToolError(error)) {\n    return new McpError(ErrorCode.InternalError, `–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è ${tool}: ${error?.message || String(error)}`);\n  }\n\n  const message = formatToolErrorMessage(tool, error);\n\n  switch (error.kind) {\n    case 'invalid_params':\n      return new McpError(ErrorCode.InvalidParams, message);\n    case 'timeout':\n      return new McpError(ErrorCode.RequestTimeout, message);\n    case 'denied':\n    case 'conflict':\n    case 'not_found':\n      return new McpError(ErrorCode.InvalidRequest, message);\n    case 'retryable':\n      return new McpError(ErrorCode.InternalError, message);\n    case 'internal':\n    default:\n      return new McpError(ErrorCode.InternalError, message);\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "mapToolErrorToMcpError",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 194,
          "qualified_name": "mapToolErrorToMcpError",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1261,
        "end_line": 1350,
        "content": "function formatHelpResultToContext(result) {\n  const lines = buildContextHeaderLegend();\n  lines.push('[CONTENT]');\n\n  if (!result || typeof result !== 'object') {\n    lines.push(`A: help`);\n    lines.push(`N: invalid help payload (${typeof result})`);\n    return formatContextDoc(lines);\n  }\n\n  if (result.error) {\n    lines.push(`E: ${result.error}`);\n    if (Array.isArray(result.known_tools)) {\n      lines.push(`N: known_tools: ${result.known_tools.join(', ')}`);\n    }\n    if (result.hint) {\n      lines.push(`N: hint: ${result.hint}`);\n    }\n    return formatContextDoc(lines);\n  }\n\n  if (result.name && Array.isArray(result.actions)) {\n    lines.push(`A: help({ tool: '${result.name}'${result.action ? \", action: '\" + result.action + \"'\" : ''} })`);\n    if (result.description) {\n      lines.push(`N: ${result.description}`);\n    }\n    if (result.usage) {\n      lines.push(`N: usage: ${result.usage}`);\n    }\n\n    if (Array.isArray(result.actions) && result.actions.length > 0) {\n      lines.push('');\n      lines.push('Actions:');\n      for (const action of result.actions) {\n        lines.push(`- ${action}`);\n      }\n    }\n\n    if (Array.isArray(result.fields) && result.fields.length > 0) {\n      lines.push('');\n      lines.push('Fields (action-specific payload, excluding semantic fields):');\n      for (const field of result.fields) {\n        lines.push(`- ${field}`);\n      }\n    }\n\n    if (result.example && typeof result.example === 'object') {\n      lines.push('');\n      lines.push('Example:');\n      lines.push('```json');\n      lines.push(JSON.stringify(result.example, null, 2));\n      lines.push('```');\n    }\n\n    if (result.legend_hint) {\n      lines.push('');\n      lines.push(`N: ${result.legend_hint}`);\n    }\n\n    return formatContextDoc(lines);\n  }\n\n  lines.push('A: help()');\n  if (result.overview) {\n    lines.push(`N: ${result.overview}`);\n  }\n  if (result.usage) {\n    lines.push(`N: usage: ${result.usage}`);\n  }\n\n  if (result.legend?.hint) {\n    lines.push(`N: ${result.legend.hint}`);\n  }\n\n  if (Array.isArray(result.tools)) {\n    lines.push('');\n    lines.push('Tools:');\n    for (const tool of result.tools) {\n      if (!tool || typeof tool !== 'object') {\n        continue;\n      }\n      const actions = Array.isArray(tool.actions) && tool.actions.length > 0\n        ? ` (actions: ${tool.actions.slice(0, 12).join(', ')}${tool.actions.length > 12 ? ', ...' : ''})`\n        : '';\n      lines.push(`- ${tool.name}: ${tool.description}${actions}`);\n    }\n  }\n\n  return formatContextDoc(lines);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatHelpResultToContext",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 633,
          "qualified_name": "formatHelpResultToContext",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1352,
        "end_line": 1418,
        "content": "function formatLegendResultToContext(result) {\n  const lines = buildContextHeaderLegend();\n  lines.push('[CONTENT]');\n  lines.push('A: legend()');\n\n  if (!result || typeof result !== 'object') {\n    lines.push(`E: invalid legend payload (${typeof result})`);\n    return formatContextDoc(lines);\n  }\n\n  if (result.description) {\n    lines.push(`N: ${result.description}`);\n  }\n\n  if (Array.isArray(result.golden_path)) {\n    lines.push('');\n    lines.push('Golden path:');\n    for (const step of result.golden_path) {\n      lines.push(`- ${step}`);\n    }\n  }\n\n  if (result.common_fields && typeof result.common_fields === 'object') {\n    lines.push('');\n    lines.push('Common fields:');\n    for (const [key, entry] of Object.entries(result.common_fields)) {\n      if (!entry || typeof entry !== 'object') {\n        continue;\n      }\n      if (entry.meaning) {\n        lines.push(`- ${key}: ${entry.meaning}`);\n      }\n    }\n  }\n\n  if (result.resolution && typeof result.resolution === 'object') {\n    lines.push('');\n    lines.push('Resolution:');\n    if (Array.isArray(result.resolution.tool_resolution_order)) {\n      lines.push('- tool resolution order:');\n      for (const step of result.resolution.tool_resolution_order) {\n        lines.push(`  - ${step}`);\n      }\n    }\n  }\n\n  if (result.safety && typeof result.safety === 'object') {\n    lines.push('');\n    lines.push('Safety:');\n    for (const [key, entry] of Object.entries(result.safety)) {\n      if (!entry || typeof entry !== 'object') {\n        continue;\n      }\n      if (entry.meaning) {\n        lines.push(`- ${key}: ${entry.meaning}`);\n      }\n      if (entry.gate) {\n        lines.push(`  - gate: ${entry.gate}`);\n      }\n      if (Array.isArray(entry.gates)) {\n        lines.push(`  - gates: ${entry.gates.join(', ')}`);\n      }\n    }\n  }\n\n  return formatContextDoc(lines);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatLegendResultToContext",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 461,
          "qualified_name": "formatLegendResultToContext",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1420,
        "end_line": 1428,
        "content": "function buildArtifactRef({ traceId, spanId }) {\n  const runId = traceId || 'run';\n  const callId = spanId || crypto.randomUUID();\n  const rel = `runs/${runId}/tool_calls/${callId}.context`;\n  return {\n    uri: `artifact://${rel}`,\n    rel,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildArtifactRef",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 61,
          "qualified_name": "buildArtifactRef",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1430,
        "end_line": 1435,
        "content": "async function writeContextArtifact(contextRoot, artifact, content) {\n  const filePath = path.join(contextRoot, 'artifacts', artifact.rel);\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\n  await fs.writeFile(filePath, content, { encoding: 'utf8' });\n  return filePath;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeContextArtifact",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 71,
          "qualified_name": "writeContextArtifact",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1437,
        "end_line": 1506,
        "content": "function formatGenericResultToContext({ tool, action, result, meta, artifactUri, artifactWriteError }) {\n  const lines = ['[CONTENT]'];\n\n  const header = action ? `${tool}.${action}` : tool;\n  lines.push(`A: ${header}`);\n\n  if (meta?.duration_ms !== undefined) {\n    lines.push(`N: duration_ms: ${meta.duration_ms}`);\n  }\n  if (meta?.trace_id) {\n    lines.push(`N: trace_id: ${meta.trace_id}`);\n  }\n  if (meta?.span_id) {\n    lines.push(`N: span_id: ${meta.span_id}`);\n  }\n  if (meta?.parent_span_id) {\n    lines.push(`N: parent_span_id: ${meta.parent_span_id}`);\n  }\n  if (meta?.stored_as) {\n    lines.push(`N: stored_as: ${meta.stored_as}`);\n  }\n  if (meta?.invoked_as) {\n    lines.push(`N: invoked_as: ${meta.invoked_as}`);\n  }\n  if (meta?.preset) {\n    lines.push(`N: preset: ${meta.preset}`);\n  }\n\n  const refDedupe = new Set();\n  if (artifactUri) {\n    refDedupe.add(artifactUri);\n    lines.push(`R: ${artifactUri}`);\n  }\n  if (artifactWriteError) {\n    lines.push(`N: artifact_write_failed: ${artifactWriteError}`);\n  }\n\n  const redacted = redactObject(result);\n  for (const ref of collectArtifactRefs(redacted)) {\n    if (refDedupe.has(ref)) {\n      continue;\n    }\n    refDedupe.add(ref);\n    lines.push(`R: ${ref}`);\n  }\n  const compacted = compactValue(redacted);\n\n  if (compacted === null || compacted === undefined) {\n    return formatContextDoc(lines);\n  }\n\n  if (typeof compacted !== 'object') {\n    lines.push(`N: result: ${asString(compacted)}`);\n    return formatContextDoc(lines);\n  }\n\n  if (Array.isArray(compacted)) {\n    lines.push(`N: result: array (${compacted.length})`);\n    lines.push('');\n    lines.push('Preview:');\n    for (const item of compacted.slice(0, 10)) {\n      lines.push(`- ${asString(item)}`);\n    }\n    return formatContextDoc(lines);\n  }\n\n  const keys = Object.keys(compacted);\n  lines.push(`N: result: object (keys: ${keys.slice(0, 12).join(', ')}${keys.length > 12 ? ', ...' : ''})`);\n  return formatContextDoc(lines);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "formatGenericResultToContext",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 491,
          "qualified_name": "formatGenericResultToContext",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1508,
        "end_line": 1515,
        "content": "function normalizeToolForOpenAI(tool) {\n  const normalized = normalizeJsonSchemaForOpenAI(tool.inputSchema);\n  const minimized = stripToolSemanticFields(normalized);\n  return {\n    ...tool,\n    inputSchema: minimized,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeToolForOpenAI",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 56,
          "qualified_name": "normalizeToolForOpenAI",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1518,
        "end_line": 1533,
        "content": "constructor() {\n    this.server = new Server(\n      {\n        name: 'sentryfrogg',\n        version: '6.4.0',\n      },\n      {\n        capabilities: {\n          tools: { list: true, call: true },\n        },\n        protocolVersion: '2025-06-18',\n      }\n    );\n    this.container = null;\n    this.initialized = false;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 84,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1535,
        "end_line": 1546,
        "content": "async initialize() {\n    try {\n      this.container = await ServiceBootstrap.initialize();\n      await this.setupHandlers();\n      this.initialized = true;\n      const logger = this.container.get('logger');\n      logger.info('SentryFrogg MCP Server v6.4.0 ready');\n    } catch (error) {\n      process.stderr.write(`Failed to initialize SentryFrogg MCP Server: ${error.message}\\n`);\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 106,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1548,
        "end_line": 1721,
        "content": "async setupHandlers() {\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      const tier = resolveToolTier();\n      const visible = filterToolCatalogForTier(toolCatalog, tier);\n      return { tools: visible.map(normalizeToolForOpenAI) };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n      const toolExecutor = this.container.get('toolExecutor');\n\n      try {\n        assertToolArgsValid(name, args);\n        let result;\n        let payload;\n        const startedAt = Date.now();\n        switch (name) {\n          case 'help': {\n            const traceId = args?.trace_id || crypto.randomUUID();\n            const spanId = args?.span_id || crypto.randomUUID();\n            const parentSpanId = args?.parent_span_id;\n            result = this.handleHelp(args);\n            payload = await toolExecutor.wrapResult({\n              tool: name,\n              args,\n              result,\n              startedAt,\n              traceId,\n              spanId,\n              parentSpanId,\n            });\n            break;\n          }\n          case 'legend': {\n            const traceId = args?.trace_id || crypto.randomUUID();\n            const spanId = args?.span_id || crypto.randomUUID();\n            const parentSpanId = args?.parent_span_id;\n            result = this.handleLegend(args);\n            payload = await toolExecutor.wrapResult({\n              tool: name,\n              args,\n              result,\n              startedAt,\n              traceId,\n              spanId,\n              parentSpanId,\n            });\n            break;\n          }\n          default:\n            payload = await toolExecutor.execute(name, args);\n            break;\n        }\n\n        const meta = (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'meta'))\n          ? payload.meta\n          : undefined;\n\n        const toolResult = (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'result'))\n          ? payload.result\n          : payload;\n\n        const contextRoot = resolveContextRepoRoot();\n        const artifact = contextRoot\n          ? buildArtifactRef({ traceId: meta?.trace_id, spanId: meta?.span_id })\n          : null;\n\n        let artifactWriteError;\n        let artifactPath;\n        let text;\n        let contentMarker = false;\n\n        const toolName = meta?.tool || name;\n        const actionName = meta?.action || args?.action;\n\n        if (toolName === 'help') {\n          if (\n            toolResult &&\n            typeof toolResult === 'object' &&\n            toolResult.name === 'legend' &&\n            toolResult.common_fields &&\n            toolResult.resolution\n          ) {\n            text = formatLegendResultToContext(toolResult);\n          } else {\n            text = formatHelpResultToContext(toolResult);\n          }\n        } else if (toolName === 'legend') {\n          text = formatLegendResultToContext(toolResult);\n        } else {\n          text = formatGenericResultToContext({\n            tool: toolName,\n            action: actionName,\n            result: toolResult,\n            meta,\n            artifactUri: artifact?.uri,\n          });\n        }\n\n        if (artifact && contextRoot) {\n          try {\n            artifactPath = await writeContextArtifact(contextRoot, artifact, text);\n          } catch (error) {\n            artifactWriteError = error?.message || String(error);\n          }\n\n          if (artifactWriteError) {\n            if (toolName === 'help') {\n              text = `${text}N: artifact_write_failed: ${artifactWriteError}\\n`;\n            } else if (toolName === 'legend') {\n              text = `${text}N: artifact_write_failed: ${artifactWriteError}\\n`;\n            } else {\n              text = formatGenericResultToContext({\n                tool: toolName,\n                action: actionName,\n                result: toolResult,\n                meta,\n                artifactUri: artifact.uri,\n                artifactWriteError,\n              });\n            }\n          }\n\n          if (text.includes('[CONTENT]\\\\n')) {\n            contentMarker = true;\n            text = text.replace('[CONTENT]\\\\n', '[DATA]\\\\n');\n          }\n\n          if (artifactPath) {\n            if (!text.includes(`R: ${artifact.uri}`)) {\n              if (text.includes('[CONTENT]\\\\n')) {\n                text = text.replace('[CONTENT]\\\\n', `[CONTENT]\\\\nR: ${artifact.uri}\\\\n`);\n              } else {\n                text = text.replace('[DATA]\\n', `[DATA]\\nR: ${artifact.uri}\\n`);\n              }\n            }\n            if (!text.includes(`N: artifact_path:`)) {\n              text = `${text}N: artifact_path: ${artifactPath}\\n`;\n            }\n          }\n        }\n\n        if (contentMarker) {\n          text = text.replace('[DATA]\\\\n', '[CONTENT]\\\\n');\n        }\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text,\n            },\n          ],\n        };\n      } catch (error) {\n        const logger = this.container?.get('logger');\n        logger?.error('Tool execution failed', {\n          tool: name,\n          action: args?.action,\n          error: error.message,\n        });\n\n        if (error instanceof McpError) {\n          throw error;\n        }\n\n        if (ToolError.isToolError(error)) {\n          throw mapToolErrorToMcpError(name, error);\n        }\n\n        throw new McpError(ErrorCode.InternalError, `–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è ${name}: ${error.message}`);\n      }\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 1402,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1723,
        "end_line": 1726,
        "content": "async handlePostgreSQL(args) {\n    this.ensureInitialized();\n    return this.container.get('postgresqlManager').handleAction(args);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 37,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1728,
        "end_line": 1731,
        "content": "async handleSSH(args) {\n    this.ensureInitialized();\n    return this.container.get('sshManager').handleAction(args);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 34,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1733,
        "end_line": 1736,
        "content": "async handleAPI(args) {\n    this.ensureInitialized();\n    return this.container.get('apiManager').handleAction(args);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 34,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1738,
        "end_line": 1862,
        "content": "buildLegendPayload() {\n    const aliases = Object.fromEntries(\n      Object.entries(HELP_TOOL_ALIASES).filter(([, toolName]) => Boolean(toolByName[toolName]))\n    );\n\n    return {\n      name: 'legend',\n      description: '–ö–∞–Ω–æ–Ω–∏—á–Ω–∞—è —Å–µ–º–∞–Ω—Ç–∏–∫–∞ SentryFrogg MCP: –æ–±—â–∏–µ –ø–æ–ª—è, –ø–æ—Ä—è–¥–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã.',\n      mental_model: [\n        '–î—É–º–∞–π—Ç–µ –æ SentryFrogg –∫–∞–∫ –æ ¬´–Ω–∞–±–æ—Ä–µ –∞–¥–∞–ø—Ç–µ—Ä–æ–≤ + –ø–∞–º—è—Ç—å¬ª: –≤—ã –≤—ã–∑—ã–≤–∞–µ—Ç–µ tool+action –∏ –ø–æ–ª—É—á–∞–µ—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ `output` –∏/–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —á–µ—Ä–µ–∑ `store_as`).',\n        \"–û—Å–Ω–æ–≤–Ω–∞—è UX-–æ—Å—å: –æ–¥–∏–Ω —Ä–∞–∑ —Å–≤—è–∑–∞—Ç—å `project`+`target` —Å –ø—Ä–æ—Ñ–∏–ª—è–º–∏ ‚Üí –¥–∞–ª—å—à–µ –≤—ã–∑—ã–≤–∞—Ç—å `ssh`/`env`/`psql`/`api` —Ç–æ–ª—å–∫–æ —Å `target`.\",\n      ],\n      response: {\n        shape: '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç ¬´—Å–∞–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç¬ª (–ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è `output`). –û—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∫–∞–∫ MCP error.',\n        tracing: '–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è (`trace_id`/`span_id`/`parent_span_id`) –ø–∏—à–µ—Ç—Å—è –≤ audit log –∏ –ª–æ–≥–∏ (stderr). –î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `mcp_audit`.',\n      },\n      common_fields: {\n        action: {\n          meaning: '–û–ø–µ—Ä–∞—Ü–∏—è –≤–Ω—É—Ç—Ä–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞. –ü–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ (—Å–º. `help({tool})` —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å enum).',\n          example: { tool: 'mcp_ssh_manager', action: 'exec' },\n        },\n        output: {\n          meaning: '–§–æ—Ä–º–∏—Ä—É–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (–∏ —Ç–æ, —á—Ç–æ –ø–æ–ø–∞–¥—ë—Ç –≤ `store_as`).',\n          pipeline: '`path` ‚Üí `pick` ‚Üí `omit` ‚Üí `map`',\n          path_syntax: [\n            'Dot/bracket: `rows[0].id`, `entries[0].trace_id`',\n            '–ß–∏—Å–ª–∞ –≤ `[]` —Å—á–∏—Ç–∞—é—Ç—Å—è –∏–Ω–¥–µ–∫—Å–∞–º–∏ –º–∞—Å—Å–∏–≤–∞.',\n          ],\n          missing: {\n            default: '`error` (–±—Ä–æ—Å–∞–µ—Ç –æ—à–∏–±–∫—É)',\n            modes: [\n              '`error` ‚Üí –æ—à–∏–±–∫–∞, –µ—Å–ª–∏ `path` –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ `map` –æ–∂–∏–¥–∞–µ—Ç –º–∞—Å—Å–∏–≤',\n              '`null` ‚Üí –≤–µ—Ä–Ω—É—Ç—å `null`',\n              '`undefined` ‚Üí –≤–µ—Ä–Ω—É—Ç—å `undefined`',\n              '`empty` ‚Üí –≤–µ—Ä–Ω—É—Ç—å ¬´–ø—É—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ¬ª (–æ–±—ã—á–Ω–æ `{}`; –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `map` ‚Äî `[]`)',\n            ],\n          },\n          default: {\n            meaning: '–ï—Å–ª–∏ `missing` –Ω–µ `error`, –º–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å —è–≤–Ω—ã–π `default` (–æ–Ω —Ç–∞–∫–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ `map`).',\n          },\n        },\n        store_as: {\n          meaning: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ `mcp_state`.',\n          forms: [\n            '`store_as: \\\"key\\\"` + (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) `store_scope: \\\"session\\\"|\\\"persistent\\\"`',\n            '`store_as: { key: \\\"key\\\", scope: \\\"session\\\"|\\\"persistent\\\" }`',\n          ],\n          note: '`session` ‚Äî –¥–µ—Ñ–æ–ª—Ç, –µ—Å–ª–∏ scope –Ω–µ —É–∫–∞–∑–∞–Ω.',\n        },\n        preset: {\n          meaning: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π preset –¥–æ –º–µ—Ä–¥–∂–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –°–∏–Ω–æ–Ω–∏–º—ã: `preset` –∏ `preset_name`.',\n          merge_order: [\n            '1) preset.data (–ø–æ –∏–º–µ–Ω–∏)',\n            '2) alias.args (–µ—Å–ª–∏ –≤—ã–∑–≤–∞–ª–∏ –∞–ª–∏–∞—Å)',\n            '3) arguments –≤—ã–∑–æ–≤–∞ (–ø–æ–±–µ–∂–¥–∞—é—Ç)',\n          ],\n        },\n        tracing: {\n          meaning: '–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –≤—ã–∑–æ–≤–æ–≤ –¥–ª—è –ª–æ–≥–æ–≤/–∞—É–¥–∏—Ç–∞/—Ç—Ä–∞—Å—Å. –ú–æ–∂–Ω–æ –ø—Ä–æ–∫–∏–¥—ã–≤–∞—Ç—å —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑.',\n          fields: ['`trace_id`', '`span_id`', '`parent_span_id`'],\n        },\n      },\n      resolution: {\n        tool_aliases: aliases,\n        tool_resolution_order: [\n          '–¢–æ—á–Ω–æ–µ –∏–º—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `mcp_ssh_manager`).',\n          '–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∞–ª–∏–∞—Å—ã (`ssh`, `psql`, `api`, ‚Ä¶).',\n          '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∞–ª–∏–∞—Å—ã –∏–∑ `mcp_alias` (–º–æ–≥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å args/preset).',\n        ],\n        project: {\n          meaning: '–ò–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞–±–æ—Ä target-–æ–≤, –∫–∞–∂–¥—ã–π target —Å–≤—è–∑—ã–≤–∞–µ—Ç –ø—Ä–æ—Ñ–∏–ª–∏/–ø—É—Ç–∏/URL.',\n          resolved_from: ['`project` –∏–ª–∏ `project_name` –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö', 'active project –∏–∑ state (`project.active`)'],\n        },\n        target: {\n          meaning: '–û–∫—Ä—É–∂–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ project (–Ω–∞–ø—Ä–∏–º–µ—Ä, `prod`, `stage`).',\n          synonyms: ['`target`', '`project_target`', '`environment`'],\n          selection: [\n            '—è–≤–Ω–æ —á–µ—Ä–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç—ã (synonyms)',\n            '–∏–Ω–∞—á–µ `project.default_target`',\n            '–∏–Ω–∞—á–µ auto-pick –µ—Å–ª–∏ target —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω',\n            '–∏–Ω–∞—á–µ –æ—à–∏–±–∫–∞ (–∫–æ–≥–¥–∞ target-–æ–≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ)',\n          ],\n        },\n        profile_resolution: {\n          meaning: '–ö–∞–∫ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è `profile_name`, –µ—Å–ª–∏ –≤—ã –µ–≥–æ –Ω–µ —É–∫–∞–∑–∞–ª–∏.',\n          order: [\n            '–µ—Å–ª–∏ –µ—Å—Ç—å inline `connection` ‚Üí –æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é',\n            '–∏–Ω–∞—á–µ `profile_name` (—è–≤–Ω–æ)',\n            '–∏–Ω–∞—á–µ binding –∏–∑ `project.target.*_profile` (–µ—Å–ª–∏ project/target —Ä–µ–∑–æ–ª–≤—è—Ç—Å—è)',\n            '–∏–Ω–∞—á–µ auto-pick –µ—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞',\n            '–∏–Ω–∞—á–µ –æ—à–∏–±–∫–∞',\n          ],\n        },\n      },\n      refs: {\n        env: {\n          scheme: '`ref:env:VAR_NAME`',\n          meaning: '–ü–æ–¥—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è (–¥–ª—è —Å–µ–∫—Ä–µ—Ç–æ–≤/–ø–∞—Ä–æ–ª–µ–π/–∫–ª—é—á–µ–π).',\n        },\n        vault: {\n          scheme: '`ref:vault:...` (–Ω–∞–ø—Ä–∏–º–µ—Ä, `ref:vault:kv2:secret/app/prod#TOKEN`)',\n          meaning: '–ü–æ–¥—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ HashiCorp Vault (KV v2). –¢—Ä–µ–±—É–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ `vault_profile`.',\n        },\n      },\n      safety: {\n        secret_export: {\n          meaning: '–î–∞–∂–µ –µ—Å–ª–∏ –µ—Å—Ç—å `include_secrets: true`, —ç–∫—Å–ø–æ—Ä—Ç —Å–µ–∫—Ä–µ—Ç–æ–≤ –∏–∑ –ø—Ä–æ—Ñ–∏–ª–µ–π –≤–∫–ª—é—á–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ break-glass —Ñ–ª–∞–≥–æ–º –æ–∫—Ä—É–∂–µ–Ω–∏—è.',\n          gates: ['`SENTRYFROGG_ALLOW_SECRET_EXPORT=1`', '`SF_ALLOW_SECRET_EXPORT=1`'],\n        },\n        intent_apply: {\n          meaning: 'Intent —Å write/mixed effects —Ç—Ä–µ–±—É–µ—Ç `apply: true` (–∏–Ω–∞—á–µ –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞).',\n        },\n        unsafe_local: {\n          meaning: '`mcp_local` –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤–∫–ª—é—á—ë–Ω–Ω–æ–º unsafe —Ä–µ–∂–∏–º–µ; –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –æ–Ω —Å–∫—Ä—ã—Ç –∏–∑ `tools/list`.',\n          gate: '`SENTRYFROGG_UNSAFE_LOCAL=1`',\n        },\n      },\n      golden_path: [\n        '1) `help()` ‚Üí —É–≤–∏–¥–µ—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã.',\n        '2) `legend()` ‚Üí –ø–æ–Ω—è—Ç—å —Å–µ–º–∞–Ω—Ç–∏–∫—É –æ–±—â–∏—Ö –ø–æ–ª–µ–π –∏ resolution.',\n        '3) (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) `mcp_project.project_upsert` + `mcp_project.project_use` ‚Üí —Å–≤—è–∑–∞—Ç—å project/target —Å –ø—Ä–æ—Ñ–∏–ª—è–º–∏.',\n        '4) –î–∞–ª—å—à–µ —Ä–∞–±–æ—Ç–∞—Ç—å —á–µ—Ä–µ–∑ `ssh`/`env`/`psql`/`api` —Å `target` –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏.',\n      ],\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 1864,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 1864,
        "end_line": 2244,
        "content": "handleHelp(args = {}) {\n    this.ensureInitialized();\n    const rawTool = args.tool ? String(args.tool).trim().toLowerCase() : '';\n    const rawAction = args.action ? String(args.action).trim() : '';\n\n    const tool = rawTool ? (HELP_TOOL_ALIASES[rawTool] || rawTool) : '';\n    const action = rawAction || '';\n    const tier = resolveToolTier();\n\n    const extractActions = (toolName) => {\n      const schema = toolByName[toolName]?.inputSchema;\n      const actionEnum = schema?.properties?.action?.enum;\n      return Array.isArray(actionEnum) ? actionEnum.slice() : [];\n    };\n\n    const extractFields = (toolName) => {\n      const schema = toolByName[toolName]?.inputSchema;\n      const props = schema?.properties || {};\n      const ignored = new Set([\n        'action',\n        'output',\n        'store_as',\n        'store_scope',\n        'trace_id',\n        'span_id',\n        'parent_span_id',\n        'preset',\n        'preset_name',\n      ]);\n      return Object.keys(props).filter((key) => !ignored.has(key));\n    };\n\n    const buildExample = (toolName, actionName) => {\n      if (!toolName || !actionName) {\n        return null;\n      }\n\n      if (toolName === 'mcp_ssh_manager') {\n\t        switch (actionName) {\n\t          case 'profile_upsert':\n\t            return {\n\t              action: 'profile_upsert',\n\t              profile_name: 'my-ssh',\n\t              connection: { host: 'example.com', port: 22, username: 'root', private_key_path: '~/.ssh/id_ed25519', host_key_policy: 'tofu' },\n\t            };\n          case 'authorized_keys_add':\n            return {\n              action: 'authorized_keys_add',\n              target: 'prod',\n              public_key_path: '~/.ssh/id_ed25519.pub',\n            };\n          case 'exec':\n            return {\n              action: 'exec',\n              target: 'prod',\n              command: 'uname -a',\n            };\n          case 'exec_detached':\n            return {\n              action: 'exec_detached',\n              target: 'prod',\n              command: 'sleep 60 && echo done',\n              log_path: '/tmp/sentryfrogg-detached.log',\n            };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_project') {\n        switch (actionName) {\n          case 'project_upsert':\n            return {\n              action: 'project_upsert',\n              name: 'myapp',\n              project: {\n                default_target: 'prod',\n                targets: {\n                  prod: {\n                    ssh_profile: 'myapp-prod-ssh',\n                    env_profile: 'myapp-prod-env',\n                    postgres_profile: 'myapp-prod-db',\n                    api_profile: 'myapp-prod-api',\n                    cwd: '/opt/myapp',\n                    env_path: '/opt/myapp/.env',\n                  },\n                },\n              },\n            };\n          case 'project_use':\n            return { action: 'project_use', name: 'myapp', scope: 'persistent' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_context') {\n        switch (actionName) {\n          case 'summary':\n            return { action: 'summary', project: 'myapp', target: 'prod' };\n          case 'refresh':\n            return { action: 'refresh', cwd: '/srv/myapp' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_workspace') {\n        switch (actionName) {\n          case 'summary':\n            return { action: 'summary', project: 'myapp', target: 'prod' };\n          case 'diagnose':\n            return { action: 'diagnose' };\n          case 'run':\n            return { action: 'run', intent_type: 'k8s.diff', inputs: { overlay: '/repo/overlays/prod' } };\n          case 'cleanup':\n            return { action: 'cleanup' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_env') {\n        switch (actionName) {\n          case 'profile_upsert':\n            return {\n              action: 'profile_upsert',\n              profile_name: 'myapp-prod-env',\n              secrets: { DATABASE_URL: 'ref:vault:kv2:secret/myapp/prod#DATABASE_URL' },\n            };\n          case 'write_remote':\n            return { action: 'write_remote', target: 'prod', overwrite: false, backup: true };\n          case 'run_remote':\n            return { action: 'run_remote', target: 'prod', command: 'printenv | head' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_vault') {\n        switch (actionName) {\n          case 'profile_upsert':\n            return {\n              action: 'profile_upsert',\n              profile_name: 'corp-vault',\n              addr: 'https://vault.example.com',\n              namespace: 'team-a',\n              auth_type: 'approle',\n              role_id: '<role_id>',\n              secret_id: '<secret_id>',\n            };\n          case 'profile_test':\n            return { action: 'profile_test', profile_name: 'corp-vault' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_psql_manager') {\n        switch (actionName) {\n          case 'query':\n            return { action: 'query', target: 'prod', sql: 'SELECT 1' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_api_client') {\n        switch (actionName) {\n          case 'request':\n            return { action: 'request', target: 'prod', method: 'GET', url: '/health' };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      if (toolName === 'mcp_repo') {\n        switch (actionName) {\n          case 'repo_info':\n            return { action: 'repo_info', repo_root: '/repo' };\n          case 'assert_clean':\n            return { action: 'assert_clean', repo_root: '/repo' };\n          case 'exec':\n            return { action: 'exec', repo_root: '/repo', command: 'git', args: ['status', '--short'] };\n          case 'apply_patch':\n            return { action: 'apply_patch', repo_root: '/repo', apply: true, patch: 'diff --git a/file b/file\\n...' };\n          case 'git_commit':\n            return { action: 'git_commit', repo_root: '/repo', apply: true, message: 'chore(gitops): update manifests' };\n          case 'git_revert':\n            return { action: 'git_revert', repo_root: '/repo', apply: true, sha: 'HEAD' };\n          case 'git_push':\n            return { action: 'git_push', repo_root: '/repo', apply: true, remote: 'origin', branch: 'sf/gitops/update-123' };\n          default:\n            return { action: actionName, repo_root: '/repo' };\n        }\n      }\n\n      if (toolName === 'mcp_intent') {\n        switch (actionName) {\n          case 'compile':\n            return { action: 'compile', intent: { type: 'k8s.diff', inputs: { overlay: '/repo/overlay' } } };\n          case 'execute':\n            return { action: 'execute', apply: true, intent: { type: 'k8s.apply', inputs: { overlay: '/repo/overlay' } } };\n          default:\n            return { action: actionName };\n        }\n      }\n\n      return { action: actionName };\n    };\n\n    const summaries = {\n      help: {\n        description: '–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø—Ä–∞–≤–∫—É. –ü–µ—Ä–µ–¥–∞–π—Ç–µ `tool`, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É.',\n        usage: \"call_tool ‚Üí name: 'help', arguments: { tool?: string, action?: string }\",\n      },\n      legend: {\n        description: '–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –ª–µ–≥–µ–Ω–¥–∞: –æ–±—â–∏–µ –ø–æ–ª—è, –ø–æ—Ä—è–¥–æ–∫ resolution, safety-–≥–µ–π—Ç—ã –∏ golden path.',\n        usage: \"call_tool ‚Üí name: 'legend' (–∏–ª–∏ help({ tool: 'legend' }))\",\n      },\n      mcp_psql_manager: {\n        description: 'PostgreSQL: –ø—Ä–æ—Ñ–∏–ª–∏, –∑–∞–ø—Ä–æ—Å—ã, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, CRUD, select/count/exists/export + bulk insert.',\n        usage: \"profile_upsert/profile_list ‚Üí query/batch/transaction ‚Üí insert/insert_bulk/update/delete/select/count/exists/export\",\n      },\n      mcp_ssh_manager: {\n        description: 'SSH: –ø—Ä–æ—Ñ–∏–ª–∏, exec/batch, –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ SFTP.',\n        usage: \"profile_upsert/profile_list ‚Üí (optional) authorized_keys_add ‚Üí exec/exec_detached/batch/system_info/check_host/sftp_*\",\n      },\n      mcp_api_client: {\n        description: 'HTTP: –ø—Ä–æ—Ñ–∏–ª–∏, request/paginate/download, retry/backoff, auth providers + cache.',\n        usage: \"profile_upsert/profile_list ‚Üí request/paginate/download/check\",\n      },\n      mcp_repo: {\n        description: 'Repo: –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ git/render/diff/patch –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ sandbox + allowlisted exec –±–µ–∑ shell.',\n        usage: 'repo_info/git_diff/render ‚Üí (apply=true) apply_patch/git_commit/git_revert/git_push ‚Üí exec',\n      },\n      mcp_state: {\n        description: 'State: –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏, –ø–æ–¥–¥–µ—Ä–∂–∫–∞ session/persistent.',\n        usage: 'set/get/list/unset/clear/dump',\n      },\n      mcp_project: {\n        description: 'Projects: –ø—Ä–æ—Ñ–∏–ª–∏, targets –∏ policy profiles –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤.',\n        usage: 'project_upsert/project_list ‚Üí project_use ‚Üí (targets + policy_profiles)',\n      },\n      mcp_context: {\n        description: 'Context: –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞ –∏ —Å–≤–æ–¥–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.',\n        usage: 'summary/get ‚Üí refresh ‚Üí list/stats',\n      },\n      mcp_workspace: {\n        description: 'Workspace: —Å–≤–æ–¥–∫–∞, –ø–æ–¥—Å–∫–∞–∑–∫–∏, –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞.',\n        usage: 'summary/suggest ‚Üí run ‚Üí cleanup ‚Üí diagnose ‚Üí store_status',\n      },\n      mcp_jobs: {\n        description: 'Jobs: –µ–¥–∏–Ω—ã–π —Ä–µ–µ—Å—Ç—Ä async –∑–∞–¥–∞—á (status/wait/logs/cancel/list).',\n        usage: 'job_status/job_wait/job_logs_tail/job_cancel/job_forget/job_list',\n      },\n      mcp_artifacts: {\n        description: 'Artifacts: —á—Ç–µ–Ω–∏–µ –∏ –ª–∏—Å—Ç–∏–Ω–≥ artifact:// refs (bounded –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).',\n        usage: 'get/head/tail/list',\n      },\n      mcp_env: {\n        description: 'Env: –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ env-–±–∞–Ω–¥–ª—ã –∏ –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–ø–∏—Å—å/–∑–∞–ø—É—Å–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö –ø–æ SSH.',\n        usage: 'profile_upsert/profile_list ‚Üí write_remote/run_remote',\n      },\n      mcp_vault: {\n        description: 'Vault: –ø—Ä–æ—Ñ–∏–ª–∏ (addr/namespace + token –∏–ª–∏ AppRole) –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (KV v2).',\n        usage: 'profile_upsert/profile_list ‚Üí profile_test',\n      },\n      mcp_runbook: {\n        description: 'Runbooks: —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤, –ø–ª—é—Å DSL.',\n        usage: 'runbook_upsert/runbook_upsert_dsl/runbook_list ‚Üí runbook_run/runbook_run_dsl',\n      },\n      mcp_capability: {\n        description: 'Capabilities: —Ä–µ–µ—Å—Ç—Ä intent‚Üírunbook, –≥—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.',\n        usage: 'list/get/resolve ‚Üí set/delete ‚Üí graph/stats',\n      },\n      mcp_intent: {\n        description: 'Intent: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ capability-–ø–ª–∞–Ω–æ–≤ —Å dry-run –∏ evidence.',\n        usage: 'compile/explain ‚Üí dry_run ‚Üí execute (apply=true –¥–ª—è write/mixed)',\n      },\n      mcp_evidence: {\n        description: 'Evidence: –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö evidence-–±–∞–Ω–¥–ª–æ–≤.',\n        usage: 'list/get',\n      },\n      mcp_alias: {\n        description: 'Aliases: –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–º–µ–Ω–∞ –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.',\n        usage: 'alias_upsert/alias_list/alias_get/alias_delete',\n      },\n      mcp_preset: {\n        description: 'Presets: reusable –Ω–∞–±–æ—Ä—ã –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.',\n        usage: 'preset_upsert/preset_list/preset_get/preset_delete',\n      },\n      mcp_audit: {\n        description: 'Audit log: –ø—Ä–æ—Å–º–æ—Ç—Ä –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π.',\n        usage: 'audit_list/audit_tail/audit_stats/audit_clear',\n      },\n      mcp_pipeline: {\n        description: 'Pipelines: –ø–æ—Ç–æ–∫–æ–≤—ã–µ HTTP‚ÜîSFTP‚ÜîPostgreSQL —Å—Ü–µ–Ω–∞—Ä–∏–∏.',\n        usage: 'run/describe',\n      },\n    };\n\n    if (isUnsafeLocalEnabled()) {\n      summaries.mcp_local = {\n        description: 'Local (UNSAFE): –ª–æ–∫–∞–ª—å–Ω—ã–µ exec –∏ filesystem –æ–ø–µ—Ä–∞—Ü–∏–∏ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤–∫–ª—é—á—ë–Ω–Ω–æ–º unsafe —Ä–µ–∂–∏–º–µ).',\n        usage: 'exec/batch/fs_read/fs_write/fs_list/fs_stat/fs_mkdir/fs_rm',\n      };\n    }\n\n    if (tool) {\n      if (tool === 'legend') {\n        return this.buildLegendPayload();\n      }\n\n      if (!summaries[tool]) {\n        return {\n          error: `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: ${tool}`,\n          known_tools: Object.keys(summaries).sort(),\n          hint: \"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ: { tool: 'mcp_ssh_manager' } –∏–ª–∏ { tool: 'ssh' }\",\n        };\n      }\n\n      const actions = extractActions(tool);\n      const fields = extractFields(tool);\n      const entry = {\n        name: tool,\n        description: summaries[tool].description,\n        usage: summaries[tool].usage,\n        actions,\n        fields,\n        hint: action\n          ? `help({ tool: '${tool}', action: '${action}' })`\n          : `help({ tool: '${tool}', action: '<action>' })`,\n      };\n\n      if (action) {\n        if (actions.length > 0 && !actions.includes(action)) {\n          return {\n            ...entry,\n            error: `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π action –¥–ª—è ${tool}: ${action}`,\n            known_actions: actions,\n          };\n        }\n        return {\n          ...entry,\n          action,\n          example: buildExample(tool, action),\n        };\n      }\n\n      return {\n        ...entry,\n        legend_hint: \"–°–º. `legend()` –¥–ª—è —Å–µ–º–∞–Ω—Ç–∏–∫–∏ –æ–±—â–∏—Ö –ø–æ–ª–µ–π (`output`, `store_as`, `preset`, `project/target`).\",\n      };\n    }\n\n    const visibleSummaries = tier === 'core'\n      ? Object.fromEntries(Object.entries(summaries).filter(([key]) => CORE_TOOL_NAMES.has(key)))\n      : summaries;\n\n    const overview = tier === 'core'\n      ? 'SentryFrogg MCP (tool_tier=core): –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ workspace/jobs/artifacts (–∏ project –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ); –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Å–∫—Ä—ã—Ç—ã –∏–∑ tools/list, –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã –ø—Ä–∏ —è–≤–Ω–æ–º –≤—ã–∑–æ–≤–µ.'\n      : (isUnsafeLocalEnabled()\n        ? 'SentryFrogg MCP –ø–æ–¥–∫–ª—é—á–∞–µ—Ç PostgreSQL, SSH, HTTP, state, project, context, runbook, capability/intent/evidence, alias, preset, audit, pipeline –∏ (unsafe) local –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã.'\n        : 'SentryFrogg MCP –ø–æ–¥–∫–ª—é—á–∞–µ—Ç PostgreSQL, SSH, HTTP, state, project, context, runbook, capability/intent/evidence, alias, preset, audit –∏ pipeline –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã.');\n\n    return {\n      overview,\n      usage: \"help({ tool: 'mcp_ssh_manager' }) –∏–ª–∏ help({ tool: 'mcp_ssh_manager', action: 'exec' })\",\n      legend: {\n        hint: \"–í—Å—è —Å–µ–º–∞–Ω—Ç–∏–∫–∞ –æ–±—â–∏—Ö –ø–æ–ª–µ–π –∏ –ø—Ä–∞–≤–∏–ª resolution ‚Äî –≤ `legend()` (–∏–ª–∏ `help({ tool: 'legend' })`).\",\n        includes: ['common_fields', 'resolution', 'refs', 'safety', 'golden_path'],\n      },\n      tools: Object.entries(visibleSummaries).map(([key, value]) => ({\n        name: key,\n        description: value.description,\n        usage: value.usage,\n        actions: extractActions(key),\n      })),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 3859,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 2246,
        "end_line": 2250,
        "content": "ensureInitialized() {\n    if (!this.initialized) {\n      throw new Error('SentryFrogg MCP Server not initialized');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 35,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 2252,
        "end_line": 2255,
        "content": "handleLegend(args = {}) {\n    this.ensureInitialized();\n    return this.buildLegendPayload();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 28,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 2257,
        "end_line": 2279,
        "content": "async run() {\n    await this.initialize();\n\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    const cleanup = async () => {\n      try {\n        await ServiceBootstrap.cleanup();\n        process.exit(0);\n      } catch (error) {\n        process.stderr.write(`Cleanup failed: ${error.message}\\n`);\n        process.exit(1);\n      }\n    };\n\n    process.on('SIGINT', cleanup);\n    process.on('SIGTERM', cleanup);\n    process.on('uncaughtException', (error) => {\n      process.stderr.write(`Uncaught exception: ${error.message}\\n`);\n      cleanup();\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 154,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "sentryfrogg_server.ts",
        "start_line": 2281,
        "end_line": 2291,
        "content": "getStats() {\n    if (!this.initialized) {\n      return { error: 'Server not initialized' };\n    }\n\n    return {\n      version: '6.4.0',\n      architecture: 'lightweight-service-layer',\n      ...ServiceBootstrap.getStats(),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SentryFroggServer",
          "estimated_tokens": 62,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/bootstrap/ServiceBootstrap.ts": [
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 10,
        "end_line": 13,
        "content": "constructor() {\n    this.services = new Map();\n    this.singletons = new Map();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceContainer",
          "estimated_tokens": 24,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 16,
        "end_line": 22,
        "content": "register(name, factory, options = {}) {\n    this.services.set(name, {\n      factory,\n      singleton: options.singleton || false,\n      dependencies: options.dependencies || []\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceContainer",
          "estimated_tokens": 61,
          "qualified_name": null,
          "documentation": "  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 25,
        "end_line": 47,
        "content": "get(name) {\n    if (!this.services.has(name)) {\n      throw new Error(`Service '${name}' not found`);\n    }\n\n    const service = this.services.get(name);\n    \n    // –ï—Å–ª–∏ singleton –∏ —É–∂–µ —Å–æ–∑–¥–∞–Ω\n    if (service.singleton && this.singletons.has(name)) {\n      return this.singletons.get(name);\n    }\n\n    // –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞\n    const dependencies = service.dependencies.map(dep => this.get(dep));\n    const instance = service.factory(...dependencies);\n\n    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ singleton\n    if (service.singleton) {\n      this.singletons.set(name, instance);\n    }\n\n    return instance;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceContainer",
          "estimated_tokens": 170,
          "qualified_name": null,
          "documentation": "  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 50,
        "end_line": 52,
        "content": "has(name) {\n    return this.services.has(name);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceContainer",
          "estimated_tokens": 31,
          "qualified_name": null,
          "documentation": "  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 55,
        "end_line": 61,
        "content": "getStats() {\n    return {\n      registered: this.services.size,\n      singletons: this.singletons.size,\n      services: Array.from(this.services.keys())\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceContainer",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": "  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 65,
        "end_line": 65,
        "content": "static container = null",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Variable",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 9,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 66,
        "end_line": 66,
        "content": "static initialized = false",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Variable",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 10,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 68,
        "end_line": 162,
        "content": "static async initialize() {\n    if (this.initialized) {\n      return this.container;\n    }\n\n    try {\n      this.container = new ServiceContainer();\n      \n      // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –±–∞–∑–æ–≤—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤\n      await this.registerBaseServices();\n      \n      // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤\n      await this.registerManagers();\n\n      // –ü—Ä–æ–≥—Ä–µ–≤–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –≥–æ–Ω–æ–∫ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—Ä–æ—Å–µ\n      if (this.container.has('profileService')) {\n        const profileService = this.container.get('profileService');\n        await profileService.initialize();\n      }\n      if (this.container.has('stateService')) {\n        const stateService = this.container.get('stateService');\n        await stateService.initialize();\n      }\n      if (this.container.has('projectService')) {\n        const projectService = this.container.get('projectService');\n        await projectService.initialize();\n      }\n      if (this.container.has('runbookService')) {\n        const runbookService = this.container.get('runbookService');\n        await runbookService.initialize();\n      }\n      if (this.container.has('contextService')) {\n        const contextService = this.container.get('contextService');\n        await contextService.initialize();\n      }\n      if (this.container.has('capabilityService')) {\n        const capabilityService = this.container.get('capabilityService');\n        await capabilityService.initialize();\n      }\n      if (this.container.has('aliasService')) {\n        const aliasService = this.container.get('aliasService');\n        await aliasService.initialize();\n      }\n      if (this.container.has('presetService')) {\n        const presetService = this.container.get('presetService');\n        await presetService.initialize();\n      }\n\n      if (this.container.has('toolExecutor') && this.container.has('runbookManager')) {\n        const toolExecutor = this.container.get('toolExecutor');\n        const runbookManager = this.container.get('runbookManager');\n        toolExecutor.register('mcp_runbook', (args) => runbookManager.handleAction(args));\n      }\n\n      if (this.container.has('toolExecutor') && this.container.has('intentManager')) {\n        const toolExecutor = this.container.get('toolExecutor');\n        const intentManager = this.container.get('intentManager');\n        toolExecutor.register('mcp_intent', (args) => intentManager.handleAction(args));\n        toolExecutor.aliasMap.intent = 'mcp_intent';\n      }\n\n      if (this.container.has('toolExecutor') && this.container.has('workspaceManager')) {\n        const toolExecutor = this.container.get('toolExecutor');\n        const workspaceManager = this.container.get('workspaceManager');\n        toolExecutor.register('mcp_workspace', (args) => workspaceManager.handleAction(args));\n        toolExecutor.aliasMap.workspace = 'mcp_workspace';\n      }\n\n      if (this.container.has('toolExecutor') && this.container.has('localManager')) {\n        const toolExecutor = this.container.get('toolExecutor');\n        const localManager = this.container.get('localManager');\n        toolExecutor.register('mcp_local', (args) => localManager.handleAction(args));\n        toolExecutor.aliasMap.local = 'mcp_local';\n      }\n\n      this.initialized = true;\n\n      if (this.container.has('logger')) {\n        const logger = this.container.get('logger');\n        logger.info('Service Layer initialized successfully');\n      } else {\n        process.stdout.write('‚úÖ Service Layer initialized successfully\\n');\n      }\n      return this.container;\n      \n    } catch (error) {\n      if (this.container && this.container.has('logger')) {\n        const logger = this.container.get('logger');\n        logger.error('Service Layer initialization failed', { error: error.message });\n      } else {\n        process.stderr.write(`‚ùå Service Layer initialization failed: ${error.message}\\n`);\n      }\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 1001,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 164,
        "end_line": 354,
        "content": "static async registerBaseServices() {\n    const Logger = require('../services/Logger');\n    const Security = require('../services/Security');\n    const Validation = require('../services/Validation');\n    const ProfileService = require('../services/ProfileService');\n    const VaultClient = require('../services/VaultClient');\n    const SecretRefResolver = require('../services/SecretRefResolver');\n    const StateService = require('../services/StateService');\n    const ProjectService = require('../services/ProjectService');\n    const ProjectResolver = require('../services/ProjectResolver');\n    const RunbookService = require('../services/RunbookService');\n    const ContextService = require('../services/ContextService');\n    const ContextSessionService = require('../services/ContextSessionService');\n    const CapabilityService = require('../services/CapabilityService');\n    const EvidenceService = require('../services/EvidenceService');\n    const AliasService = require('../services/AliasService');\n    const PresetService = require('../services/PresetService');\n    const AuditService = require('../services/AuditService');\n    const CacheService = require('../services/CacheService');\n    const WorkspaceService = require('../services/WorkspaceService');\n    const PolicyService = require('../services/PolicyService');\n    const JobService = require('../services/JobService');\n\n    // Logger (–±–∞–∑–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å)\n    this.container.register('logger', () => {\n      const logger = new Logger('sentryfrogg');\n      return logger;\n    }, { singleton: true });\n\n    // Security —Å–µ—Ä–≤–∏—Å\n    this.container.register('security', (logger) => new Security(logger), { \n      singleton: true,\n      dependencies: ['logger'] \n    });\n\n    // Job service (unified async registry)\n    this.container.register('jobService', (logger) => new JobService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Validation —Å–µ—Ä–≤–∏—Å\n    this.container.register('validation', (logger) => new Validation(logger), { \n      singleton: true,\n      dependencies: ['logger'] \n    });\n\n    // Profile —Å–µ—Ä–≤–∏—Å\n    this.container.register('profileService', (logger, security) => \n      new ProfileService(logger, security), { \n      singleton: true,\n      dependencies: ['logger', 'security'] \n    });\n\n    // Vault client (KV v2)\n    this.container.register('vaultClient', (logger, validation, profileService) =>\n      new VaultClient(logger, validation, profileService), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'profileService'],\n    });\n\n    // State —Å–µ—Ä–≤–∏—Å\n    this.container.register('stateService', (logger) =>\n      new StateService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Project —Å–µ—Ä–≤–∏—Å\n    this.container.register('projectService', (logger) =>\n      new ProjectService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Project resolver (project/target ‚Üí –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤—ã–∑–æ–≤–∞)\n    this.container.register('projectResolver', (validation, projectService, stateService) =>\n      new ProjectResolver(validation, projectService, stateService), {\n      singleton: true,\n      dependencies: ['validation', 'projectService', 'stateService'],\n    });\n\n    // SecretRef resolver (Vault/ENV refs)\n    this.container.register('secretRefResolver', (logger, validation, profileService, vaultClient, projectResolver) =>\n      new SecretRefResolver(logger, validation, profileService, vaultClient, projectResolver), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'profileService', 'vaultClient', 'projectResolver'],\n    });\n\n    // Runbook —Å–µ—Ä–≤–∏—Å\n    this.container.register('runbookService', (logger) =>\n      new RunbookService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Context —Å–µ—Ä–≤–∏—Å\n    this.container.register('contextService', (logger, projectResolver) =>\n      new ContextService(logger, projectResolver), {\n      singleton: true,\n      dependencies: ['logger', 'projectResolver'],\n    });\n\n    // ContextSession —Å–µ—Ä–≤–∏—Å\n    this.container.register('contextSessionService', (logger, contextService, projectResolver, profileService) =>\n      new ContextSessionService(logger, contextService, projectResolver, profileService), {\n      singleton: true,\n      dependencies: ['logger', 'contextService', 'projectResolver', 'profileService'],\n    });\n\n    // Policy service (GitOps hardening)\n    this.container.register('policyService', (logger, validation, stateService) =>\n      new PolicyService(logger, validation, stateService), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'stateService'],\n    });\n\n    // Capability —Å–µ—Ä–≤–∏—Å\n    this.container.register('capabilityService', (logger, security) =>\n      new CapabilityService(logger, security), {\n      singleton: true,\n      dependencies: ['logger', 'security'],\n    });\n\n    // Evidence —Å–µ—Ä–≤–∏—Å\n    this.container.register('evidenceService', (logger, security) =>\n      new EvidenceService(logger, security), {\n      singleton: true,\n      dependencies: ['logger', 'security'],\n    });\n\n    // Alias —Å–µ—Ä–≤–∏—Å\n    this.container.register('aliasService', (logger) =>\n      new AliasService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Preset —Å–µ—Ä–≤–∏—Å\n    this.container.register('presetService', (logger) =>\n      new PresetService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Audit —Å–µ—Ä–≤–∏—Å\n    this.container.register('auditService', (logger) =>\n      new AuditService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Cache —Å–µ—Ä–≤–∏—Å\n    this.container.register('cacheService', (logger) =>\n      new CacheService(logger), {\n      singleton: true,\n      dependencies: ['logger'],\n    });\n\n    // Workspace —Å–µ—Ä–≤–∏—Å\n    this.container.register('workspaceService',\n      (logger, contextService, contextSessionService, projectResolver, profileService, runbookService, capabilityService, projectService, aliasService, presetService, stateService) =>\n        new WorkspaceService(\n          logger,\n          contextService,\n          contextSessionService,\n          projectResolver,\n          profileService,\n          runbookService,\n          capabilityService,\n          projectService,\n          aliasService,\n          presetService,\n          stateService\n        ), {\n      singleton: true,\n      dependencies: [\n        'logger',\n        'contextService',\n        'contextSessionService',\n        'projectResolver',\n        'profileService',\n        'runbookService',\n        'capabilityService',\n        'projectService',\n        'aliasService',\n        'presetService',\n        'stateService',\n      ],\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 1721,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 356,
        "end_line": 631,
        "content": "static async registerManagers() {\n    const PostgreSQLManager = require('../managers/PostgreSQLManager');\n    const SSHManager = require('../managers/SSHManager');\n    const APIManager = require('../managers/APIManager');\n    const LocalManager = require('../managers/LocalManager');\n    const RepoManager = require('../managers/RepoManager');\n    const ArtifactManager = require('../managers/ArtifactManager');\n    const StateManager = require('../managers/StateManager');\n    const ProjectManager = require('../managers/ProjectManager');\n    const EnvManager = require('../managers/EnvManager');\n    const VaultManager = require('../managers/VaultManager');\n    const RunbookManager = require('../managers/RunbookManager');\n    const ContextManager = require('../managers/ContextManager');\n    const CapabilityManager = require('../managers/CapabilityManager');\n    const IntentManager = require('../managers/IntentManager');\n    const EvidenceManager = require('../managers/EvidenceManager');\n    const AliasManager = require('../managers/AliasManager');\n    const PresetManager = require('../managers/PresetManager');\n    const AuditManager = require('../managers/AuditManager');\n    const PipelineManager = require('../managers/PipelineManager');\n    const WorkspaceManager = require('../managers/WorkspaceManager');\n    const JobManager = require('../managers/JobManager');\n    const ToolExecutor = require('../services/ToolExecutor');\n    const { isUnsafeLocalEnabled } = require('../utils/featureFlags');\n\n    // PostgreSQL Manager\n    this.container.register('postgresqlManager', \n      (logger, validation, profileService, projectResolver, secretRefResolver) => \n        new PostgreSQLManager(logger, validation, profileService, projectResolver, secretRefResolver), { \n      singleton: true,\n      dependencies: ['logger', 'validation', 'profileService', 'projectResolver', 'secretRefResolver'] \n    });\n\n    // SSH Manager\n    this.container.register('sshManager', \n      (logger, security, validation, profileService, projectResolver, secretRefResolver, jobService) => \n        new SSHManager(logger, security, validation, profileService, projectResolver, secretRefResolver, jobService), { \n      singleton: true,\n      dependencies: ['logger', 'security', 'validation', 'profileService', 'projectResolver', 'secretRefResolver', 'jobService'] \n    });\n\n    // Job Manager (unified job API)\n    this.container.register('jobManager',\n      (logger, validation, jobService, sshManager) =>\n        new JobManager(logger, validation, jobService, { sshManager }), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'jobService', 'sshManager'],\n    });\n\n    // API Manager\n    this.container.register('apiManager', \n      (logger, security, validation, profileService, cacheService, projectResolver, secretRefResolver) => \n        new APIManager(logger, security, validation, profileService, cacheService, { projectResolver, secretRefResolver }), { \n      singleton: true,\n      dependencies: ['logger', 'security', 'validation', 'profileService', 'cacheService', 'projectResolver', 'secretRefResolver'] \n    });\n\n    if (isUnsafeLocalEnabled()) {\n      this.container.register('localManager',\n        (logger, validation) =>\n          new LocalManager(logger, validation, { enabled: true }), {\n        singleton: true,\n        dependencies: ['logger', 'validation'],\n      });\n    }\n\n    // Repo Manager (safe-by-default)\n    this.container.register('repoManager',\n      (logger, security, validation, projectResolver, policyService) =>\n        new RepoManager(logger, security, validation, projectResolver, policyService), {\n      singleton: true,\n      dependencies: ['logger', 'security', 'validation', 'projectResolver', 'policyService'],\n    });\n\n    // Artifact Manager\n    this.container.register('artifactManager',\n      (logger, validation) =>\n        new ArtifactManager(logger, validation), {\n      singleton: true,\n      dependencies: ['logger', 'validation'],\n    });\n\n    // State Manager\n    this.container.register('stateManager',\n      (logger, stateService) =>\n        new StateManager(logger, stateService), {\n      singleton: true,\n      dependencies: ['logger', 'stateService'],\n    });\n\n    // Project Manager\n    this.container.register('projectManager',\n      (logger, validation, projectService, stateService) =>\n        new ProjectManager(logger, validation, projectService, stateService), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'projectService', 'stateService'],\n    });\n\n    // Env Manager\n    this.container.register('envManager',\n      (logger, validation, profileService, sshManager, projectResolver, secretRefResolver) =>\n        new EnvManager(logger, validation, profileService, sshManager, projectResolver, secretRefResolver), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'profileService', 'sshManager', 'projectResolver', 'secretRefResolver'],\n    });\n\n    // Vault Manager\n    this.container.register('vaultManager',\n      (logger, validation, profileService, vaultClient) =>\n        new VaultManager(logger, validation, profileService, vaultClient), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'profileService', 'vaultClient'],\n    });\n\n    // Context Manager\n    this.container.register('contextManager',\n      (logger, validation, contextService) =>\n        new ContextManager(logger, validation, contextService), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'contextService'],\n    });\n\n    // Capability Manager\n    this.container.register('capabilityManager',\n      (logger, security, validation, capabilityService, contextService) =>\n        new CapabilityManager(logger, security, validation, capabilityService, contextService), {\n      singleton: true,\n      dependencies: ['logger', 'security', 'validation', 'capabilityService', 'contextService'],\n    });\n\n    // Evidence Manager\n    this.container.register('evidenceManager',\n      (logger, security, validation, evidenceService) =>\n        new EvidenceManager(logger, security, validation, evidenceService), {\n      singleton: true,\n      dependencies: ['logger', 'security', 'validation', 'evidenceService'],\n    });\n\n    // Tool executor\n    this.container.register('toolExecutor',\n      (logger, stateService, aliasService, presetService, auditService, postgresqlManager, sshManager, jobManager, apiManager, repoManager, artifactManager, stateManager, projectManager, envManager, vaultManager, contextManager, capabilityManager, evidenceManager, aliasManager, presetManager, auditManager, pipelineManager) =>\n        new ToolExecutor(logger, stateService, aliasService, presetService, auditService, {\n          mcp_psql_manager: (args) => postgresqlManager.handleAction(args),\n          mcp_ssh_manager: (args) => sshManager.handleAction(args),\n          mcp_jobs: (args) => jobManager.handleAction(args),\n          mcp_api_client: (args) => apiManager.handleAction(args),\n          mcp_repo: (args) => repoManager.handleAction(args),\n          mcp_artifacts: (args) => artifactManager.handleAction(args),\n          mcp_state: (args) => stateManager.handleAction(args),\n          mcp_project: (args) => projectManager.handleAction(args),\n          mcp_env: (args) => envManager.handleAction(args),\n          mcp_vault: (args) => vaultManager.handleAction(args),\n          mcp_context: (args) => contextManager.handleAction(args),\n          mcp_capability: (args) => capabilityManager.handleAction(args),\n          mcp_evidence: (args) => evidenceManager.handleAction(args),\n          mcp_alias: (args) => aliasManager.handleAction(args),\n          mcp_preset: (args) => presetManager.handleAction(args),\n          mcp_audit: (args) => auditManager.handleAction(args),\n          mcp_pipeline: (args) => pipelineManager.handleAction(args),\n        }, {\n          aliasMap: {\n            sql: 'mcp_psql_manager',\n            psql: 'mcp_psql_manager',\n            ssh: 'mcp_ssh_manager',\n            job: 'mcp_jobs',\n            http: 'mcp_api_client',\n            api: 'mcp_api_client',\n            repo: 'mcp_repo',\n            artifacts: 'mcp_artifacts',\n            state: 'mcp_state',\n            project: 'mcp_project',\n            env: 'mcp_env',\n            vault: 'mcp_vault',\n            context: 'mcp_context',\n            capability: 'mcp_capability',\n            evidence: 'mcp_evidence',\n            runbook: 'mcp_runbook',\n            alias: 'mcp_alias',\n            preset: 'mcp_preset',\n            audit: 'mcp_audit',\n            pipeline: 'mcp_pipeline',\n          },\n        }), {\n      singleton: true,\n      dependencies: [\n        'logger',\n        'stateService',\n        'aliasService',\n        'presetService',\n        'auditService',\n        'postgresqlManager',\n        'sshManager',\n        'jobManager',\n        'apiManager',\n        'repoManager',\n        'artifactManager',\n        'stateManager',\n        'projectManager',\n        'envManager',\n        'vaultManager',\n        'contextManager',\n        'capabilityManager',\n        'evidenceManager',\n        'aliasManager',\n        'presetManager',\n        'auditManager',\n        'pipelineManager',\n      ],\n    });\n\n    // Runbook Manager\n    this.container.register('runbookManager',\n      (logger, runbookService, stateService, toolExecutor) =>\n        new RunbookManager(logger, runbookService, stateService, toolExecutor), {\n      singleton: true,\n      dependencies: ['logger', 'runbookService', 'stateService', 'toolExecutor'],\n    });\n\n    // Intent Manager\n    this.container.register('intentManager',\n      (logger, security, validation, capabilityService, runbookManager, evidenceService, projectResolver, contextService, policyService) =>\n        new IntentManager(logger, security, validation, capabilityService, runbookManager, evidenceService, projectResolver, contextService, policyService), {\n      singleton: true,\n      dependencies: [\n        'logger',\n        'security',\n        'validation',\n        'capabilityService',\n        'runbookManager',\n        'evidenceService',\n        'projectResolver',\n        'contextService',\n        'policyService',\n      ],\n    });\n\n    // Workspace Manager\n    this.container.register('workspaceManager',\n      (logger, validation, workspaceService, runbookManager, intentManager, sshManager) =>\n        new WorkspaceManager(logger, validation, workspaceService, runbookManager, intentManager, sshManager), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'workspaceService', 'runbookManager', 'intentManager', 'sshManager'],\n    });\n\n    // Alias Manager\n    this.container.register('aliasManager',\n      (logger, aliasService) =>\n        new AliasManager(logger, aliasService), {\n      singleton: true,\n      dependencies: ['logger', 'aliasService'],\n    });\n\n    // Preset Manager\n    this.container.register('presetManager',\n      (logger, presetService) =>\n        new PresetManager(logger, presetService), {\n      singleton: true,\n      dependencies: ['logger', 'presetService'],\n    });\n\n    // Audit Manager\n    this.container.register('auditManager',\n      (logger, auditService) =>\n        new AuditManager(logger, auditService), {\n      singleton: true,\n      dependencies: ['logger', 'auditService'],\n    });\n\n    // Pipeline Manager\n    this.container.register('pipelineManager',\n      (logger, validation, apiManager, sshManager, postgresqlManager, cacheService, auditService, projectResolver) =>\n        new PipelineManager(logger, validation, apiManager, sshManager, postgresqlManager, cacheService, auditService, projectResolver), {\n      singleton: true,\n      dependencies: ['logger', 'validation', 'apiManager', 'sshManager', 'postgresqlManager', 'cacheService', 'auditService', 'projectResolver'],\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 2961,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 633,
        "end_line": 657,
        "content": "static async cleanup() {\n    if (!this.initialized) {\n      return;\n    }\n\n    try {\n      // Cleanup –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤\n      for (const [name, instance] of this.container.singletons) {\n        if (instance && typeof instance.cleanup === 'function') {\n          await instance.cleanup();\n        }\n      }\n\n      this.container.services.clear();\n      this.container.singletons.clear();\n      this.container = null;\n      this.initialized = false;\n      \n      process.stdout.write('‚úÖ Service Layer cleanup completed\\n');\n      \n    } catch (error) {\n      process.stderr.write(`‚ùå Service Layer cleanup failed: ${error.message}\\n`);\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 172,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/bootstrap/ServiceBootstrap.ts",
        "start_line": 659,
        "end_line": 668,
        "content": "static getStats() {\n    if (!this.initialized) {\n      return { error: 'Service Layer not initialized' };\n    }\n\n    return {\n      initialized: this.initialized,\n      ...this.container.getStats()\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ServiceBootstrap",
          "estimated_tokens": 56,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/constants/Constants.ts": [
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 7,
        "end_line": 26,
        "content": "static get NETWORK() {\n    return {\n      POSTGRES_DEFAULT_PORT: 5432,\n      SSH_DEFAULT_PORT: 22,\n      TIMEOUT_SSH_READY: 10000,       // 10 —Å–µ–∫—É–Ω–¥\n      // NOTE: MCP tool calls are often subject to an external ~60s deadline.\n      // Keep any single tool execution below this budget unless explicitly detached.\n      TIMEOUT_MCP_TOOL_CALL: 55000,   // 55 —Å–µ–∫—É–Ω–¥\n      TIMEOUT_SSH_EXEC_DEFAULT: 45000, // 45 —Å–µ–∫—É–Ω–¥\n      TIMEOUT_SSH_EXEC_HARD_GRACE: 2000, // 2 —Å–µ–∫—É–Ω–¥—ã (force-settle timeout)\n      TIMEOUT_SSH_DETACHED_START: 20000, // 20 —Å–µ–∫—É–Ω–¥ (start-only wrapper)\n      TIMEOUT_API_REQUEST: 30000,     // 30 —Å–µ–∫—É–Ω–¥\n      TIMEOUT_MUTEX: 30000,           // 30 —Å–µ–∫—É–Ω–¥\n      TIMEOUT_CONNECTION: 5000,       // 5 —Å–µ–∫—É–Ω–¥\n      TIMEOUT_IDLE: 300000,           // 5 –º–∏–Ω—É—Ç\n      KEEPALIVE_INTERVAL: 30000,      // 30 —Å–µ–∫—É–Ω–¥\n      CLEANUP_INTERVAL: 300000,       // 5 –º–∏–Ω—É—Ç\n      DANGEROUS_PORTS: [22, 23, 25, 53, 135, 139, 445, 593, 636, 993, 995]\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 266,
          "qualified_name": null,
          "documentation": "  // –°–µ—Ç–µ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 29,
        "end_line": 38,
        "content": "static get LIMITS() {\n    return {\n      MAX_CONNECTIONS: 10,\n      MAX_PORT: 65535,\n      MIN_PORT: 1,\n      SAMPLE_DATA_LIMIT: 10,\n      LOG_SUBSTRING_LENGTH: 100,\n      COMMAND_SUBSTRING_LENGTH: 50\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 62,
          "qualified_name": null,
          "documentation": "  // –õ–∏–º–∏—Ç—ã –∏ —Ä–∞–∑–º–µ—Ä—ã",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 41,
        "end_line": 51,
        "content": "static get TIMEOUTS() {\n    return {\n      BUFFER_FLUSH: 5000,             // 5 —Å–µ–∫—É–Ω–¥\n      RATE_LIMIT_WINDOW: 60000,       // 1 –º–∏–Ω—É—Ç–∞\n      STATISTICS_WINDOW: 3600000,     // 1 —á–∞—Å\n      STATISTICS_MINUTE: 60000,       // 1 –º–∏–Ω—É—Ç–∞\n      CLEANUP_OLD_LOGS: 10000,        // 10 —Å–µ–∫—É–Ω–¥\n      CONNECTION_TIMEOUT: 2000,       // 2 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\n      IDLE_TIMEOUT: 30000             // 30 —Å–µ–∫—É–Ω–¥ –ø—Ä–æ—Å—Ç–æ—è\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 132,
          "qualified_name": null,
          "documentation": "  // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 54,
        "end_line": 62,
        "content": "static get RETRY() {\n    return {\n      MAX_ATTEMPTS: 3,\n      BASE_DELAY_MS: 250,\n      MAX_DELAY_MS: 5000,\n      JITTER: 0.2,\n      STATUS_CODES: [408, 429, 500, 502, 503, 504]\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": "  // Retry defaults (HTTP)",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 65,
        "end_line": 70,
        "content": "static get PAGINATION() {\n    return {\n      MAX_PAGES: 10,\n      PAGE_SIZE: 100\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 30,
          "qualified_name": null,
          "documentation": "  // Pagination defaults",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 73,
        "end_line": 77,
        "content": "static get CACHE() {\n    return {\n      DEFAULT_TTL_MS: 60000\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 24,
          "qualified_name": null,
          "documentation": "  // Cache defaults",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 80,
        "end_line": 91,
        "content": "static get BUFFERS() {\n    return {\n      LOG_BUFFER_SIZE: 100,\n      SLIDING_WINDOW_SIZE: 1000,\n      MAX_LOG_SIZE: 10 * 1024 * 1024, // 10MB\n      MAX_LOG_FILES: 10,\n      CRYPTO_KEY_SIZE: 32,\n      CRYPTO_IV_SIZE: 12,\n      CRYPTO_TAG_SIZE: 16,\n      CRYPTO_SALT_SIZE: 32\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 84,
          "qualified_name": null,
          "documentation": "  // –†–∞–∑–º–µ—Ä—ã –±—É—Ñ–µ—Ä–æ–≤ –∏ –æ–∫–æ–Ω",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 94,
        "end_line": 101,
        "content": "static get CRYPTO() {\n    return {\n      ALGORITHM: 'aes-256-gcm',\n      PBKDF2_ITERATIONS: 100000,\n      HASH_LENGTH: 64,\n      HASH_ALGORITHM: 'sha512'\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": "  // –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 104,
        "end_line": 110,
        "content": "static get RATE_LIMIT() {\n    return {\n      WINDOW_MS: 60000,               // 1 –º–∏–Ω—É—Ç–∞\n      MAX_REQUESTS: 100,              // –º–∞–∫—Å–∏–º—É–º –∑–∞–ø—Ä–æ—Å–æ–≤\n      CLEANUP_INTERVAL: 300000        // 5 –º–∏–Ω—É—Ç\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": "  // Rate limiting",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 113,
        "end_line": 122,
        "content": "static get LOCALHOST() {\n    return {\n      NAMES: ['localhost', '127.0.0.1'],\n      PRIVATE_RANGES: [\n        '192.168.',\n        '10.',\n        /^172\\.(1[6-9]|2\\d|3[01])\\./\n      ]\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": "  // Localhost –∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ IP",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/constants/Constants.ts",
        "start_line": 125,
        "end_line": 129,
        "content": "static get PROTOCOLS() {\n    return {\n      ALLOWED_HTTP: ['http:', 'https:']\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Constants",
          "estimated_tokens": 29,
          "qualified_name": null,
          "documentation": "  // –ü—Ä–æ—Ç–æ–∫–æ–ª—ã",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/errors/ToolError.ts": [
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 15,
        "end_line": 29,
        "content": "constructor({ kind, code, message, hint, details, retryable } = {}) {\n    const safeKind = typeof kind === 'string' ? kind : 'internal';\n    const safeCode = typeof code === 'string' && code.trim().length ? code.trim() : 'INTERNAL';\n    const safeMessage = typeof message === 'string' && message.trim().length\n      ? message.trim()\n      : safeCode;\n\n    super(safeMessage);\n    this.name = 'ToolError';\n    this.kind = VALID_KINDS.has(safeKind) ? safeKind : 'internal';\n    this.code = safeCode;\n    this.hint = typeof hint === 'string' && hint.trim().length ? hint.trim() : undefined;\n    this.details = details && typeof details === 'object' && !Array.isArray(details) ? details : undefined;\n    this.retryable = Boolean(retryable);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 187,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 31,
        "end_line": 41,
        "content": "toJSON() {\n    return {\n      name: this.name,\n      kind: this.kind,\n      code: this.code,\n      message: this.message,\n      hint: this.hint,\n      details: this.details,\n      retryable: this.retryable,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 56,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 43,
        "end_line": 45,
        "content": "static isToolError(error) {\n    return Boolean(error && typeof error === 'object' && error.name === 'ToolError' && typeof error.kind === 'string');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 47,
        "end_line": 69,
        "content": "static invalidParams({ message, field, expected, received, hint, details } = {}) {\n    const payload = {\n      ...(details && typeof details === 'object' && !Array.isArray(details) ? details : {}),\n    };\n    if (field !== undefined) {\n      payload.field = field;\n    }\n    if (expected !== undefined) {\n      payload.expected = expected;\n    }\n    if (received !== undefined) {\n      payload.received = received;\n    }\n\n    return new ToolError({\n      kind: 'invalid_params',\n      code: 'INVALID_PARAMS',\n      message: message || 'Invalid parameters',\n      hint,\n      details: Object.keys(payload).length ? payload : undefined,\n      retryable: false,\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 169,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 71,
        "end_line": 80,
        "content": "static denied({ code, message, hint, details, retryable } = {}) {\n    return new ToolError({\n      kind: 'denied',\n      code: code || 'DENIED',\n      message: message || 'Request denied',\n      hint,\n      details,\n      retryable: Boolean(retryable),\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 82,
        "end_line": 91,
        "content": "static notFound({ code, message, hint, details, retryable } = {}) {\n    return new ToolError({\n      kind: 'not_found',\n      code: code || 'NOT_FOUND',\n      message: message || 'Not found',\n      hint,\n      details,\n      retryable: Boolean(retryable),\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 93,
        "end_line": 102,
        "content": "static conflict({ code, message, hint, details, retryable } = {}) {\n    return new ToolError({\n      kind: 'conflict',\n      code: code || 'CONFLICT',\n      message: message || 'Conflict',\n      hint,\n      details,\n      retryable: Boolean(retryable),\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 104,
        "end_line": 113,
        "content": "static timeout({ code, message, hint, details } = {}) {\n    return new ToolError({\n      kind: 'timeout',\n      code: code || 'TIMEOUT',\n      message: message || 'Timed out',\n      hint,\n      details,\n      retryable: true,\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 61,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 115,
        "end_line": 124,
        "content": "static retryable({ code, message, hint, details } = {}) {\n    return new ToolError({\n      kind: 'retryable',\n      code: code || 'RETRYABLE',\n      message: message || 'Retryable error',\n      hint,\n      details,\n      retryable: true,\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/errors/ToolError.ts",
        "start_line": 126,
        "end_line": 135,
        "content": "static internal({ code, message, hint, details, retryable } = {}) {\n    return new ToolError({\n      kind: 'internal',\n      code: code || 'INTERNAL',\n      message: message || 'Internal error',\n      hint,\n      details,\n      retryable: Boolean(retryable),\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolError",
          "estimated_tokens": 69,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/APIManager.ts": [
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 33,
        "end_line": 42,
        "content": "async function fetchFn(...args) {\n  if (typeof globalThis.fetch === 'function') {\n    return globalThis.fetch(...args);\n  }\n  if (!fetchPromise) {\n    fetchPromise = import('node-fetch').then((mod) => mod.default);\n  }\n  const fetch = await fetchPromise;\n  return fetch(...args);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "fetchFn",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 70,
          "qualified_name": "fetchFn",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 46,
        "end_line": 55,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return null;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 57,
        "end_line": 76,
        "content": "function resolveStreamToArtifactMode() {\n  const raw = process.env.SENTRYFROGG_API_STREAM_TO_ARTIFACT\n    || process.env.SF_API_STREAM_TO_ARTIFACT\n    || process.env.SENTRYFROGG_STREAM_TO_ARTIFACT\n    || process.env.SF_STREAM_TO_ARTIFACT;\n  if (raw === undefined || raw === null) {\n    return null;\n  }\n  const normalized = String(raw).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n  if (normalized === 'full') {\n    return 'full';\n  }\n  if (normalized === 'capped') {\n    return 'capped';\n  }\n  return isTruthy(normalized) ? 'capped' : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveStreamToArtifactMode",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 140,
          "qualified_name": "resolveStreamToArtifactMode",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 78,
        "end_line": 177,
        "content": "async function readResponseBodyBytes(response, maxCaptureBytes) {\n  const limit = Number.isFinite(maxCaptureBytes) && maxCaptureBytes > 0\n    ? maxCaptureBytes\n    : DEFAULT_MAX_CAPTURE_BYTES;\n\n  const body = response?.body;\n  if (body && typeof body[Symbol.asyncIterator] === 'function') {\n    const chunks = [];\n    let readBytes = 0;\n    let captured = 0;\n    let truncated = false;\n\n    try {\n      for await (const chunk of body) {\n        const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk ?? '');\n        readBytes += buf.length;\n\n        if (captured < limit) {\n          const remaining = limit - captured;\n          if (buf.length <= remaining) {\n            chunks.push(buf);\n            captured += buf.length;\n          } else {\n            chunks.push(buf.subarray(0, remaining));\n            captured += remaining;\n            truncated = true;\n          }\n        } else {\n          truncated = true;\n        }\n\n        if (captured >= limit) {\n          truncated = true;\n          if (typeof body.destroy === 'function') {\n            body.destroy();\n          }\n          break;\n        }\n      }\n    } catch (error) {\n      if (!truncated) {\n        throw error;\n      }\n    }\n\n    const buffer = captured ? Buffer.concat(chunks, captured) : Buffer.alloc(0);\n    return {\n      buffer,\n      body_read_bytes: readBytes,\n      body_captured_bytes: buffer.length,\n      body_truncated: truncated,\n    };\n  }\n\n  if (typeof response?.arrayBuffer === 'function') {\n    const full = Buffer.from(await response.arrayBuffer());\n    const truncated = full.length > limit;\n    const buffer = truncated ? full.subarray(0, limit) : full;\n    return {\n      buffer,\n      body_read_bytes: full.length,\n      body_captured_bytes: buffer.length,\n      body_truncated: truncated,\n    };\n  }\n\n  if (typeof response?.text === 'function') {\n    const text = await response.text();\n    const full = Buffer.from(text, 'utf8');\n    const truncated = full.length > limit;\n    const buffer = truncated ? full.subarray(0, limit) : full;\n    return {\n      buffer,\n      body_read_bytes: full.length,\n      body_captured_bytes: buffer.length,\n      body_truncated: truncated,\n    };\n  }\n\n  if (typeof response?.json === 'function') {\n    const payload = await response.json();\n    const text = typeof payload === 'string' ? payload : JSON.stringify(payload);\n    const full = Buffer.from(text, 'utf8');\n    const truncated = full.length > limit;\n    const buffer = truncated ? full.subarray(0, limit) : full;\n    return {\n      buffer,\n      body_read_bytes: full.length,\n      body_captured_bytes: buffer.length,\n      body_truncated: truncated,\n    };\n  }\n\n  return {\n    buffer: Buffer.alloc(0),\n    body_read_bytes: 0,\n    body_captured_bytes: 0,\n    body_truncated: false,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readResponseBodyBytes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 697,
          "qualified_name": "readResponseBodyBytes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 179,
        "end_line": 196,
        "content": "function parseRetryAfter(value) {\n  if (!value) {\n    return null;\n  }\n  const trimmed = String(value).trim();\n  if (!trimmed) {\n    return null;\n  }\n  const seconds = Number(trimmed);\n  if (Number.isFinite(seconds)) {\n    return Math.max(0, seconds * 1000);\n  }\n  const date = Date.parse(trimmed);\n  if (!Number.isNaN(date)) {\n    return Math.max(0, date - Date.now());\n  }\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseRetryAfter",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 97,
          "qualified_name": "parseRetryAfter",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 198,
        "end_line": 213,
        "content": "function parseLinkHeader(header) {\n  if (!header) {\n    return [];\n  }\n  return header\n    .split(',')\n    .map((part) => part.trim())\n    .map((part) => {\n      const match = part.match(/<([^>]+)>;\\s*rel=\"?([^\";]+)\"?/i);\n      if (!match) {\n        return null;\n      }\n      return { url: match[1], rel: match[2] };\n    })\n    .filter(Boolean);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseLinkHeader",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 87,
          "qualified_name": "parseLinkHeader",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 215,
        "end_line": 236,
        "content": "function toAuthObject(auth) {\n  if (auth === undefined || auth === null) {\n    return undefined;\n  }\n\n  if (typeof auth === 'string') {\n    const trimmed = auth.trim();\n    if (!trimmed) {\n      return undefined;\n    }\n    if (/^Bearer\\s+/i.test(trimmed) || /^Basic\\s+/i.test(trimmed)) {\n      return { type: 'raw', value: trimmed };\n    }\n    return { type: 'bearer', token: trimmed };\n  }\n\n  if (typeof auth === 'object') {\n    return { ...auth };\n  }\n\n  return undefined;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "toAuthObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 119,
          "qualified_name": "toAuthObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 239,
        "end_line": 256,
        "content": "constructor(logger, security, validation, profileService, cacheService, options = {}) {\n    this.logger = logger.child('api');\n    this.security = security;\n    this.validation = validation;\n    this.profileService = profileService;\n    this.cacheService = cacheService;\n    this.projectResolver = options.projectResolver;\n    this.secretRefResolver = options.secretRefResolver;\n    this.fetch = options.fetch ?? fetchFn;\n    this.tokenCache = new Map();\n    this.stats = {\n      requests: 0,\n      errors: 0,\n      retries: 0,\n      downloads: 0,\n      pages: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 145,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 258,
        "end_line": 266,
        "content": "resolveMaxCaptureBytes() {\n    const fromEnv = readPositiveInt(\n      process.env.SENTRYFROGG_API_MAX_CAPTURE_BYTES\n      || process.env.SF_API_MAX_CAPTURE_BYTES\n      || process.env.SENTRYFROGG_MAX_CAPTURE_BYTES\n      || process.env.SF_MAX_CAPTURE_BYTES\n    );\n    return fromEnv ?? DEFAULT_MAX_CAPTURE_BYTES;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 80,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 268,
        "end_line": 291,
        "content": "async handleAction(args) {\n    const { action } = args;\n\n    switch (action) {\n      case 'profile_upsert':\n        return this.profileUpsert(args.profile_name, args);\n      case 'profile_get':\n        return this.profileGet(args.profile_name, args.include_secrets);\n      case 'profile_list':\n        return this.profileList();\n      case 'profile_delete':\n        return this.profileDelete(args.profile_name);\n      case 'request':\n        return this.request(args);\n      case 'paginate':\n        return this.paginate(args);\n      case 'download':\n        return this.download(args);\n      case 'check':\n        return this.checkApi(args);\n      default:\n        throw new Error(`Unknown API action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 183,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 293,
        "end_line": 320,
        "content": "splitAuth(auth) {\n    const normalized = toAuthObject(auth);\n    if (!normalized) {\n      return { dataAuth: undefined, secrets: {} };\n    }\n\n    const dataAuth = { ...normalized };\n    const secrets = {};\n\n    if (dataAuth.token) {\n      secrets.auth_token = dataAuth.token;\n      delete dataAuth.token;\n    }\n    if (dataAuth.password) {\n      secrets.auth_password = dataAuth.password;\n      delete dataAuth.password;\n    }\n    if (dataAuth.header_value) {\n      secrets.auth_header_value = dataAuth.header_value;\n      delete dataAuth.header_value;\n    }\n    if (dataAuth.value) {\n      secrets.auth_value = dataAuth.value;\n      delete dataAuth.value;\n    }\n\n    return { dataAuth, secrets };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 177,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 322,
        "end_line": 355,
        "content": "mergeAuth(dataAuth, secrets) {\n    if (!dataAuth && (!secrets || Object.keys(secrets).length === 0)) {\n      return undefined;\n    }\n\n    const auth = { ...(dataAuth || {}) };\n\n    if (secrets?.auth_token) {\n      auth.token = secrets.auth_token;\n    }\n    if (secrets?.auth_password) {\n      auth.password = secrets.auth_password;\n    }\n    if (secrets?.auth_header_value) {\n      auth.header_value = secrets.auth_header_value;\n    }\n    if (secrets?.auth_value) {\n      auth.value = secrets.auth_value;\n    }\n\n    if (!auth.type) {\n      if (auth.value) {\n        auth.type = 'raw';\n      } else if (auth.token) {\n        auth.type = 'bearer';\n      } else if (auth.username && auth.password) {\n        auth.type = 'basic';\n      } else if (auth.header_name && auth.header_value) {\n        auth.type = 'header';\n      }\n    }\n\n    return auth;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 214,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 357,
        "end_line": 383,
        "content": "splitAuthProvider(provider) {\n    if (!provider) {\n      return { dataProvider: undefined, secrets: {} };\n    }\n    if (typeof provider !== 'object' || Array.isArray(provider)) {\n      throw new Error('auth_provider must be an object');\n    }\n\n    const dataProvider = { ...provider };\n    const secrets = {};\n\n    if (dataProvider.client_secret) {\n      secrets.auth_provider_client_secret = String(dataProvider.client_secret);\n      delete dataProvider.client_secret;\n    }\n    if (dataProvider.refresh_token) {\n      secrets.auth_provider_refresh_token = String(dataProvider.refresh_token);\n      delete dataProvider.refresh_token;\n    }\n    if (dataProvider.exec?.env) {\n      secrets.auth_provider_exec_env = JSON.stringify(dataProvider.exec.env);\n      dataProvider.exec = { ...dataProvider.exec };\n      delete dataProvider.exec.env;\n    }\n\n    return { dataProvider, secrets };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 224,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 385,
        "end_line": 408,
        "content": "mergeAuthProvider(dataProvider, secrets) {\n    if (!dataProvider && (!secrets || Object.keys(secrets).length === 0)) {\n      return undefined;\n    }\n\n    const provider = { ...(dataProvider || {}) };\n\n    if (secrets?.auth_provider_client_secret) {\n      provider.client_secret = secrets.auth_provider_client_secret;\n    }\n    if (secrets?.auth_provider_refresh_token) {\n      provider.refresh_token = secrets.auth_provider_refresh_token;\n    }\n    if (secrets?.auth_provider_exec_env) {\n      try {\n        const env = JSON.parse(secrets.auth_provider_exec_env);\n        provider.exec = { ...(provider.exec || {}), env };\n      } catch (error) {\n        provider.exec = { ...(provider.exec || {}) };\n      }\n    }\n\n    return provider;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 187,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 410,
        "end_line": 446,
        "content": "buildAuthHeaders(auth) {\n    if (!auth) {\n      return {};\n    }\n\n    const normalized = toAuthObject(auth);\n    if (!normalized || normalized.type === 'none') {\n      return {};\n    }\n\n    switch (normalized.type) {\n      case 'raw':\n        return normalized.value ? { Authorization: normalized.value } : {};\n      case 'bearer':\n        if (!normalized.token) {\n          return {};\n        }\n        return {\n          Authorization: normalized.token.startsWith('Bearer ')\n            ? normalized.token\n            : `Bearer ${normalized.token}`,\n        };\n      case 'basic': {\n        const username = normalized.username ?? '';\n        const password = normalized.password ?? '';\n        const encoded = Buffer.from(`${username}:${password}`).toString('base64');\n        return { Authorization: `Basic ${encoded}` };\n      }\n      case 'header':\n        if (!normalized.header_name || normalized.header_value === undefined) {\n          return {};\n        }\n        return { [normalized.header_name]: normalized.header_value };\n      default:\n        return {};\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 271,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 448,
        "end_line": 463,
        "content": "authFromToken(provider, token) {\n    const headerName = provider.header_name;\n    if (headerName) {\n      return { type: 'header', header_name: headerName, header_value: token };\n    }\n\n    const scheme = provider.scheme ? String(provider.scheme).toLowerCase() : undefined;\n    if (scheme === 'raw') {\n      return { type: 'raw', value: token };\n    }\n    if (scheme === 'basic') {\n      return { type: 'raw', value: token };\n    }\n\n    return { type: 'bearer', token };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 120,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 465,
        "end_line": 468,
        "content": "cacheKey(provider, profileName) {\n    const base = provider.cache_key || provider.token_url || provider.command || 'inline';\n    return `${profileName || 'inline'}:${base}`;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 470,
        "end_line": 480,
        "content": "getCachedToken(key) {\n    const entry = this.tokenCache.get(key);\n    if (!entry) {\n      return null;\n    }\n    if (entry.expiresAt && entry.expiresAt <= Date.now()) {\n      this.tokenCache.delete(key);\n      return null;\n    }\n    return entry.token;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 66,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 482,
        "end_line": 485,
        "content": "setCachedToken(key, token, ttlMs) {\n    const expiresAt = ttlMs ? Date.now() + ttlMs : null;\n    this.tokenCache.set(key, { token, expiresAt });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 487,
        "end_line": 615,
        "content": "async resolveAuthProvider(provider, profileName, args = {}) {\n    if (!provider) {\n      return undefined;\n    }\n\n    if (this.secretRefResolver) {\n      provider = await this.secretRefResolver.resolveDeep(provider, args);\n    }\n\n    let type = String(provider.type || '').toLowerCase();\n    if (!type) {\n      if (provider.command || provider.exec?.command) {\n        type = 'exec';\n      } else if (provider.token_url) {\n        type = 'oauth2';\n      }\n    }\n\n    if (type === 'static') {\n      if (provider.auth) {\n        return provider.auth;\n      }\n      if (provider.token) {\n        return { type: 'bearer', token: provider.token };\n      }\n    }\n\n    if (type === 'exec') {\n      const execConfig = provider.exec ? provider.exec : provider;\n      const command = execConfig.command;\n      if (!command) {\n        throw new Error('auth_provider.exec.command is required');\n      }\n      const args = Array.isArray(execConfig.args) ? execConfig.args : [];\n      const options = {\n        cwd: execConfig.cwd,\n        env: execConfig.env,\n        timeout: execConfig.timeout_ms,\n      };\n\n      const output = await execFileAsync(command, args, options);\n      const format = String(execConfig.format || 'raw').toLowerCase();\n\n      let token = (output.stdout || '').trim();\n      if (format === 'json') {\n        const parsed = JSON.parse(token || '{}');\n        const tokenPath = execConfig.token_path || provider.token_path || 'token';\n        token = getPathValue(parsed, tokenPath, { required: true });\n      }\n\n      if (!token) {\n        throw new Error('auth_provider.exec did not return a token');\n      }\n\n      return this.authFromToken(execConfig, token);\n    }\n\n    if (type === 'oauth2') {\n      const tokenUrl = provider.token_url;\n      const clientId = provider.client_id;\n      const clientSecret = provider.client_secret;\n\n      if (!tokenUrl || !clientId || !clientSecret) {\n        throw new Error('auth_provider.oauth2 requires token_url, client_id, client_secret');\n      }\n\n      const cacheKey = this.cacheKey(provider, profileName);\n      const cached = this.getCachedToken(cacheKey);\n      if (cached) {\n        return this.authFromToken(provider, cached);\n      }\n\n      const grantType = provider.grant_type || 'client_credentials';\n      const payload = new URLSearchParams();\n      payload.set('grant_type', grantType);\n      payload.set('client_id', clientId);\n      payload.set('client_secret', clientSecret);\n\n      if (provider.scope) {\n        payload.set('scope', provider.scope);\n      }\n      if (provider.audience) {\n        payload.set('audience', provider.audience);\n      }\n      if (grantType === 'refresh_token') {\n        const refreshToken = provider.refresh_token;\n        if (!refreshToken) {\n          throw new Error('auth_provider.oauth2.refresh_token is required for refresh_token grant');\n        }\n        payload.set('refresh_token', refreshToken);\n      }\n      if (provider.extra && typeof provider.extra === 'object') {\n        for (const [key, value] of Object.entries(provider.extra)) {\n          payload.set(key, String(value));\n        }\n      }\n\n      const response = await this.fetch(tokenUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          ...(provider.headers || {}),\n        },\n        body: payload.toString(),\n      });\n\n      if (!response.ok) {\n        const text = await response.text();\n        throw new Error(`OAuth2 token request failed (${response.status}): ${text}`);\n      }\n\n      const tokenPayload = await response.json();\n      const tokenPath = provider.token_path || 'access_token';\n      const token = getPathValue(tokenPayload, tokenPath, { required: true });\n      const expiresIn = Number(tokenPayload.expires_in || provider.expires_in);\n\n      if (token) {\n        const ttlMs = Number.isFinite(expiresIn) && expiresIn > 0 ? expiresIn * 1000 : null;\n        if (ttlMs) {\n          const bufferMs = provider.expiry_buffer_ms ? Number(provider.expiry_buffer_ms) : 30000;\n          this.setCachedToken(cacheKey, token, Math.max(0, ttlMs - bufferMs));\n        }\n      }\n\n      return this.authFromToken(provider, token);\n    }\n\n    return undefined;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 1057,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 617,
        "end_line": 643,
        "content": "async profileUpsert(profileName, params) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const base = params.base_url ? String(params.base_url) : undefined;\n    const headers = this.validation.ensureHeaders(params.headers);\n\n    const { dataAuth, secrets } = this.splitAuth(params.auth);\n    const { dataProvider, secrets: providerSecrets } = this.splitAuthProvider(params.auth_provider);\n\n    await this.profileService.setProfile(name, {\n      type: 'api',\n      data: {\n        base_url: base,\n        headers,\n        auth: dataAuth,\n        auth_provider: dataProvider,\n        retry: params.retry,\n        pagination: params.pagination,\n        cache: params.cache,\n        timeout_ms: params.timeout_ms,\n        response_type: params.response_type,\n        redirect: params.redirect,\n      },\n      secrets: { ...secrets, ...providerSecrets },\n    });\n\n    return { success: true, profile: { name, base_url: base } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 242,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 645,
        "end_line": 665,
        "content": "async profileGet(profileName, includeSecrets = false) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const profile = await this.profileService.getProfile(name, 'api');\n\n    const allow = isTruthy(process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT) || isTruthy(process.env.SF_ALLOW_SECRET_EXPORT);\n    if (includeSecrets && allow) {\n      return { success: true, profile };\n    }\n\n    const secretKeys = profile.secrets ? Object.keys(profile.secrets).sort() : [];\n    return {\n      success: true,\n      profile: {\n        name: profile.name,\n        type: profile.type,\n        data: profile.data,\n        secrets: secretKeys,\n        secrets_redacted: true,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 178,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 667,
        "end_line": 670,
        "content": "async profileList() {\n    const profiles = await this.profileService.listProfiles('api');\n    return { success: true, profiles };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 35,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 672,
        "end_line": 676,
        "content": "async profileDelete(profileName) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    await this.profileService.deleteProfile(name);\n    return { success: true, profile: name };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 678,
        "end_line": 685,
        "content": "buildHeaders(baseHeaders, authHeaders) {\n    return {\n      'User-Agent': 'sentryfrogg-api-client/6.4.0',\n      Accept: 'application/json, text/plain, */*',\n      ...baseHeaders,\n      ...authHeaders,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 687,
        "end_line": 715,
        "content": "prepareBody({ body, body_type, body_base64, form }) {\n    if (body_base64) {\n      return { body: Buffer.from(body_base64, 'base64'), contentType: 'application/octet-stream' };\n    }\n\n    if (form && typeof form === 'object') {\n      const params = new URLSearchParams();\n      for (const [key, value] of Object.entries(form)) {\n        params.append(key, String(value));\n      }\n      return { body: params.toString(), contentType: 'application/x-www-form-urlencoded' };\n    }\n\n    if (body === undefined) {\n      return { body: undefined, contentType: undefined };\n    }\n\n    const normalizedType = body_type ? String(body_type).toLowerCase() : undefined;\n\n    if (normalizedType === 'json' || (normalizedType === undefined && typeof body === 'object')) {\n      return { body: JSON.stringify(body), contentType: 'application/json' };\n    }\n\n    if (normalizedType === 'text' || typeof body === 'string') {\n      return { body: String(body), contentType: 'text/plain; charset=utf-8' };\n    }\n\n    return { body: String(body), contentType: 'text/plain; charset=utf-8' };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 270,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 717,
        "end_line": 740,
        "content": "buildUrl(baseUrl, path, query, explicitUrl) {\n    let url = explicitUrl;\n    if (!url) {\n      if (!baseUrl) {\n        throw new Error('base_url or url must be provided');\n      }\n      url = path ? new URL(path, baseUrl).toString() : baseUrl;\n    }\n\n    const parsed = this.security.ensureUrl(url);\n    if (query && typeof query === 'object') {\n      for (const [key, value] of Object.entries(query)) {\n        if (Array.isArray(value)) {\n          value.forEach((item) => parsed.searchParams.append(key, String(item)));\n        } else if (value !== undefined && value !== null) {\n          parsed.searchParams.set(key, String(value));\n        }\n      }\n    } else if (typeof query === 'string') {\n      parsed.search = query;\n    }\n\n    return parsed.toString();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 194,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 742,
        "end_line": 779,
        "content": "async resolveProfile(profileName, args = {}) {\n    if (!profileName && this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args).catch(() => null);\n      const apiProfile = context?.target?.api_profile;\n      if (apiProfile) {\n        profileName = this.validation.ensureString(String(apiProfile), 'profile_name');\n      }\n    }\n\n    if (!profileName) {\n      const profiles = await this.profileService.listProfiles('api');\n      if (profiles.length === 1) {\n        profileName = profiles[0].name;\n      } else {\n        return { name: undefined, data: {}, auth: undefined, authProvider: undefined, retry: undefined, pagination: undefined, secrets: {} };\n      }\n    }\n\n    const profile = await this.profileService.getProfile(profileName, 'api');\n    const data = profile.data || {};\n    let auth = this.mergeAuth(data.auth, profile.secrets || {});\n    let authProvider = this.mergeAuthProvider(data.auth_provider, profile.secrets || {});\n\n    if (this.secretRefResolver) {\n      auth = await this.secretRefResolver.resolveDeep(auth, args);\n      authProvider = await this.secretRefResolver.resolveDeep(authProvider, args);\n    }\n\n    return {\n      name: profileName,\n      data,\n      auth,\n      authProvider,\n      retry: data.retry,\n      pagination: data.pagination,\n      secrets: profile.secrets || {},\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 341,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 781,
        "end_line": 794,
        "content": "getDefaultRetryPolicy() {\n    return {\n      enabled: true,\n      max_attempts: Constants.RETRY?.MAX_ATTEMPTS ?? 3,\n      base_delay_ms: Constants.RETRY?.BASE_DELAY_MS ?? 250,\n      max_delay_ms: Constants.RETRY?.MAX_DELAY_MS ?? 5000,\n      jitter: Constants.RETRY?.JITTER ?? 0.2,\n      status_codes: Constants.RETRY?.STATUS_CODES ?? [408, 429, 500, 502, 503, 504],\n      methods: ['GET', 'HEAD', 'PUT', 'DELETE', 'OPTIONS'],\n      retry_on_network_error: true,\n      respect_retry_after: true,\n      backoff_factor: 2,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 796,
        "end_line": 821,
        "content": "normalizeRetryPolicy(requestPolicy, profilePolicy, method) {\n    const fallback = this.getDefaultRetryPolicy();\n    const merged = {\n      ...fallback,\n      ...(profilePolicy || {}),\n      ...(requestPolicy || {}),\n    };\n\n    if (merged.enabled === false) {\n      return { enabled: false };\n    }\n\n    const normalizedMethods = Array.isArray(merged.methods)\n      ? merged.methods.map((entry) => String(entry).toUpperCase())\n      : fallback.methods;\n\n    if (method && !normalizedMethods.includes(String(method).toUpperCase())) {\n      return { enabled: false };\n    }\n\n    return {\n      ...merged,\n      methods: normalizedMethods,\n      max_attempts: Number(merged.max_attempts) || fallback.max_attempts,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 182,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 823,
        "end_line": 845,
        "content": "normalizeCachePolicy(requestCache, profileCache) {\n    if (!requestCache && !profileCache) {\n      return { enabled: false };\n    }\n\n    if (requestCache === false) {\n      return { enabled: false };\n    }\n\n    const merged = {\n      enabled: true,\n      ttl_ms: Constants.CACHE?.DEFAULT_TTL_MS ?? 60000,\n      cache_errors: false,\n      ...(profileCache || {}),\n      ...(requestCache === true ? {} : (requestCache || {})),\n    };\n\n    if (merged.enabled === false) {\n      return { enabled: false };\n    }\n\n    return merged;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 847,
        "end_line": 858,
        "content": "buildCacheKey(args, config) {\n    if (!this.cacheService) {\n      return null;\n    }\n\n    return this.cacheService.buildKey({\n      url: config.url,\n      method: config.method,\n      headers: config.headers,\n      body: args.body ?? args.data ?? args.form ?? args.body_base64,\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 860,
        "end_line": 868,
        "content": "shouldRetryResponse(response, policy) {\n    if (!policy.enabled) {\n      return false;\n    }\n    if (!response) {\n      return false;\n    }\n    return Array.isArray(policy.status_codes) && policy.status_codes.includes(response.status);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 61,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 870,
        "end_line": 890,
        "content": "computeRetryDelay(attempt, policy, response) {\n    const base = Number(policy.base_delay_ms) || 0;\n    const factor = Number(policy.backoff_factor) || 2;\n    const maxDelay = Number(policy.max_delay_ms) || base;\n    const jitter = Number(policy.jitter) || 0;\n\n    let delay = Math.min(maxDelay, base * Math.pow(factor, Math.max(0, attempt - 1)));\n    if (jitter > 0) {\n      const delta = delay * jitter;\n      delay = delay - delta + Math.random() * delta * 2;\n    }\n\n    if (policy.respect_retry_after && response) {\n      const retryAfter = parseRetryAfter(response.headers?.['retry-after']);\n      if (retryAfter !== null && retryAfter > delay) {\n        delay = retryAfter;\n      }\n    }\n\n    return Math.max(0, Math.floor(delay));\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 187,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 892,
        "end_line": 949,
        "content": "buildRequestConfig(args, profile, auth, overrides = {}) {\n    const baseUrl = args.base_url ?? profile.data.base_url;\n    const mergedHeaders = {\n      ...(profile.data.headers || {}),\n      ...this.validation.ensureHeaders(args.headers),\n    };\n\n    const authHeaders = this.buildAuthHeaders(auth);\n    const finalHeaders = this.buildHeaders(mergedHeaders, authHeaders);\n\n    const { body, contentType } = this.prepareBody({\n      body: args.body ?? args.data,\n      body_type: args.body_type,\n      body_base64: args.body_base64,\n      form: args.form,\n    });\n\n    if (contentType && !finalHeaders['Content-Type'] && !finalHeaders['content-type']) {\n      finalHeaders['Content-Type'] = contentType;\n    }\n\n    const url = this.buildUrl(baseUrl, args.path, args.query, args.url);\n    const method = String(args.method || 'GET').toUpperCase();\n    const timeoutMs = args.timeout_ms ?? profile.data.timeout_ms ?? Constants.NETWORK.TIMEOUT_API_REQUEST;\n\n    const config = {\n      url,\n      method,\n      headers: finalHeaders,\n      body,\n      timeoutMs,\n      redirect: args.redirect ?? profile.data.redirect ?? 'follow',\n    };\n\n    if (overrides.headers) {\n      config.headers = { ...config.headers, ...overrides.headers };\n    }\n    if (overrides.url) {\n      config.url = overrides.url;\n    }\n    if (overrides.method) {\n      config.method = overrides.method;\n    }\n    if (overrides.body !== undefined) {\n      config.body = overrides.body;\n    }\n    if (overrides.timeoutMs !== undefined) {\n      config.timeoutMs = overrides.timeoutMs;\n    }\n    if (overrides.redirect) {\n      config.redirect = overrides.redirect;\n    }\n    if (overrides.duplex) {\n      config.duplex = overrides.duplex;\n    }\n\n    return config;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 435,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 951,
        "end_line": 1144,
        "content": "async requestOnce(args, profile, auth) {\n    const config = this.buildRequestConfig(args, profile, auth);\n    const controller = new AbortController();\n    const timeout = config.timeoutMs ? setTimeout(() => controller.abort(), config.timeoutMs) : null;\n    const started = Date.now();\n\n    try {\n      const response = await this.fetch(config.url, {\n        method: config.method,\n        headers: config.headers,\n        body: config.body,\n        signal: controller.signal,\n        redirect: config.redirect,\n      });\n\n      const contentType = response.headers.get('content-type') || '';\n      const responseType = (args.response_type || profile.data.response_type || 'auto').toLowerCase();\n\n      const maxCaptureBytes = this.resolveMaxCaptureBytes();\n      const streamMode = resolveStreamToArtifactMode();\n      const contextRoot = streamMode ? resolveContextRepoRoot() : null;\n      const traceId = args.trace_id || 'run';\n      const spanId = args.span_id || crypto.randomUUID();\n\n      let bodyRef = null;\n      let bodyRefTruncated = null;\n      let body;\n\n      if (\n        streamMode\n        && contextRoot\n        && response?.body\n        && typeof response.body[Symbol.asyncIterator] === 'function'\n      ) {\n        const artifactLimit = streamMode === 'full' ? Number.POSITIVE_INFINITY : maxCaptureBytes;\n        const previewChunks = [];\n        let previewCaptured = 0;\n        let previewTruncated = false;\n        let readBytes = 0;\n        let artifactWritten = 0;\n        let artifactTruncated = false;\n\n        const filename = `api-body-${crypto.randomUUID()}.bin`;\n        const ref = buildToolCallFileRef({ traceId, spanId, filename });\n\n        let writer = null;\n        try {\n          writer = await createArtifactWriteStream(contextRoot, ref);\n        } catch (artifactError) {\n          this.logger.warn('Failed to initialize API response artifact stream', { error: artifactError.message });\n        }\n\n        if (writer) {\n          let abortedEarly = false;\n          try {\n            for await (const chunk of response.body) {\n              const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk ?? '');\n              readBytes += buf.length;\n\n              if (previewCaptured < maxCaptureBytes) {\n                const remaining = maxCaptureBytes - previewCaptured;\n                if (buf.length <= remaining) {\n                  previewChunks.push(buf);\n                  previewCaptured += buf.length;\n                } else {\n                  previewChunks.push(buf.subarray(0, remaining));\n                  previewCaptured += remaining;\n                  previewTruncated = true;\n                }\n              } else {\n                previewTruncated = true;\n              }\n\n              if (artifactWritten < artifactLimit && writer) {\n                const remaining = artifactLimit - artifactWritten;\n                const slice = buf.length <= remaining ? buf : buf.subarray(0, remaining);\n                try {\n                  const ok = writer.stream.write(slice);\n                  if (!ok) {\n                    await once(writer.stream, 'drain');\n                  }\n                } catch (writeError) {\n                  this.logger.warn('Failed to stream API response body chunk', { error: writeError.message });\n                  await writer.abort().catch(() => null);\n                  writer = null;\n                }\n                artifactWritten += slice.length;\n                if (slice.length < buf.length) {\n                  artifactTruncated = true;\n                }\n              } else if (artifactLimit !== Number.POSITIVE_INFINITY) {\n                artifactTruncated = true;\n              }\n\n              if (artifactLimit !== Number.POSITIVE_INFINITY && artifactWritten >= artifactLimit) {\n                previewTruncated = true;\n                abortedEarly = true;\n                if (typeof response.body.destroy === 'function') {\n                  response.body.destroy();\n                }\n                break;\n              }\n            }\n          } catch (error) {\n            if (!abortedEarly) {\n              await writer.abort().catch(() => null);\n              throw error;\n            }\n          }\n\n          const previewBuffer = previewCaptured\n            ? Buffer.concat(previewChunks, previewCaptured)\n            : Buffer.alloc(0);\n\n          if (writer && artifactWritten > 0) {\n            try {\n              const written = await writer.finalize();\n              bodyRef = { uri: written.uri, rel: written.rel, bytes: written.bytes };\n              bodyRefTruncated = artifactTruncated;\n            } catch (artifactError) {\n              this.logger.warn('Failed to finalize API response artifact', { error: artifactError.message });\n              await writer.abort().catch(() => null);\n            }\n          } else if (writer) {\n            await writer.abort().catch(() => null);\n          }\n\n          body = {\n            buffer: previewBuffer,\n            body_read_bytes: readBytes,\n            body_captured_bytes: previewBuffer.length,\n            body_truncated: previewTruncated,\n          };\n        } else {\n          body = await readResponseBodyBytes(response, maxCaptureBytes);\n        }\n      } else {\n        body = await readResponseBodyBytes(response, maxCaptureBytes);\n      }\n\n      let data;\n      let bodyBase64;\n      let bodyBytes;\n      let dataTruncated;\n\n      if (responseType === 'bytes') {\n        bodyBase64 = body.buffer.toString('base64');\n        bodyBytes = body.buffer.length;\n      } else if (responseType === 'text') {\n        data = body.buffer.toString('utf8');\n        dataTruncated = body.body_truncated;\n      } else if (responseType === 'json' || contentType.includes('application/json')) {\n        const text = body.buffer.toString('utf8');\n        if (!body.body_truncated) {\n          try {\n            data = JSON.parse(text);\n          } catch (error) {\n            data = text;\n          }\n        } else {\n          data = text;\n        }\n        dataTruncated = body.body_truncated;\n      } else {\n        data = body.buffer.toString('utf8');\n        dataTruncated = body.body_truncated;\n      }\n\n      this.stats.requests += 1;\n\n      return {\n        success: response.ok,\n        method: config.method,\n        url: config.url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: Object.fromEntries(response.headers.entries()),\n        duration_ms: Date.now() - started,\n        data,\n        data_truncated: dataTruncated,\n        body_base64: bodyBase64,\n        body_bytes: bodyBytes,\n        body_read_bytes: body.body_read_bytes,\n        body_captured_bytes: body.body_captured_bytes,\n        body_truncated: body.body_truncated,\n        body_ref: bodyRef,\n        body_ref_truncated: bodyRefTruncated,\n      };\n    } finally {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 1734,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1146,
        "end_line": 1168,
        "content": "async fetchOnce(args, profile, auth, overrides = {}) {\n    const config = this.buildRequestConfig(args, profile, auth, overrides);\n    const controller = new AbortController();\n    const timeout = config.timeoutMs ? setTimeout(() => controller.abort(), config.timeoutMs) : null;\n    const started = Date.now();\n\n    try {\n      const response = await this.fetch(config.url, {\n        method: config.method,\n        headers: config.headers,\n        body: config.body,\n        signal: controller.signal,\n        redirect: config.redirect,\n        duplex: config.duplex,\n      });\n\n      return { response, config, duration_ms: Date.now() - started };\n    } finally {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 185,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1170,
        "end_line": 1220,
        "content": "async fetchWithRetry(args, profile, auth, overrides = {}) {\n    const policy = this.normalizeRetryPolicy(args.retry, profile.retry, args.method);\n    if (!policy.enabled) {\n      const once = await this.fetchOnce(args, profile, auth, overrides);\n      return { ...once, attempts: 1, retries: 0 };\n    }\n\n    let attempt = 0;\n    let lastError = null;\n    let lastResponse = null;\n\n    while (attempt < policy.max_attempts) {\n      attempt += 1;\n      try {\n        const once = await this.fetchOnce(args, profile, auth, overrides);\n        lastResponse = once;\n\n        const headers = Object.fromEntries(once.response.headers.entries());\n        const summary = {\n          status: once.response.status,\n          headers,\n        };\n\n        if (!this.shouldRetryResponse(summary, policy) || attempt >= policy.max_attempts) {\n          return {\n            ...once,\n            attempts: attempt,\n            retries: Math.max(0, attempt - 1),\n          };\n        }\n\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy, summary);\n        await sleep(delay);\n      } catch (error) {\n        lastError = error;\n        if (!policy.retry_on_network_error || attempt >= policy.max_attempts) {\n          throw error;\n        }\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy);\n        await sleep(delay);\n      }\n    }\n\n    if (lastResponse) {\n      return lastResponse;\n    }\n\n    throw lastError || new Error('Request failed after retries');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 385,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1222,
        "end_line": 1264,
        "content": "async requestWithRetry(args, profile, auth) {\n    const policy = this.normalizeRetryPolicy(args.retry, profile.retry, args.method);\n    if (!policy.enabled) {\n      return this.requestOnce(args, profile, auth);\n    }\n\n    let attempt = 0;\n    let lastResponse = null;\n    let lastError = null;\n\n    while (attempt < policy.max_attempts) {\n      attempt += 1;\n      try {\n        const response = await this.requestOnce(args, profile, auth);\n        lastResponse = response;\n        if (!this.shouldRetryResponse(response, policy) || attempt >= policy.max_attempts) {\n          return {\n            ...response,\n            attempts: attempt,\n            retries: Math.max(0, attempt - 1),\n          };\n        }\n\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy, response);\n        await sleep(delay);\n      } catch (error) {\n        lastError = error;\n        if (!policy.retry_on_network_error || attempt >= policy.max_attempts) {\n          throw error;\n        }\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy);\n        await sleep(delay);\n      }\n    }\n\n    if (lastResponse) {\n      return lastResponse;\n    }\n\n    throw lastError || new Error('Request failed after retries');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 321,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1266,
        "end_line": 1287,
        "content": "normalizePagination(requestPagination, profilePagination) {\n    const merged = {\n      ...(profilePagination || {}),\n      ...(requestPagination || {}),\n    };\n    if (!merged || !merged.type) {\n      throw new Error('pagination.type is required');\n    }\n\n    return {\n      type: String(merged.type).toLowerCase(),\n      param: merged.param || merged.cursor_param || 'page',\n      size_param: merged.size_param || 'limit',\n      size: merged.size ?? merged.page_size ?? Constants.PAGINATION?.PAGE_SIZE ?? 100,\n      start: merged.start ?? (merged.type === 'page' ? 1 : 0),\n      max_pages: merged.max_pages ?? Constants.PAGINATION?.MAX_PAGES ?? 10,\n      item_path: merged.item_path,\n      cursor_path: merged.cursor_path,\n      link_rel: merged.link_rel || 'next',\n      stop_on_empty: merged.stop_on_empty !== false,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 209,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1289,
        "end_line": 1337,
        "content": "async request(args) {\n    const profile = await this.resolveProfile(args.profile_name, args);\n    let auth = args.auth !== undefined ? args.auth : profile.auth;\n    const authProvider = args.auth_provider !== undefined ? args.auth_provider : profile.authProvider;\n\n    if (authProvider) {\n      auth = await this.resolveAuthProvider(authProvider, profile.name, args);\n    }\n\n    try {\n      const cachePolicy = this.normalizeCachePolicy(args.cache, profile.data.cache);\n      let cacheKey = null;\n\n      if (cachePolicy.enabled && this.cacheService) {\n        const config = this.buildRequestConfig(args, profile, auth);\n        const explicitKey = cachePolicy.key !== undefined ? this.cacheService.normalizeKey(cachePolicy.key) : null;\n        cacheKey = explicitKey || this.buildCacheKey(args, config);\n        if (cacheKey) {\n          const cached = await this.cacheService.getJson(cacheKey, cachePolicy.ttl_ms);\n          if (cached?.value) {\n            const createdAt = cached.created_at ? Date.parse(cached.created_at) : null;\n            const ageMs = createdAt ? Date.now() - createdAt : null;\n            return {\n              ...cached.value,\n              cache: { hit: true, key: cacheKey, created_at: cached.created_at, age_ms: ageMs },\n            };\n          }\n        }\n      }\n\n      const response = await this.requestWithRetry(args, profile, auth);\n\n      if (cachePolicy.enabled && this.cacheService && cacheKey) {\n        if (response.success !== false || cachePolicy.cache_errors) {\n          await this.cacheService.setJson(cacheKey, response, {\n            ttl_ms: cachePolicy.ttl_ms,\n            meta: { url: response.url, method: response.method },\n          });\n        }\n        response.cache = { hit: false, key: cacheKey };\n      }\n\n      return response;\n    } catch (error) {\n      this.stats.errors += 1;\n      this.logger.error('HTTP request failed', { method: args.method, url: args.url, error: error.message });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 497,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1339,
        "end_line": 1432,
        "content": "async paginate(args) {\n    const profile = await this.resolveProfile(args.profile_name, args);\n    let auth = args.auth !== undefined ? args.auth : profile.auth;\n    const authProvider = args.auth_provider !== undefined ? args.auth_provider : profile.authProvider;\n\n    if (authProvider) {\n      auth = await this.resolveAuthProvider(authProvider, profile.name, args);\n    }\n\n    const pagination = this.normalizePagination(args.pagination, profile.pagination);\n    const pages = [];\n    const items = [];\n\n    let cursor = pagination.start;\n    let pageNumber = pagination.start;\n    let offset = pagination.start;\n    let nextUrl = args.url;\n\n    for (let page = 0; page < pagination.max_pages; page += 1) {\n      const requestArgs = { ...args };\n      delete requestArgs.pagination;\n\n      if (pagination.type === 'page') {\n        requestArgs.query = { ...(args.query || {}), [pagination.param]: pageNumber, [pagination.size_param]: pagination.size };\n      } else if (pagination.type === 'offset') {\n        requestArgs.query = { ...(args.query || {}), [pagination.param]: offset, [pagination.size_param]: pagination.size };\n      } else if (pagination.type === 'cursor') {\n        const query = { ...(args.query || {}) };\n        if (cursor !== undefined && cursor !== null && cursor !== '') {\n          query[pagination.param] = cursor;\n        }\n        if (pagination.size_param) {\n          query[pagination.size_param] = pagination.size;\n        }\n        requestArgs.query = query;\n      } else if (pagination.type === 'link') {\n        if (!nextUrl) {\n          break;\n        }\n        requestArgs.url = nextUrl;\n        requestArgs.path = undefined;\n        requestArgs.base_url = undefined;\n      }\n\n      const response = await this.requestWithRetry(requestArgs, profile, auth);\n      pages.push(response);\n      this.stats.pages += 1;\n\n      if (pagination.item_path) {\n        const pageItems = getPathValue(response, pagination.item_path, { defaultValue: [] });\n        if (Array.isArray(pageItems)) {\n          items.push(...pageItems);\n          if (pagination.stop_on_empty && pageItems.length === 0) {\n            break;\n          }\n        } else if (pagination.stop_on_empty) {\n          break;\n        }\n      }\n\n      if (pagination.type === 'page') {\n        pageNumber += 1;\n      } else if (pagination.type === 'offset') {\n        offset += pagination.size;\n      } else if (pagination.type === 'cursor') {\n        if (!pagination.cursor_path) {\n          throw new Error('pagination.cursor_path is required for cursor pagination');\n        }\n        const nextCursor = getPathValue(response, pagination.cursor_path, { defaultValue: null });\n        if (!nextCursor) {\n          cursor = null;\n          break;\n        }\n        cursor = nextCursor;\n      } else if (pagination.type === 'link') {\n        const header = response.headers?.link || response.headers?.Link || response.headers?.LINK;\n        const links = parseLinkHeader(header);\n        const next = links.find((link) => link.rel === pagination.link_rel);\n        if (!next) {\n          nextUrl = null;\n          break;\n        }\n        nextUrl = next.url;\n      }\n    }\n\n    return {\n      success: pages.every((page) => page.success !== false),\n      pages,\n      items: pagination.item_path ? items : undefined,\n      page_count: pages.length,\n      next_cursor: cursor,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 847,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1434,
        "end_line": 1496,
        "content": "async downloadOnce(args, profile, auth) {\n    const config = this.buildRequestConfig(args, profile, auth);\n    const filePath = expandHomePath(args.download_path || args.file_path);\n    if (!filePath) {\n      throw new Error('download_path is required');\n    }\n\n    const overwrite = args.overwrite === true;\n    if (!overwrite && await pathExists(filePath)) {\n      throw new Error(`Local path already exists: ${filePath}`);\n    }\n\n    const controller = new AbortController();\n    const timeout = config.timeoutMs ? setTimeout(() => controller.abort(), config.timeoutMs) : null;\n    const started = Date.now();\n    const tmpPath = tempSiblingPath(filePath, '.part');\n\n    try {\n      await ensureDirForFile(filePath);\n      const response = await this.fetch(config.url, {\n        method: config.method,\n        headers: config.headers,\n        body: config.body,\n        signal: controller.signal,\n        redirect: config.redirect,\n      });\n\n      if (response.body) {\n        const readable = Readable.fromWeb(response.body);\n        await pipeline(readable, createWriteStream(tmpPath, { mode: 0o600 }));\n      } else {\n        const buffer = Buffer.from(await response.arrayBuffer());\n        await fs.writeFile(tmpPath, buffer, { mode: 0o600 });\n      }\n\n      await atomicReplaceFile(tmpPath, filePath, { overwrite, mode: 0o600 });\n      const stat = await fs.stat(filePath);\n\n      this.stats.downloads += 1;\n      return {\n        success: response.ok,\n        method: config.method,\n        url: config.url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: Object.fromEntries(response.headers.entries()),\n        file_path: filePath,\n        bytes: stat.size,\n        duration_ms: Date.now() - started,\n      };\n    } catch (error) {\n      try {\n        await fs.unlink(tmpPath);\n      } catch (cleanupError) {\n        // ignore cleanup errors\n      }\n      throw error;\n    } finally {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 504,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1498,
        "end_line": 1548,
        "content": "async download(args) {\n    const profile = await this.resolveProfile(args.profile_name, args);\n    let auth = args.auth !== undefined ? args.auth : profile.auth;\n    const authProvider = args.auth_provider !== undefined ? args.auth_provider : profile.authProvider;\n\n    if (authProvider) {\n      auth = await this.resolveAuthProvider(authProvider, profile.name, args);\n    }\n\n    const policy = this.normalizeRetryPolicy(args.retry, profile.retry, args.method);\n    if (!policy.enabled) {\n      return this.downloadOnce(args, profile, auth);\n    }\n\n    let attempt = 0;\n    let lastResponse = null;\n    let lastError = null;\n\n    while (attempt < policy.max_attempts) {\n      attempt += 1;\n      try {\n        const response = await this.downloadOnce(args, profile, auth);\n        lastResponse = response;\n        if (!this.shouldRetryResponse(response, policy) || attempt >= policy.max_attempts) {\n          return {\n            ...response,\n            attempts: attempt,\n            retries: Math.max(0, attempt - 1),\n          };\n        }\n\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy, response);\n        await sleep(delay);\n      } catch (error) {\n        lastError = error;\n        if (!policy.retry_on_network_error || attempt >= policy.max_attempts) {\n          throw error;\n        }\n        this.stats.retries += 1;\n        const delay = this.computeRetryDelay(attempt, policy);\n        await sleep(delay);\n      }\n    }\n\n    if (lastResponse) {\n      return lastResponse;\n    }\n\n    throw lastError || new Error('Download failed after retries');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 404,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1550,
        "end_line": 1566,
        "content": "async checkApi(args = {}) {\n    try {\n      const result = await this.request({ ...args, method: 'GET' });\n      return {\n        success: true,\n        accessible: result.status < 500,\n        status: result.status,\n        response: result.data ?? result.body_base64,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        accessible: false,\n        error: error.message,\n      };\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 105,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1568,
        "end_line": 1570,
        "content": "getStats() {\n    return { ...this.stats };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 13,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/APIManager.ts",
        "start_line": 1572,
        "end_line": 1574,
        "content": "async cleanup() {\n    // –Ω–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "APIManager",
          "estimated_tokens": 20,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/AliasManager.ts": [
      {
        "file_path": "src/managers/AliasManager.ts",
        "start_line": 9,
        "end_line": 12,
        "content": "constructor(logger, aliasService) {\n    this.logger = logger.child('alias');\n    this.aliasService = aliasService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasManager",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AliasManager.ts",
        "start_line": 14,
        "end_line": 33,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'alias_upsert':\n        return this.aliasService.setAlias(args.name, args.alias || args);\n      case 'alias_get':\n        return this.aliasService.getAlias(args.name);\n      case 'alias_list':\n        return this.aliasService.listAliases();\n      case 'alias_delete':\n        return this.aliasService.deleteAlias(args.name);\n      case 'alias_resolve': {\n        const resolved = await this.aliasService.resolveAlias(args.name);\n        return { success: true, alias: resolved ? { name: args.name, ...resolved } : null };\n      }\n      default:\n        throw new Error(`Unknown alias action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasManager",
          "estimated_tokens": 180,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AliasManager.ts",
        "start_line": 35,
        "end_line": 37,
        "content": "getStats() {\n    return this.aliasService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AliasManager.ts",
        "start_line": 39,
        "end_line": 41,
        "content": "async cleanup() {\n    await this.aliasService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/ArtifactManager.ts": [
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 12,
        "end_line": 21,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return null;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 23,
        "end_line": 41,
        "content": "function normalizeArtifactRel({ uri, rel }) {\n  if (typeof uri === 'string' && uri.trim().length) {\n    const trimmed = uri.trim();\n    if (!trimmed.startsWith('artifact://')) {\n      throw ToolError.invalidParams({ field: 'uri', message: 'uri must start with artifact://' });\n    }\n    const next = trimmed.slice('artifact://'.length);\n    if (!next.trim().length) {\n      throw ToolError.invalidParams({ field: 'uri', message: 'artifact uri must include path' });\n    }\n    return next;\n  }\n\n  if (typeof rel === 'string' && rel.trim().length) {\n    return rel.trim();\n  }\n\n  throw ToolError.invalidParams({ message: 'Provide artifact uri or rel path', hint: \"Example: { action: 'get', uri: 'artifact://runs/<trace>/tool_calls/<span>/stdout.log' }\" });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeArtifactRel",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 189,
          "qualified_name": "normalizeArtifactRel",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 43,
        "end_line": 46,
        "content": "function buildArtifactUri(rel) {\n  const normalized = typeof rel === 'string' ? rel.trim() : '';\n  return `artifact://${normalized}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildArtifactUri",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 33,
          "qualified_name": "buildArtifactUri",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 48,
        "end_line": 73,
        "content": "async function readFileSlice(filePath, { offset, length }) {\n  const handle = await fs.open(filePath, 'r');\n  try {\n    const stat = await handle.stat();\n    const fileBytes = stat.size;\n\n    const start = Math.max(0, Math.min(Number(offset) || 0, fileBytes));\n    const maxLen = Math.max(0, Number(length) || 0);\n    const toRead = Math.max(0, Math.min(maxLen, fileBytes - start));\n    const buffer = Buffer.alloc(toRead);\n\n    if (toRead > 0) {\n      await handle.read(buffer, 0, toRead, start);\n    }\n\n    return {\n      buffer,\n      file_bytes: fileBytes,\n      offset: start,\n      length: toRead,\n      truncated: start + toRead < fileBytes,\n    };\n  } finally {\n    await handle.close();\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readFileSlice",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 175,
          "qualified_name": "readFileSlice",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 75,
        "end_line": 97,
        "content": "async function readTailSlice(filePath, { length }) {\n  const handle = await fs.open(filePath, 'r');\n  try {\n    const stat = await handle.stat();\n    const fileBytes = stat.size;\n    const maxLen = Math.max(0, Number(length) || 0);\n    const toRead = Math.max(0, Math.min(maxLen, fileBytes));\n    const start = Math.max(0, fileBytes - toRead);\n    const buffer = Buffer.alloc(toRead);\n    if (toRead > 0) {\n      await handle.read(buffer, 0, toRead, start);\n    }\n    return {\n      buffer,\n      file_bytes: fileBytes,\n      offset: start,\n      length: toRead,\n      truncated: start > 0,\n    };\n  } finally {\n    await handle.close();\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readTailSlice",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 160,
          "qualified_name": "readTailSlice",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 99,
        "end_line": 101,
        "content": "function sha256(buffer) {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "sha256",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 23,
          "qualified_name": "sha256",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 104,
        "end_line": 107,
        "content": "constructor(logger, validation) {\n    this.logger = logger.child('artifacts');\n    this.validation = validation;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 109,
        "end_line": 127,
        "content": "async handleAction(args = {}) {\n    const action = args.action;\n    switch (action) {\n      case 'get':\n        return this.get(args);\n      case 'head':\n        return this.head(args);\n      case 'tail':\n        return this.tail(args);\n      case 'list':\n        return this.list(args);\n      default:\n        throw ToolError.invalidParams({\n          field: 'action',\n          message: `Unknown artifacts action: ${action}`,\n          hint: 'Use one of: get, head, tail, list.',\n        });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 128,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 129,
        "end_line": 139,
        "content": "resolveContextRoot() {\n    const contextRoot = resolveContextRepoRoot();\n    if (!contextRoot) {\n      throw ToolError.denied({\n        code: 'ARTIFACTS_UNAVAILABLE',\n        message: 'Artifacts are unavailable (context repo root is not configured)',\n        hint: 'Set SF_CONTEXT_REPO_ROOT (or SENTRYFROGG_CONTEXT_REPO_ROOT) to a writable directory.',\n      });\n    }\n    return contextRoot;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 102,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 141,
        "end_line": 155,
        "content": "async resolveFilePath({ uri, rel }) {\n    const contextRoot = this.resolveContextRoot();\n    const artifactRel = normalizeArtifactRel({ uri, rel });\n    const filePath = resolveArtifactPath(contextRoot, artifactRel);\n    const exists = await pathExists(filePath);\n    if (!exists) {\n      throw ToolError.notFound({\n        code: 'ARTIFACT_NOT_FOUND',\n        message: `Artifact not found: ${buildArtifactUri(artifactRel)}`,\n        hint: 'Check the uri/rel or call { action: \"list\" } to discover available artifacts.',\n        details: { uri: buildArtifactUri(artifactRel), rel: artifactRel },\n      });\n    }\n    return { contextRoot, rel: artifactRel, uri: buildArtifactUri(artifactRel), filePath };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 179,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 157,
        "end_line": 184,
        "content": "async get(args = {}) {\n    const resolved = await this.resolveFilePath({ uri: args.uri, rel: args.rel });\n    const maxBytes = Math.min(readPositiveInt(args.max_bytes) ?? 64 * 1024, 10 * 1024 * 1024);\n    const offset = readPositiveInt(args.offset) ?? 0;\n    const slice = await readFileSlice(resolved.filePath, { offset, length: maxBytes });\n\n    const encoding = String(args.encoding || 'utf8').toLowerCase();\n    const payload = {\n      success: true,\n      uri: resolved.uri,\n      rel: resolved.rel,\n      file_bytes: slice.file_bytes,\n      offset: slice.offset,\n      length: slice.length,\n      truncated: slice.truncated,\n      sha256: sha256(slice.buffer),\n      encoding,\n    };\n\n    if (encoding === 'base64') {\n      payload.content_base64 = slice.buffer.toString('base64');\n    } else {\n      payload.content = slice.buffer.toString('utf8');\n      payload.encoding = 'utf8';\n    }\n\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 232,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 186,
        "end_line": 212,
        "content": "async head(args = {}) {\n    const resolved = await this.resolveFilePath({ uri: args.uri, rel: args.rel });\n    const maxBytes = Math.min(readPositiveInt(args.max_bytes) ?? 64 * 1024, 10 * 1024 * 1024);\n    const slice = await readFileSlice(resolved.filePath, { offset: 0, length: maxBytes });\n    const encoding = String(args.encoding || 'utf8').toLowerCase();\n\n    const payload = {\n      success: true,\n      uri: resolved.uri,\n      rel: resolved.rel,\n      file_bytes: slice.file_bytes,\n      offset: slice.offset,\n      length: slice.length,\n      truncated: slice.truncated,\n      sha256: sha256(slice.buffer),\n      encoding,\n    };\n\n    if (encoding === 'base64') {\n      payload.content_base64 = slice.buffer.toString('base64');\n    } else {\n      payload.content = slice.buffer.toString('utf8');\n      payload.encoding = 'utf8';\n    }\n\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 220,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 214,
        "end_line": 240,
        "content": "async tail(args = {}) {\n    const resolved = await this.resolveFilePath({ uri: args.uri, rel: args.rel });\n    const maxBytes = Math.min(readPositiveInt(args.max_bytes) ?? 64 * 1024, 10 * 1024 * 1024);\n    const slice = await readTailSlice(resolved.filePath, { length: maxBytes });\n    const encoding = String(args.encoding || 'utf8').toLowerCase();\n\n    const payload = {\n      success: true,\n      uri: resolved.uri,\n      rel: resolved.rel,\n      file_bytes: slice.file_bytes,\n      offset: slice.offset,\n      length: slice.length,\n      truncated: slice.truncated,\n      sha256: sha256(slice.buffer),\n      encoding,\n    };\n\n    if (encoding === 'base64') {\n      payload.content_base64 = slice.buffer.toString('base64');\n    } else {\n      payload.content = slice.buffer.toString('utf8');\n      payload.encoding = 'utf8';\n    }\n\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 217,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ArtifactManager.ts",
        "start_line": 242,
        "end_line": 298,
        "content": "async list(args = {}) {\n    const contextRoot = this.resolveContextRoot();\n    const prefix = typeof args.prefix === 'string' && args.prefix.trim().length ? args.prefix.trim() : '.';\n    const limit = Math.min(readPositiveInt(args.limit) ?? 200, 2000);\n\n    const baseDir = path.resolve(contextRoot, 'artifacts');\n    const root = resolveArtifactPath(contextRoot, prefix);\n\n    const exists = await pathExists(root);\n    if (!exists) {\n      return { success: true, prefix, items: [], count: 0 };\n    }\n\n    const items = [];\n    const stack = [{ dir: root, rel: prefix === '.' ? '' : prefix }];\n\n    while (stack.length && items.length < limit) {\n      const current = stack.pop();\n      if (!current) {\n        continue;\n      }\n\n      let entries;\n      try {\n        entries = await fs.readdir(current.dir, { withFileTypes: true });\n      } catch (error) {\n        if (error.code === 'ENOTDIR') {\n          break;\n        }\n        throw error;\n      }\n\n      for (const entry of entries) {\n        if (items.length >= limit) {\n          break;\n        }\n\n        const nextRel = current.rel ? `${current.rel}/${entry.name}` : entry.name;\n        const entryPath = path.join(current.dir, entry.name);\n        if (entry.isDirectory()) {\n          stack.push({ dir: entryPath, rel: nextRel });\n          continue;\n        }\n\n        const stat = await fs.stat(entryPath).catch(() => null);\n        const fileBytes = stat?.size ?? null;\n        items.push({\n          uri: buildArtifactUri(nextRel),\n          rel: nextRel,\n          bytes: fileBytes,\n          mtime: stat?.mtime ? stat.mtime.toISOString() : null,\n        });\n      }\n    }\n\n    return { success: true, prefix, items, count: items.length, truncated: items.length >= limit };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactManager",
          "estimated_tokens": 439,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/AuditManager.ts": [
      {
        "file_path": "src/managers/AuditManager.ts",
        "start_line": 9,
        "end_line": 12,
        "content": "constructor(logger, auditService) {\n    this.logger = logger.child('audit');\n    this.auditService = auditService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditManager",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AuditManager.ts",
        "start_line": 14,
        "end_line": 51,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'audit_list':\n        return this.auditService.readEntries({\n          limit: args.limit,\n          offset: args.offset,\n          reverse: args.reverse === true,\n          filters: {\n            trace_id: args.trace_id,\n            tool: args.tool,\n            action: args.audit_action,\n            status: args.status,\n            since: args.since,\n          },\n        });\n      case 'audit_tail':\n        return this.auditService.readEntries({\n          limit: args.limit || 50,\n          offset: 0,\n          reverse: true,\n          filters: {\n            trace_id: args.trace_id,\n            tool: args.tool,\n            action: args.audit_action,\n            status: args.status,\n            since: args.since,\n          },\n        });\n      case 'audit_clear':\n        return this.auditService.clear();\n      case 'audit_stats':\n        return { success: true, stats: this.auditService.getStats() };\n      default:\n        throw new Error(`Unknown audit action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditManager",
          "estimated_tokens": 275,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AuditManager.ts",
        "start_line": 53,
        "end_line": 55,
        "content": "getStats() {\n    return this.auditService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/AuditManager.ts",
        "start_line": 57,
        "end_line": 59,
        "content": "async cleanup() {\n    await this.auditService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/CapabilityManager.ts": [
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 11,
        "end_line": 26,
        "content": "function ensureStringArray(value, label) {\n  if (value === undefined || value === null) {\n    return [];\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`${label} must be an array`);\n  }\n  const result = [];\n  for (const entry of value) {\n    if (typeof entry !== 'string' || entry.trim().length === 0) {\n      throw new Error(`${label} must contain non-empty strings`);\n    }\n    result.push(entry.trim());\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureStringArray",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 109,
          "qualified_name": "ensureStringArray",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 28,
        "end_line": 36,
        "content": "function ensureOptionalObject(value, label) {\n  if (value === undefined || value === null) {\n    return undefined;\n  }\n  if (typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error(`${label} must be an object`);\n  }\n  return value;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureOptionalObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "ensureOptionalObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 38,
        "end_line": 52,
        "content": "function normalizeInputs(inputs) {\n  if (!inputs) {\n    return { required: [], defaults: {}, map: {}, pass_through: true };\n  }\n  const required = ensureStringArray(inputs.required, 'Capability inputs.required');\n  const defaults = ensureOptionalObject(inputs.defaults, 'Capability inputs.defaults') || {};\n  const map = ensureOptionalObject(inputs.map, 'Capability inputs.map') || {};\n  const passThrough = inputs.pass_through !== false;\n  return {\n    required,\n    defaults,\n    map,\n    pass_through: passThrough,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeInputs",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 131,
          "qualified_name": "normalizeInputs",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 54,
        "end_line": 61,
        "content": "function normalizeEffects(effects) {\n  const kind = effects?.kind || 'read';\n  if (!EFFECT_KINDS.has(kind)) {\n    throw new Error(`effects.kind must be one of: ${Array.from(EFFECT_KINDS).join(', ')}`);\n  }\n  const requiresApply = effects?.requires_apply ?? (kind !== 'read');\n  return { kind, requires_apply: Boolean(requiresApply) };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeEffects",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 84,
          "qualified_name": "normalizeEffects",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 63,
        "end_line": 71,
        "content": "function normalizeWhen(when) {\n  if (when === undefined || when === null) {\n    return undefined;\n  }\n  if (typeof when !== 'object' || Array.isArray(when)) {\n    throw new Error('Capability when must be an object');\n  }\n  return when;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeWhen",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 59,
          "qualified_name": "normalizeWhen",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 74,
        "end_line": 80,
        "content": "constructor(logger, security, validation, capabilityService, contextService) {\n    this.logger = logger.child('capability');\n    this.security = security;\n    this.validation = validation;\n    this.capabilityService = capabilityService;\n    this.contextService = contextService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 82,
        "end_line": 104,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n    switch (action) {\n      case 'list':\n        return this.list();\n      case 'get':\n        return this.get(args);\n      case 'set':\n        return this.set(args);\n      case 'delete':\n        return this.delete(args);\n      case 'resolve':\n        return this.resolve(args);\n      case 'suggest':\n        return this.suggest(args);\n      case 'graph':\n        return this.graph();\n      case 'stats':\n        return this.capabilityService.getStats();\n      default:\n        throw new Error(`Unknown capability action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 155,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 106,
        "end_line": 109,
        "content": "async list() {\n    const capabilities = await this.capabilityService.listCapabilities();\n    return { success: true, capabilities };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 38,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 111,
        "end_line": 115,
        "content": "async get(args) {\n    const name = this.validation.ensureString(args.name, 'Capability name');\n    const capability = await this.capabilityService.getCapability(name);\n    return { success: true, capability };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 117,
        "end_line": 152,
        "content": "async resolve(args) {\n    const intent = this.validation.ensureString(args.intent, 'Intent type');\n    const candidates = await this.capabilityService.findAllByIntent(intent);\n    if (!candidates || candidates.length === 0) {\n      throw new Error(`Capability for intent '${intent}' not found`);\n    }\n\n    const contextResult = this.contextService\n      ? await this.contextService.getContext(args).catch(() => null)\n      : null;\n    const context = contextResult?.context && typeof contextResult.context === 'object'\n      ? contextResult.context\n      : {};\n\n    const matched = [];\n    for (const candidate of candidates) {\n      if (await matchesWhen(candidate.when, context)) {\n        matched.push(candidate);\n      }\n    }\n\n    if (matched.length === 0) {\n      throw new Error(`No capability matched when-clause for intent '${intent}'`);\n    }\n\n    matched.sort((a, b) => {\n      const aIsDirect = a.name === intent ? 0 : 1;\n      const bIsDirect = b.name === intent ? 0 : 1;\n      if (aIsDirect !== bIsDirect) {\n        return aIsDirect - bIsDirect;\n      }\n      return String(a.name).localeCompare(String(b.name));\n    });\n\n    return { success: true, capability: matched[0], context: contextResult?.context };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 310,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 154,
        "end_line": 173,
        "content": "async set(args) {\n    const name = this.validation.ensureString(args.name, 'Capability name');\n    const config = this.validation.ensureObject(args.capability, 'Capability config');\n    this.security.ensureSizeFits(JSON.stringify(config));\n\n    const normalized = {\n      name,\n      intent: this.validation.ensureString(config.intent || name, 'Capability intent'),\n      description: config.description ? this.validation.ensureString(config.description, 'Capability description', { trim: false }) : undefined,\n      runbook: this.validation.ensureString(config.runbook, 'Capability runbook'),\n      inputs: normalizeInputs(config.inputs),\n      effects: normalizeEffects(config.effects),\n      depends_on: ensureStringArray(config.depends_on, 'Capability depends_on'),\n      tags: ensureStringArray(config.tags, 'Capability tags'),\n      when: normalizeWhen(config.when),\n    };\n\n    const capability = await this.capabilityService.setCapability(name, normalized);\n    return { success: true, capability };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 256,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 175,
        "end_line": 178,
        "content": "async delete(args) {\n    const name = this.validation.ensureString(args.name, 'Capability name');\n    return this.capabilityService.deleteCapability(name);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 43,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 180,
        "end_line": 188,
        "content": "async graph() {\n    const items = await this.capabilityService.listCapabilities();\n    const edges = items.map((capability) => ({\n      name: capability.name,\n      depends_on: capability.depends_on || [],\n      intent: capability.intent,\n    }));\n    return { success: true, graph: edges };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/CapabilityManager.ts",
        "start_line": 190,
        "end_line": 222,
        "content": "async suggest(args) {\n    if (!this.contextService) {\n      throw new Error('Context service is not available');\n    }\n    const contextResult = await this.contextService.getContext(args);\n    const context = contextResult.context || {};\n    const capabilities = await this.capabilityService.listCapabilities();\n\n    const suggestions = [];\n    for (const capability of capabilities) {\n      if (await matchesWhen(capability.when, context)) {\n        suggestions.push({\n          name: capability.name,\n          intent: capability.intent,\n          description: capability.description,\n          effects: capability.effects,\n          tags: capability.tags || [],\n          when: capability.when,\n          source: capability.source || 'local',\n        });\n      }\n    }\n\n    return {\n      success: true,\n      context: {\n        key: context.key,\n        root: context.root,\n        tags: context.tags,\n      },\n      suggestions,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityManager",
          "estimated_tokens": 240,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/ContextManager.ts": [
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 9,
        "end_line": 13,
        "content": "constructor(logger, validation, contextService) {\n    this.logger = logger.child('context');\n    this.validation = validation;\n    this.contextService = contextService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 15,
        "end_line": 31,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n    switch (action) {\n      case 'get':\n        return this.get(args);\n      case 'refresh':\n        return this.refresh(args);\n      case 'summary':\n        return this.summary(args);\n      case 'list':\n        return this.list();\n      case 'stats':\n        return this.contextService.getStats();\n      default:\n        throw new Error(`Unknown context action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 114,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 33,
        "end_line": 51,
        "content": "normalizeArgs(args) {\n    const payload = { ...args };\n    if (payload.project) {\n      payload.project = this.validation.ensureString(payload.project, 'project');\n    }\n    if (payload.target) {\n      payload.target = this.validation.ensureString(payload.target, 'target');\n    }\n    if (payload.cwd) {\n      payload.cwd = this.validation.ensureString(payload.cwd, 'cwd', { trim: false });\n    }\n    if (payload.repo_root) {\n      payload.repo_root = this.validation.ensureString(payload.repo_root, 'repo_root', { trim: false });\n    }\n    if (payload.key) {\n      payload.key = this.validation.ensureString(payload.key, 'key', { trim: false });\n    }\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 172,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 53,
        "end_line": 56,
        "content": "async get(args) {\n    const payload = this.normalizeArgs(args);\n    return this.contextService.getContext(payload);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 58,
        "end_line": 61,
        "content": "async refresh(args) {\n    const payload = this.normalizeArgs(args);\n    return this.contextService.getContext({ ...payload, refresh: true });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 63,
        "end_line": 79,
        "content": "async summary(args) {\n    const payload = this.normalizeArgs(args);\n    const result = await this.contextService.getContext(payload);\n    const context = result.context || {};\n    return {\n      success: true,\n      summary: {\n        key: context.key,\n        root: context.root,\n        tags: context.tags,\n        signals: context.signals,\n        project_name: context.project_name,\n        target_name: context.target_name,\n        updated_at: context.updated_at,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 125,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ContextManager.ts",
        "start_line": 81,
        "end_line": 83,
        "content": "async list() {\n    return this.contextService.listContexts();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextManager",
          "estimated_tokens": 19,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/EnvManager.ts": [
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 14,
        "end_line": 16,
        "content": "function isPlainObject(value) {\n  return !!value && typeof value === 'object' && !Array.isArray(value);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isPlainObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 26,
          "qualified_name": "isPlainObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 18,
        "end_line": 46,
        "content": "function normalizeStringMap(input, label, { allowNull = true } = {}) {\n  if (input === undefined) {\n    return undefined;\n  }\n  if (input === null) {\n    return null;\n  }\n  if (!isPlainObject(input)) {\n    throw new Error(`${label} must be an object`);\n  }\n\n  const out = {};\n  for (const [key, raw] of Object.entries(input)) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      continue;\n    }\n    if (raw === undefined) {\n      continue;\n    }\n    if (raw === null) {\n      if (allowNull) {\n        out[key] = null;\n      }\n      continue;\n    }\n    out[key] = String(raw);\n  }\n  return out;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeStringMap",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 153,
          "qualified_name": "normalizeStringMap",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 48,
        "end_line": 57,
        "content": "function normalizeEnvKey(key) {\n  const trimmed = String(key || '').trim();\n  if (!trimmed) {\n    throw new Error('env var key must be a non-empty string');\n  }\n  if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(trimmed)) {\n    throw new Error(`Invalid env var key: ${trimmed}`);\n  }\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeEnvKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 72,
          "qualified_name": "normalizeEnvKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 59,
        "end_line": 67,
        "content": "function escapeEnvValue(value) {\n  const str = String(value ?? '');\n  const escaped = str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\"/g, '\\\\\"');\n  return `\"${escaped}\"`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "escapeEnvValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 56,
          "qualified_name": "escapeEnvValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 69,
        "end_line": 77,
        "content": "function renderDotenv(vars) {\n  const entries = Object.entries(vars || {})\n    .map(([k, v]) => [normalizeEnvKey(k), String(v ?? '')]);\n\n  entries.sort(([a], [b]) => a.localeCompare(b));\n\n  const lines = entries.map(([key, value]) => `${key}=${escapeEnvValue(value)}`);\n  return `${lines.join('\\n')}\\n`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "renderDotenv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 76,
          "qualified_name": "renderDotenv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 80,
        "end_line": 87,
        "content": "constructor(logger, validation, profileService, sshManager, projectResolver, secretRefResolver) {\n    this.logger = logger.child('env');\n    this.validation = validation;\n    this.profileService = profileService;\n    this.sshManager = sshManager;\n    this.projectResolver = projectResolver;\n    this.secretRefResolver = secretRefResolver;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 87,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 89,
        "end_line": 108,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'profile_upsert':\n        return this.profileUpsert(args.profile_name, args);\n      case 'profile_get':\n        return this.profileGet(args.profile_name, args.include_secrets);\n      case 'profile_list':\n        return this.profileList();\n      case 'profile_delete':\n        return this.profileDelete(args.profile_name);\n      case 'write_remote':\n        return this.writeRemote(args);\n      case 'run_remote':\n        return this.runRemote(args);\n      default:\n        throw new Error(`Unknown env action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 158,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 110,
        "end_line": 142,
        "content": "async resolveProfilesFromProject(args) {\n    if (!this.projectResolver) {\n      return {\n        projectName: undefined,\n        targetName: undefined,\n        envProfile: undefined,\n        sshProfile: undefined,\n        cwd: undefined,\n        envPath: undefined,\n      };\n    }\n\n    const context = await this.projectResolver.resolveContext(args);\n    if (!context) {\n      return {\n        projectName: undefined,\n        targetName: undefined,\n        envProfile: undefined,\n        sshProfile: undefined,\n        cwd: undefined,\n        envPath: undefined,\n      };\n    }\n\n    return {\n      projectName: context.projectName,\n      targetName: context.targetName,\n      envProfile: context.target.env_profile,\n      sshProfile: context.target.ssh_profile,\n      cwd: context.target.cwd,\n      envPath: context.target.env_path,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 212,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 144,
        "end_line": 166,
        "content": "async resolveEnvProfileName(args) {\n    if (args.profile_name) {\n      return this.validation.ensureString(args.profile_name, 'profile_name');\n    }\n\n    if (args.env_profile) {\n      return this.validation.ensureString(String(args.env_profile), 'env_profile');\n    }\n\n    const resolved = await this.resolveProfilesFromProject(args);\n    if (resolved.envProfile) {\n      return this.validation.ensureString(String(resolved.envProfile), 'env_profile');\n    }\n\n    const profiles = await this.profileService.listProfiles(ENV_PROFILE_TYPE);\n    if (profiles.length === 1) {\n      return profiles[0].name;\n    }\n    if (profiles.length === 0) {\n      throw new Error('env profile is required (no env profiles exist)');\n    }\n    throw new Error('env profile is required when multiple env profiles exist');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 203,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 168,
        "end_line": 185,
        "content": "async resolveSshProfileName(args) {\n    if (args.ssh_profile_name) {\n      return this.validation.ensureString(String(args.ssh_profile_name), 'ssh_profile_name');\n    }\n    if (args.ssh_profile) {\n      return this.validation.ensureString(String(args.ssh_profile), 'ssh_profile');\n    }\n    if (args.profile_name && args.action !== 'profile_upsert' && args.action !== 'profile_get' && args.action !== 'profile_delete') {\n      // avoid collisions: profile_name belongs to env profile operations\n    }\n\n    const resolved = await this.resolveProfilesFromProject(args);\n    if (resolved.sshProfile) {\n      return this.validation.ensureString(String(resolved.sshProfile), 'ssh_profile');\n    }\n\n    throw new Error('ssh_profile_name is required (or configure project target.ssh_profile)');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 199,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 187,
        "end_line": 197,
        "content": "async loadEnvBundle(envProfileName) {\n    const profile = await this.profileService.getProfile(envProfileName, ENV_PROFILE_TYPE);\n    const vars = { ...(profile.data?.variables || {}) };\n    const secrets = { ...(profile.secrets || {}) };\n    return {\n      name: envProfileName,\n      variables: { ...vars, ...secrets },\n      variable_keys: Object.keys({ ...vars, ...secrets }).sort(),\n      secret_keys: Object.keys(secrets).sort(),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 113,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 199,
        "end_line": 232,
        "content": "async profileUpsert(profileName, params) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n\n    const description = params.description !== undefined ? String(params.description) : undefined;\n\n    let secrets;\n    if (params.secrets === null) {\n      secrets = null;\n    } else if (params.env !== undefined || params.variables !== undefined || params.secrets !== undefined) {\n      const fromEnv = normalizeStringMap(params.env, 'env', { allowNull: true }) || {};\n      const fromVars = normalizeStringMap(params.variables, 'variables', { allowNull: true }) || {};\n      const fromSecrets = normalizeStringMap(params.secrets, 'secrets', { allowNull: true }) || {};\n      secrets = { ...fromEnv, ...fromVars, ...fromSecrets };\n    }\n\n    await this.profileService.setProfile(name, {\n      type: ENV_PROFILE_TYPE,\n      data: { description },\n      secrets,\n    });\n\n    const stored = await this.profileService.getProfile(name, ENV_PROFILE_TYPE);\n    const keys = stored.secrets ? Object.keys(stored.secrets).sort() : [];\n\n    return {\n      success: true,\n      profile: {\n        name,\n        type: ENV_PROFILE_TYPE,\n        description: stored.data?.description,\n        keys,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 308,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 234,
        "end_line": 260,
        "content": "async profileGet(profileName, includeSecrets = false) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const profile = await this.profileService.getProfile(name, ENV_PROFILE_TYPE);\n\n    const legacyVars = isPlainObject(profile.data?.variables) ? profile.data.variables : {};\n    const secretVars = profile.secrets || {};\n    const keys = Object.keys({ ...legacyVars, ...secretVars }).sort();\n\n    const allow = isTruthy(process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT) || isTruthy(process.env.SF_ALLOW_SECRET_EXPORT);\n    if (includeSecrets && allow) {\n      return { success: true, profile };\n    }\n\n    return {\n      success: true,\n      profile: {\n        name: profile.name,\n        type: profile.type,\n        data: {\n          ...(profile.data || {}),\n          variables: keys,\n        },\n        secrets: keys,\n        secrets_redacted: true,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 227,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 262,
        "end_line": 265,
        "content": "async profileList() {\n    const profiles = await this.profileService.listProfiles(ENV_PROFILE_TYPE);\n    return { success: true, profiles };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 38,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 267,
        "end_line": 271,
        "content": "async profileDelete(profileName) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    await this.profileService.deleteProfile(name);\n    return { success: true, profile: name };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 273,
        "end_line": 408,
        "content": "async writeRemote(args) {\n    const envProfileName = await this.resolveEnvProfileName(args);\n    const sshProfileName = await this.resolveSshProfileName(args);\n\n    let remotePath = args.remote_path !== undefined\n      ? this.validation.ensureString(args.remote_path, 'remote_path', { trim: false })\n      : undefined;\n    const mode = args.mode !== undefined ? Number(args.mode) : 0o600;\n    const mkdirs = args.mkdirs === true;\n    const overwrite = args.overwrite === true;\n    const keepBackup = args.backup === true;\n\n    const bundle = await this.loadEnvBundle(envProfileName);\n    const resolvedVars = await this.secretRefResolver.resolveDeep(bundle.variables, args);\n    const content = renderDotenv(resolvedVars);\n\n    const projectDefaults = !remotePath ? await this.resolveProfilesFromProject(args) : null;\n    if (!remotePath) {\n      if (projectDefaults?.envPath) {\n        remotePath = this.validation.ensureString(String(projectDefaults.envPath), 'remote_path', { trim: false });\n      } else if (projectDefaults?.cwd) {\n        const cwd = this.validation.ensureString(String(projectDefaults.cwd), 'cwd', { trim: false });\n        remotePath = path.posix.join(cwd, '.env');\n      } else {\n        throw new Error('remote_path is required (or configure project target.env_path / target.cwd)');\n      }\n    }\n\n    const randomToken = () => crypto.randomBytes(6).toString('hex');\n\n    let keptBackupPath = null;\n\n    await this.sshManager.withSftp({ profile_name: sshProfileName }, async (sftp) => {\n      const stat = (candidate) => new Promise((resolve, reject) => {\n        sftp.stat(candidate, (error, result) => (error ? reject(error) : resolve(result)));\n      });\n      const rename = (from, to) => new Promise((resolve, reject) => {\n        sftp.rename(from, to, (error) => (error ? reject(error) : resolve()));\n      });\n      const unlink = (candidate) => new Promise((resolve, reject) => {\n        sftp.unlink(candidate, (error) => (error ? reject(error) : resolve()));\n      });\n      const chmod = (candidate, chmodMode) => new Promise((resolve, reject) => {\n        if (typeof sftp.chmod !== 'function') {\n          resolve();\n          return;\n        }\n        sftp.chmod(candidate, chmodMode, (error) => (error ? reject(error) : resolve()));\n      });\n\n      if (mkdirs) {\n        await this.sshManager.ensureRemoteDir(sftp, remotePath);\n      }\n\n      let exists = false;\n      try {\n        await stat(remotePath);\n        exists = true;\n      } catch (error) {\n        if (error && (error.code === 2 || error.code === 'ENOENT')) {\n          exists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (exists && !overwrite) {\n        throw new Error(`Remote path already exists: ${remotePath}`);\n      }\n\n      const tmpPath = `${remotePath}.tmp-${process.pid}-${Date.now()}-${randomToken()}`;\n      const backupPath = exists ? `${remotePath}.bak-${Date.now()}-${randomToken()}` : null;\n      let movedToBackup = false;\n\n      const writeTmp = () => new Promise((resolve, reject) => {\n        const stream = sftp.createWriteStream(tmpPath, { mode });\n        let done = false;\n        const finalize = (error) => {\n          if (done) {\n            return;\n          }\n          done = true;\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        };\n\n        stream.on('error', finalize);\n        stream.on('close', () => finalize());\n        stream.on('finish', () => finalize());\n        stream.end(content);\n      });\n\n      try {\n        await writeTmp();\n        await chmod(tmpPath, mode);\n\n        if (exists && overwrite && backupPath) {\n          await rename(remotePath, backupPath);\n          movedToBackup = true;\n        }\n\n        await rename(tmpPath, remotePath);\n        await chmod(remotePath, mode);\n\n        if (movedToBackup && !keepBackup) {\n          await unlink(backupPath).catch(() => null);\n        } else if (movedToBackup && keepBackup) {\n          keptBackupPath = backupPath;\n        }\n      } catch (error) {\n        await unlink(tmpPath).catch(() => null);\n        if (movedToBackup && backupPath) {\n          await rename(backupPath, remotePath).catch(() => null);\n        }\n        throw error;\n      }\n    });\n\n    const response = {\n      success: true,\n      ssh_profile_name: sshProfileName,\n      env_profile_name: envProfileName,\n      remote_path: remotePath,\n      overwrite,\n      variables: { count: bundle.variable_keys.length, keys: bundle.variable_keys },\n    };\n\n    if (keptBackupPath) {\n      response.backup_path = keptBackupPath;\n    }\n\n    return response;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 1159,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 410,
        "end_line": 449,
        "content": "async runRemote(args) {\n    const envProfileName = await this.resolveEnvProfileName(args);\n    const sshProfileName = await this.resolveSshProfileName(args);\n    const command = this.validation.ensureString(args.command, 'command', { trim: false });\n\n    const defaults = !args.cwd ? await this.resolveProfilesFromProject(args) : null;\n    const cwd = args.cwd !== undefined\n      ? args.cwd\n      : (defaults?.cwd ? String(defaults.cwd) : undefined);\n\n    const bundle = await this.loadEnvBundle(envProfileName);\n    const resolvedVars = await this.secretRefResolver.resolveDeep(bundle.variables, args);\n    const env = Object.fromEntries(\n      Object.entries(resolvedVars).map(([key, value]) => [normalizeEnvKey(key), String(value ?? '')])\n    );\n\n    const result = await this.sshManager.execCommand({\n      profile_name: sshProfileName,\n      command,\n      cwd,\n      env,\n      stdin: args.stdin,\n      timeout_ms: args.timeout_ms,\n      pty: args.pty,\n    });\n\n    return {\n      success: result.exitCode === 0,\n      ssh_profile_name: sshProfileName,\n      env_profile_name: envProfileName,\n      variables: { count: bundle.variable_keys.length, keys: bundle.variable_keys },\n      command: result.command,\n      stdout: result.stdout,\n      stderr: result.stderr,\n      exitCode: result.exitCode,\n      signal: result.signal,\n      timedOut: result.timedOut,\n      duration_ms: result.duration_ms,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 356,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 451,
        "end_line": 453,
        "content": "getStats() {\n    return {};\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 9,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EnvManager.ts",
        "start_line": 455,
        "end_line": 457,
        "content": "async cleanup() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EnvManager",
          "estimated_tokens": 10,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/EvidenceManager.ts": [
      {
        "file_path": "src/managers/EvidenceManager.ts",
        "start_line": 9,
        "end_line": 14,
        "content": "constructor(logger, security, validation, evidenceService) {\n    this.logger = logger.child('evidence');\n    this.security = security;\n    this.validation = validation;\n    this.evidenceService = evidenceService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceManager",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EvidenceManager.ts",
        "start_line": 16,
        "end_line": 26,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n    switch (action) {\n      case 'list':\n        return this.list(args);\n      case 'get':\n        return this.get(args);\n      default:\n        throw new Error(`Unknown evidence action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceManager",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EvidenceManager.ts",
        "start_line": 28,
        "end_line": 32,
        "content": "async list(args) {\n    const limit = args.limit ? Number(args.limit) : 20;\n    const entries = await this.evidenceService.listEvidence(limit);\n    return { success: true, evidence: entries };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceManager",
          "estimated_tokens": 51,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/EvidenceManager.ts",
        "start_line": 34,
        "end_line": 38,
        "content": "async get(args) {\n    const id = this.validation.ensureString(args.id, 'Evidence id');\n    const payload = await this.evidenceService.getEvidence(id);\n    return { success: true, ...payload };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceManager",
          "estimated_tokens": 52,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/IntentManager.ts": [
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 14,
        "end_line": 30,
        "content": "function getByPath(source, path) {\n  if (!path) {\n    return undefined;\n  }\n  const parts = String(path).split('.').filter(Boolean);\n  let current = source;\n  for (const part of parts) {\n    if (!current || typeof current !== 'object' || Array.isArray(current)) {\n      return undefined;\n    }\n    if (!Object.prototype.hasOwnProperty.call(current, part)) {\n      return undefined;\n    }\n    current = current[part];\n  }\n  return current;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "getByPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 110,
          "qualified_name": "getByPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 32,
        "end_line": 48,
        "content": "function redactObject(value) {\n  if (Array.isArray(value)) {\n    return value.map((entry) => redactObject(entry));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, entry] of Object.entries(value)) {\n      if (SECRET_FIELD_PATTERN.test(key)) {\n        result[key] = '***';\n      } else {\n        result[key] = redactObject(entry);\n      }\n    }\n    return result;\n  }\n  return value;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "redactObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 106,
          "qualified_name": "redactObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 50,
        "end_line": 75,
        "content": "function normalizeInputs(intentInputs, capability) {\n  const inputs = intentInputs || {};\n  const defaults = capability.inputs?.defaults || {};\n  const map = capability.inputs?.map || {};\n  const passThrough = capability.inputs?.pass_through !== false;\n  const resolved = { ...defaults };\n\n  for (const [target, source] of Object.entries(map)) {\n    const value = getByPath(inputs, source);\n    if (value !== undefined) {\n      resolved[target] = value;\n    }\n  }\n\n  if (passThrough) {\n    for (const [key, value] of Object.entries(inputs)) {\n      if (value !== undefined) {\n        resolved[key] = value;\n      }\n    }\n  }\n\n  const required = capability.inputs?.required || [];\n  const missing = required.filter((key) => resolved[key] === undefined || resolved[key] === null || resolved[key] === '');\n  return { resolved, missing };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeInputs",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 209,
          "qualified_name": "normalizeInputs",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 77,
        "end_line": 92,
        "content": "function aggregateEffects(steps) {\n  let requiresApply = false;\n  let kind = 'read';\n  for (const step of steps) {\n    const effect = step.effects || {};\n    if (effect.requires_apply || effect.kind === 'write' || effect.kind === 'mixed') {\n      requiresApply = true;\n    }\n    if (effect.kind === 'mixed') {\n      kind = 'mixed';\n    } else if (effect.kind === 'write' && kind !== 'mixed') {\n      kind = 'write';\n    }\n  }\n  return { kind, requires_apply: requiresApply };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "aggregateEffects",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 119,
          "qualified_name": "aggregateEffects",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 95,
        "end_line": 115,
        "content": "constructor(\n    logger,\n    security,\n    validation,\n    capabilityService,\n    runbookManager,\n    evidenceService,\n    projectResolver,\n    contextService,\n    policyService\n  ) {\n    this.logger = logger.child('intent');\n    this.security = security;\n    this.validation = validation;\n    this.capabilityService = capabilityService;\n    this.runbookManager = runbookManager;\n    this.evidenceService = evidenceService;\n    this.projectResolver = projectResolver;\n    this.contextService = contextService;\n    this.policyService = policyService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 141,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 117,
        "end_line": 135,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n    switch (action) {\n      case 'compile':\n        return this.compile(args);\n      case 'dry_run':\n        return this.execute(args, { dryRun: true });\n      case 'execute':\n        return this.execute(args, { dryRun: false });\n      case 'explain':\n        return this.explain(args);\n      default:\n        throw ToolError.invalidParams({\n          message: `Unknown intent action: ${action}`,\n          field: 'action',\n          hint: 'Use one of: compile, dry_run, execute, explain.',\n        });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 146,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 137,
        "end_line": 140,
        "content": "async compile(args) {\n    const { plan, missing } = await this.buildPlan(args, { allowMissing: true });\n    return { success: true, plan, missing };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 41,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 142,
        "end_line": 153,
        "content": "async explain(args) {\n    const intent = await this.normalizeIntent(args);\n    const capability = await this.resolveCapability(intent.type, intent.context || intent.inputs.context);\n    const { resolved, missing } = normalizeInputs(intent.inputs, capability);\n    return {\n      success: true,\n      intent: { type: intent.type, inputs: redactObject(intent.inputs) },\n      capability,\n      inputs: resolved,\n      missing,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 111,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 155,
        "end_line": 281,
        "content": "async execute(args, { dryRun }) {\n    const { plan, missing } = await this.buildPlan(args, { allowMissing: false });\n    if (missing.length > 0) {\n      throw ToolError.invalidParams({\n        code: 'MISSING_INPUTS',\n        message: `Missing required inputs: ${missing.join(', ')}`,\n        hint: 'Provide the missing intent inputs and retry.',\n        details: { missing },\n      });\n    }\n\n    if (dryRun) {\n      return {\n        success: true,\n        dry_run: true,\n        plan,\n        preview: plan.steps.map((step) => ({\n          capability: step.capability,\n          runbook: step.runbook,\n          inputs: redactObject(step.inputs),\n        })),\n        missing,\n      };\n    }\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const apply = Boolean(args.apply || plan.intent.apply);\n    if (plan.effects.requires_apply && !apply) {\n      throw ToolError.denied({\n        code: 'APPLY_REQUIRED',\n        message: 'Intent requires apply=true for write/mixed effects',\n        hint: 'Rerun with apply=true if you intend to perform write operations.',\n      });\n    }\n\n    const isGitOpsWrite = apply\n      && plan.effects.requires_apply\n      && typeof plan.intent.type === 'string'\n      && plan.intent.type.startsWith('gitops.');\n\n    let policyGuard = null;\n    if (isGitOpsWrite && this.policyService) {\n      const repoRoot = args.repo_root || plan.intent.inputs?.repo_root || plan.intent.inputs?.context?.root;\n      const projectName = plan.intent.project || plan.intent.inputs?.context?.project_name;\n      const targetName = plan.intent.target || plan.intent.inputs?.context?.target_name;\n      const projectContext = plan.intent.project_context || null;\n\n      policyGuard = await this.policyService.guardGitOpsWrite({\n        intentType: plan.intent.type,\n        inputs: plan.intent.inputs,\n        traceId,\n        projectName,\n        targetName,\n        repoRoot,\n        projectContext,\n      });\n    } else if (isGitOpsWrite && !this.policyService) {\n      throw ToolError.internal({\n        code: 'POLICY_SERVICE_UNAVAILABLE',\n        message: 'Policy service is not available for GitOps write intents',\n        hint: 'This is a server configuration error. Enable PolicyService or disable GitOps write intents.',\n      });\n    }\n\n    const stopOnError = args.stop_on_error !== false;\n    const results = [];\n    let success = true;\n\n    try {\n      for (const step of plan.steps) {\n        const result = await this.runbookManager.handleAction({\n          action: 'runbook_run',\n          name: step.runbook,\n          input: step.inputs,\n          stop_on_error: stopOnError,\n          template_missing: args.template_missing,\n          trace_id: traceId,\n          span_id: args.span_id,\n          parent_span_id: args.parent_span_id,\n        });\n        results.push({\n          capability: step.capability,\n          runbook: step.runbook,\n          result,\n        });\n        if (!result.success && stopOnError) {\n          success = false;\n          break;\n        }\n        if (!result.success) {\n          success = false;\n        }\n      }\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n\n    const evidence = {\n      intent: redactObject(plan.intent),\n      effects: plan.effects,\n      dry_run: false,\n      executed_at: new Date().toISOString(),\n      steps: results,\n      success,\n    };\n\n    let evidencePath;\n    if (args.save_evidence) {\n      const saved = await this.evidenceService.saveEvidence(evidence);\n      evidencePath = saved.path;\n    }\n\n    return {\n      success,\n      dry_run: false,\n      plan,\n      results,\n      evidence,\n      evidence_path: evidencePath,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 961,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 283,
        "end_line": 366,
        "content": "async normalizeIntent(args) {\n    const intent = this.validation.ensureObject(args.intent, 'Intent');\n    const type = this.validation.ensureString(intent.type, 'Intent type');\n    const inputs = { ...(this.validation.ensureOptionalObject(intent.inputs, 'Intent inputs') || {}) };\n    const apply = Boolean(args.apply ?? intent.apply);\n    let project = this.validation.ensureOptionalString(args.project ?? intent.project, 'Project');\n    let target = this.validation.ensureOptionalString(args.target ?? intent.target, 'Target');\n    let context = null;\n    let projectContext = null;\n\n    const resolveFromInputs = (value, label) => {\n      if (value === undefined || value === null) {\n        return undefined;\n      }\n      if (typeof value !== 'string') {\n        return this.validation.ensureOptionalString(String(value), label);\n      }\n      const trimmed = value.trim();\n      if (!trimmed) {\n        return undefined;\n      }\n      return this.validation.ensureOptionalString(trimmed, label);\n    };\n\n    if (!project) {\n      project = resolveFromInputs(inputs.project_name, 'Project') || project;\n    }\n    if (!target) {\n      target = resolveFromInputs(inputs.target_name, 'Target') || target;\n    }\n\n    if (this.projectResolver) {\n      projectContext = await this.projectResolver.resolveContext({ ...args, project, target }).catch(() => null);\n      context = projectContext;\n      if (!project && projectContext?.projectName) {\n        project = projectContext.projectName;\n      }\n      if (!target && projectContext?.targetName) {\n        target = projectContext.targetName;\n      }\n      if (projectContext?.project && inputs.project === undefined) {\n        inputs.project = projectContext.project;\n      }\n      if (projectContext?.target && inputs.target === undefined) {\n        inputs.target = projectContext.target;\n      }\n    }\n\n    if (project && inputs.project_name === undefined) {\n      inputs.project_name = project;\n    }\n    if (target && inputs.target_name === undefined) {\n      inputs.target_name = target;\n    }\n\n    if (this.contextService && inputs.context === undefined) {\n      const contextArgs = {\n        project,\n        target,\n        cwd: args.cwd ?? intent.cwd,\n        repo_root: args.repo_root ?? intent.repo_root,\n        key: args.context_key,\n        refresh: args.context_refresh === true,\n      };\n      const contextResult = await this.contextService.getContext(contextArgs).catch((error) => {\n        this.logger.warn('Context resolution failed', { error: error.message });\n        return null;\n      });\n      if (contextResult?.context) {\n        inputs.context = contextResult.context;\n        context = contextResult.context;\n      }\n    }\n\n    return {\n      type,\n      inputs,\n      apply,\n      project,\n      target,\n      context,\n      project_context: projectContext,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 715,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 368,
        "end_line": 406,
        "content": "async resolveCapability(intentType, context) {\n    const candidates = await this.capabilityService.findAllByIntent(intentType);\n    if (!candidates || candidates.length === 0) {\n      throw ToolError.notFound({\n        code: 'CAPABILITY_NOT_FOUND',\n        message: `Capability for intent '${intentType}' not found`,\n        hint: 'Check capabilities.json (or configure capability mappings) and retry.',\n        details: { intent_type: intentType },\n      });\n    }\n\n    const resolvedContext = context && typeof context === 'object' ? context : {};\n    const matched = [];\n    for (const candidate of candidates) {\n      if (await matchesWhen(candidate.when, resolvedContext)) {\n        matched.push(candidate);\n      }\n    }\n\n    if (matched.length === 0) {\n      throw ToolError.notFound({\n        code: 'CAPABILITY_NOT_MATCHED',\n        message: `No capability matched when-clause for intent '${intentType}'`,\n        hint: 'Provide the required context inputs (project/target/repo_root/etc) or adjust capability.when clauses.',\n        details: { intent_type: intentType },\n      });\n    }\n\n    matched.sort((a, b) => {\n      const aIsDirect = a.name === intentType ? 0 : 1;\n      const bIsDirect = b.name === intentType ? 0 : 1;\n      if (aIsDirect !== bIsDirect) {\n        return aIsDirect - bIsDirect;\n      }\n      return String(a.name).localeCompare(String(b.name));\n    });\n\n    return matched[0];\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 356,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 408,
        "end_line": 452,
        "content": "async buildPlan(args, { allowMissing }) {\n    const intent = await this.normalizeIntent(args);\n    const root = await this.resolveCapability(intent.type, intent.context || intent.inputs.context);\n    const ordered = await this.resolveDependencies(root.name);\n    const steps = [];\n    const missing = [];\n    const projectContext = intent.project_context || null;\n\n    for (const capability of ordered) {\n      const { resolved, missing: missingInputs } = normalizeInputs(intent.inputs, capability);\n      resolved.apply = intent.apply;\n      if (this.policyService) {\n        const policy = this.policyService.resolvePolicy(resolved, projectContext);\n        if (policy) {\n          resolved.policy = policy;\n        }\n      }\n      steps.push({\n        capability: capability.name,\n        runbook: capability.runbook,\n        inputs: resolved,\n        effects: capability.effects,\n      });\n      if (missingInputs.length > 0) {\n        missing.push(...missingInputs.map((key) => `${capability.name}.${key}`));\n      }\n    }\n\n    if (!allowMissing && missing.length > 0) {\n      throw ToolError.invalidParams({\n        code: 'MISSING_INPUTS',\n        message: `Missing required inputs: ${missing.join(', ')}`,\n        hint: 'Provide the missing intent inputs and retry.',\n        details: { missing },\n      });\n    }\n\n    const plan = {\n      intent,\n      steps,\n      effects: aggregateEffects(steps),\n    };\n    this.security.ensureSizeFits(JSON.stringify(plan));\n    return { plan, missing };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 379,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/IntentManager.ts",
        "start_line": 454,
        "end_line": 484,
        "content": "async resolveDependencies(rootName) {\n    const ordered = [];\n    const visiting = new Set();\n    const visited = new Set();\n\n    const visit = async (name) => {\n      if (visited.has(name)) {\n        return;\n      }\n      if (visiting.has(name)) {\n        throw ToolError.internal({\n          code: 'CAPABILITY_DEP_CYCLE',\n          message: `Capability dependency cycle at '${name}'`,\n          hint: 'Fix capability.depends_on to remove cycles.',\n          details: { capability: name },\n        });\n      }\n      visiting.add(name);\n      const capability = await this.capabilityService.getCapability(name);\n      const deps = Array.isArray(capability.depends_on) ? capability.depends_on : [];\n      for (const dep of deps) {\n        await visit(dep);\n      }\n      visiting.delete(name);\n      visited.add(name);\n      ordered.push(capability);\n    };\n\n    await visit(rootName);\n    return ordered;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "IntentManager",
          "estimated_tokens": 230,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/JobManager.ts": [
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 6,
        "end_line": 15,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numberValue = Number(value);\n  if (!Number.isFinite(numberValue) || numberValue <= 0) {\n    return null;\n  }\n  return Math.floor(numberValue);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 67,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 17,
        "end_line": 19,
        "content": "function nowIso() {\n  return new Date().toISOString();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "nowIso",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 14,
          "qualified_name": "nowIso",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 21,
        "end_line": 42,
        "content": "function publicJobView(job) {\n  if (!job || typeof job !== 'object') {\n    return null;\n  }\n  const expires = job.expires_at_ms ? new Date(job.expires_at_ms).toISOString() : null;\n  return {\n    job_id: job.job_id,\n    kind: job.kind,\n    status: job.status,\n    trace_id: job.trace_id,\n    parent_span_id: job.parent_span_id,\n    created_at: job.created_at,\n    started_at: job.started_at,\n    updated_at: job.updated_at,\n    ended_at: job.ended_at,\n    expires_at: expires,\n    progress: job.progress ?? null,\n    artifacts: job.artifacts ?? null,\n    provider: job.provider ?? null,\n    error: job.error ?? null,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "publicJobView",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 155,
          "qualified_name": "publicJobView",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 45,
        "end_line": 50,
        "content": "constructor(logger, validation, jobService, { sshManager } = {}) {\n    this.logger = logger.child('job');\n    this.validation = validation;\n    this.jobService = jobService;\n    this.sshManager = sshManager || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 56,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 52,
        "end_line": 60,
        "content": "ensureJobId(value) {\n    if (this.validation?.ensureString) {\n      return this.validation.ensureString(value, 'job_id');\n    }\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw ToolError.invalidParams({ field: 'job_id', message: 'job_id must be a non-empty string' });\n    }\n    return value.trim();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 85,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 62,
        "end_line": 84,
        "content": "async handleAction(args = {}) {\n    const action = args.action;\n    switch (action) {\n      case 'job_status':\n        return this.jobStatus(args);\n      case 'job_wait':\n        return this.jobWait(args);\n      case 'job_logs_tail':\n        return this.jobLogsTail(args);\n      case 'job_cancel':\n        return this.jobCancel(args);\n      case 'job_forget':\n        return this.jobForget(args);\n      case 'job_list':\n        return this.jobList(args);\n      default:\n        throw ToolError.invalidParams({\n          field: 'action',\n          message: `Unknown job action: ${action}`,\n          hint: 'Use one of: job_status, job_wait, job_logs_tail, job_cancel, job_forget, job_list.',\n        });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 180,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 86,
        "end_line": 114,
        "content": "async jobStatus(args = {}) {\n    const jobId = this.ensureJobId(args.job_id);\n    const job = this.jobService.get(jobId);\n    if (!job) {\n      return { success: false, code: 'NOT_FOUND', job_id: jobId };\n    }\n\n    const providerTool = job.provider?.tool;\n    if (providerTool === 'mcp_ssh_manager') {\n      if (!this.sshManager) {\n        throw ToolError.internal({ code: 'SSH_MANAGER_UNAVAILABLE', message: 'SSH manager is not available' });\n      }\n      const status = await this.sshManager.jobStatus({ ...args, job_id: jobId });\n      if (status.success) {\n        const nextStatus = status.exited\n          ? (status.exit_code === 0 ? 'succeeded' : 'failed')\n          : 'running';\n        this.jobService.upsert({\n          job_id: jobId,\n          status: nextStatus,\n          started_at: job.started_at || job.created_at,\n          ended_at: status.exited ? (job.ended_at || nowIso()) : null,\n        });\n      }\n      return { success: true, job: publicJobView(this.jobService.get(jobId)), status };\n    }\n\n    return { success: false, code: 'NOT_SUPPORTED', job_id: jobId, kind: job.kind };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 278,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 116,
        "end_line": 163,
        "content": "async jobWait(args = {}) {\n    const jobId = this.ensureJobId(args.job_id);\n    const job = this.jobService.get(jobId);\n    if (!job) {\n      return { success: false, code: 'NOT_FOUND', job_id: jobId };\n    }\n\n    const providerTool = job.provider?.tool;\n    if (providerTool === 'mcp_ssh_manager') {\n      if (!this.sshManager) {\n        throw ToolError.internal({ code: 'SSH_MANAGER_UNAVAILABLE', message: 'SSH manager is not available' });\n      }\n      const wait = await this.sshManager.jobWait({ ...args, job_id: jobId });\n      const status = wait.status;\n      if (status?.success && status.exited) {\n        const nextStatus = status.exit_code === 0 ? 'succeeded' : 'failed';\n        this.jobService.upsert({ job_id: jobId, status: nextStatus, ended_at: job.ended_at || nowIso() });\n      }\n      return { success: true, job: publicJobView(this.jobService.get(jobId)), wait };\n    }\n\n    const budgetMs = readPositiveInt(process.env.SENTRYFROGG_TOOL_CALL_TIMEOUT_MS || process.env.SF_TOOL_CALL_TIMEOUT_MS) ?? 55_000;\n    const requested = readPositiveInt(args.timeout_ms) ?? 30_000;\n    const timeoutMs = Math.min(requested, budgetMs);\n    const pollMs = Math.min(readPositiveInt(args.poll_interval_ms) ?? 1000, 5000);\n    const started = Date.now();\n\n    while (Date.now() - started + pollMs <= timeoutMs) {\n      const current = this.jobService.get(jobId);\n      if (!current) {\n        return { success: false, code: 'NOT_FOUND', job_id: jobId };\n      }\n      if (current.status === 'succeeded' || current.status === 'failed' || current.status === 'canceled') {\n        return {\n          success: true,\n          job: publicJobView(current),\n          wait: { completed: true, timed_out: false, waited_ms: Date.now() - started, timeout_ms: timeoutMs, poll_interval_ms: pollMs },\n        };\n      }\n      await new Promise((resolve) => setTimeout(resolve, pollMs));\n    }\n\n    return {\n      success: true,\n      job: publicJobView(this.jobService.get(jobId)),\n      wait: { completed: false, timed_out: true, waited_ms: Date.now() - started, timeout_ms: timeoutMs, poll_interval_ms: pollMs },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 531,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 165,
        "end_line": 182,
        "content": "async jobLogsTail(args = {}) {\n    const jobId = this.ensureJobId(args.job_id);\n    const job = this.jobService.get(jobId);\n    if (!job) {\n      return { success: false, code: 'NOT_FOUND', job_id: jobId };\n    }\n\n    const providerTool = job.provider?.tool;\n    if (providerTool === 'mcp_ssh_manager') {\n      if (!this.sshManager) {\n        throw ToolError.internal({ code: 'SSH_MANAGER_UNAVAILABLE', message: 'SSH manager is not available' });\n      }\n      const logs = await this.sshManager.jobLogsTail({ ...args, job_id: jobId, lines: args.lines });\n      return { success: true, job: publicJobView(job), logs };\n    }\n\n    return { success: false, code: 'NOT_SUPPORTED', job_id: jobId, kind: job.kind };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 180,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 184,
        "end_line": 206,
        "content": "async jobCancel(args = {}) {\n    const jobId = this.ensureJobId(args.job_id);\n    const job = this.jobService.get(jobId);\n    if (!job) {\n      return { success: false, code: 'NOT_FOUND', job_id: jobId };\n    }\n\n    const providerTool = job.provider?.tool;\n    if (providerTool === 'mcp_ssh_manager') {\n      if (!this.sshManager) {\n        throw ToolError.internal({ code: 'SSH_MANAGER_UNAVAILABLE', message: 'SSH manager is not available' });\n      }\n      const killed = await this.sshManager.jobKill({ ...args, job_id: jobId });\n      if (!killed.success) {\n        return killed;\n      }\n      this.jobService.cancel(jobId, 'remote_kill');\n      return { success: true, job: publicJobView(this.jobService.get(jobId)), killed };\n    }\n\n    const canceled = this.jobService.cancel(jobId, 'cancel');\n    return { success: true, job: publicJobView(canceled) };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 218,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 208,
        "end_line": 212,
        "content": "async jobForget(args = {}) {\n    const jobId = this.ensureJobId(args.job_id);\n    const removed = this.jobService.forget(jobId);\n    return { success: true, job_id: jobId, removed };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 48,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/JobManager.ts",
        "start_line": 214,
        "end_line": 217,
        "content": "async jobList(args = {}) {\n    const jobs = this.jobService.list({ limit: args.limit, status: args.status });\n    return { success: true, jobs: jobs.map(publicJobView), count: jobs.length };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobManager",
          "estimated_tokens": 50,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/LocalManager.ts": [
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 25,
        "end_line": 27,
        "content": "function buildTempDir() {\n  return path.join(os.tmpdir(), `sentryfrogg-local-${process.pid}`);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 24,
          "qualified_name": "buildTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 29,
        "end_line": 31,
        "content": "function randomToken() {\n  return crypto.randomBytes(6).toString('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "randomToken",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 18,
          "qualified_name": "randomToken",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 34,
        "end_line": 43,
        "content": "constructor(logger, validation, options = {}) {\n    this.logger = logger.child('local');\n    this.validation = validation;\n    this.enabled = options.enabled ?? isUnsafeLocalEnabled();\n    this.stats = {\n      exec: 0,\n      fs_ops: 0,\n      errors: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 45,
        "end_line": 49,
        "content": "ensureEnabled() {\n    if (!this.enabled) {\n      throw new Error('Unsafe local tool is disabled. Set SENTRYFROGG_UNSAFE_LOCAL=1 to enable it.');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 41,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 51,
        "end_line": 76,
        "content": "async handleAction(args = {}) {\n    this.ensureEnabled();\n\n    const { action } = args;\n\n    switch (action) {\n      case 'exec':\n        return this.exec(args);\n      case 'batch':\n        return this.batch(args);\n      case 'fs_read':\n        return this.fsRead(args);\n      case 'fs_write':\n        return this.fsWrite(args);\n      case 'fs_list':\n        return this.fsList(args);\n      case 'fs_stat':\n        return this.fsStat(args);\n      case 'fs_mkdir':\n        return this.fsMkdir(args);\n      case 'fs_rm':\n        return this.fsRm(args);\n      default:\n        throw new Error(`Unknown local action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 161,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 78,
        "end_line": 96,
        "content": "normalizeEnv(env) {\n    if (env === undefined || env === null) {\n      return undefined;\n    }\n    if (typeof env !== 'object' || Array.isArray(env)) {\n      throw new Error('env must be an object');\n    }\n    return Object.fromEntries(\n      Object.entries(env).flatMap(([key, value]) => {\n        if (!key || typeof key !== 'string') {\n          return [];\n        }\n        if (value === undefined || value === null) {\n          return [];\n        }\n        return [[key, String(value)]];\n      })\n    );\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 130,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 98,
        "end_line": 217,
        "content": "async exec(args) {\n    const command = this.validation.ensureString(args.command, 'command', { trim: false });\n    const argv = Array.isArray(args.args) ? args.args.map((item) => String(item)) : null;\n    const cwd = args.cwd ? this.validation.ensureString(args.cwd, 'cwd', { trim: false }) : undefined;\n    const timeoutMs = args.timeout_ms;\n    const stdin = args.stdin;\n    const inline = args.inline === true;\n\n    const shell = args.shell !== undefined\n      ? args.shell\n      : !argv;\n\n    const env = {\n      ...process.env,\n      ...(this.normalizeEnv(args.env) || {}),\n    };\n\n    const started = Date.now();\n    const tempDir = buildTempDir();\n    await fs.mkdir(tempDir, { recursive: true, mode: 0o700 });\n\n    const token = `${Date.now()}-${randomToken()}`;\n    const stdoutPath = path.join(tempDir, `stdout-${token}.log`);\n    const stderrPath = path.join(tempDir, `stderr-${token}.log`);\n    const stdoutStream = createWriteStream(stdoutPath, { mode: 0o600 });\n    const stderrStream = createWriteStream(stderrPath, { mode: 0o600 });\n    const stdoutClosed = once(stdoutStream, 'close');\n    const stderrClosed = once(stderrStream, 'close');\n\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      let timedOut = false;\n\n      const child = argv\n        ? spawn(command, argv, { cwd, env, shell: false })\n        : spawn(command, { cwd, env, shell: shell === true ? true : shell });\n\n      let timeout;\n      if (timeoutMs) {\n        timeout = setTimeout(() => {\n          timedOut = true;\n          try {\n            child.kill('SIGKILL');\n          } catch (error) {\n          }\n        }, timeoutMs);\n      }\n\n      const finalize = async (result) => {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        stdoutStream.end();\n        stderrStream.end();\n        await Promise.allSettled([stdoutClosed, stderrClosed]);\n\n        const outStat = await fs.stat(stdoutPath).catch(() => null);\n        const errStat = await fs.stat(stderrPath).catch(() => null);\n\n        const payload = {\n          success: result.exit_code === 0,\n          command,\n          args: argv || undefined,\n          cwd,\n          exit_code: result.exit_code,\n          signal: result.signal,\n          timed_out: timedOut,\n          duration_ms: Date.now() - started,\n          stdout_path: stdoutPath,\n          stderr_path: stderrPath,\n          stdout_bytes: outStat?.size ?? 0,\n          stderr_bytes: errStat?.size ?? 0,\n        };\n\n        if (inline) {\n          const stdout = await fs.readFile(stdoutPath, 'utf8').catch(() => '');\n          const stderr = await fs.readFile(stderrPath, 'utf8').catch(() => '');\n          payload.stdout = stdout.trimEnd();\n          payload.stderr = stderr.trimEnd();\n        }\n\n        this.stats.exec += 1;\n        resolve(payload);\n      };\n\n      child.on('error', async (error) => {\n        this.stats.errors += 1;\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        stdoutStream.end();\n        stderrStream.end();\n        await Promise.allSettled([stdoutClosed, stderrClosed]);\n        await fs.unlink(stdoutPath).catch(() => null);\n        await fs.unlink(stderrPath).catch(() => null);\n        reject(error);\n      });\n\n      child.on('close', (code, signal) => {\n        finalize({ exit_code: typeof code === 'number' ? code : 1, signal }).catch(reject);\n      });\n\n      if (child.stdout) {\n        child.stdout.pipe(stdoutStream);\n      }\n      if (child.stderr) {\n        child.stderr.pipe(stderrStream);\n      }\n\n      if (stdin !== undefined && stdin !== null) {\n        child.stdin?.end(String(stdin));\n      } else {\n        child.stdin?.end();\n      }\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 943,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 219,
        "end_line": 252,
        "content": "async batch(args) {\n    const commands = Array.isArray(args.commands) ? args.commands : [];\n    if (commands.length === 0) {\n      throw new Error('commands must be a non-empty array');\n    }\n\n    const parallel = !!args.parallel;\n    const stopOnError = args.stop_on_error !== false;\n\n    if (parallel) {\n      const results = await Promise.all(\n        commands.map((command) => this.exec({ ...args, ...command }))\n      );\n      return { success: results.every((item) => item.exit_code === 0), results };\n    }\n\n    const results = [];\n    for (const command of commands) {\n      try {\n        const result = await this.exec({ ...args, ...command });\n        results.push(result);\n        if (stopOnError && result.exit_code !== 0) {\n          break;\n        }\n      } catch (error) {\n        results.push({ success: false, command: command.command, error: error.message });\n        if (stopOnError) {\n          break;\n        }\n      }\n    }\n\n    return { success: results.every((item) => item.exit_code === 0), results };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 260,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 254,
        "end_line": 299,
        "content": "async fsRead(args) {\n    const filePath = expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false }));\n    const encoding = args.encoding ? String(args.encoding).toLowerCase() : 'utf8';\n    const offset = Number.isInteger(args.offset) ? Math.max(0, args.offset) : 0;\n    const length = Number.isInteger(args.length) ? Math.max(0, args.length) : null;\n\n    let data;\n    if (offset || length !== null) {\n      const handle = await fs.open(filePath, 'r');\n      try {\n        const stat = await handle.stat();\n        const maxLen = length === null ? stat.size - offset : length;\n        const buffer = Buffer.alloc(Math.max(0, maxLen));\n        const { bytesRead } = await handle.read(buffer, 0, buffer.length, offset);\n        data = buffer.subarray(0, bytesRead);\n      } finally {\n        await handle.close();\n      }\n    } else {\n      data = await fs.readFile(filePath);\n    }\n\n    this.stats.fs_ops += 1;\n\n    if (encoding === 'base64') {\n      return {\n        success: true,\n        path: filePath,\n        encoding: 'base64',\n        offset,\n        length: length ?? undefined,\n        bytes: data.length,\n        content: data.toString('base64'),\n      };\n    }\n\n    return {\n      success: true,\n      path: filePath,\n      encoding: 'utf8',\n      offset,\n      length: length ?? undefined,\n      bytes: data.length,\n      content: data.toString('utf8'),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 352,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 301,
        "end_line": 340,
        "content": "async fsWrite(args) {\n    const filePath = expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false }));\n    const overwrite = args.overwrite === true;\n\n    if (!overwrite && await pathExists(filePath)) {\n      throw new Error(`Local path already exists: ${filePath}`);\n    }\n\n    const mode = args.mode !== undefined ? Number(args.mode) : 0o600;\n    const encoding = args.encoding ? String(args.encoding).toLowerCase() : 'utf8';\n\n    const tmpPath = tempSiblingPath(filePath, '.part');\n\n    try {\n      await ensureDirForFile(filePath, 0o700);\n\n      if (args.content_base64 !== undefined && args.content_base64 !== null) {\n        const buffer = Buffer.from(String(args.content_base64), 'base64');\n        await fs.writeFile(tmpPath, buffer, { mode });\n      } else if (args.content !== undefined && args.content !== null) {\n        if (encoding === 'base64') {\n          const buffer = Buffer.from(String(args.content), 'base64');\n          await fs.writeFile(tmpPath, buffer, { mode });\n        } else {\n          await fs.writeFile(tmpPath, String(args.content), { encoding: 'utf8', mode });\n        }\n      } else {\n        throw new Error('content or content_base64 is required');\n      }\n\n      await atomicReplaceFile(tmpPath, filePath, { overwrite, mode });\n      this.stats.fs_ops += 1;\n\n      return { success: true, path: filePath, bytes_written: (await fs.stat(filePath)).size };\n    } catch (error) {\n      await fs.unlink(tmpPath).catch(() => null);\n      this.stats.errors += 1;\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 389,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 342,
        "end_line": 386,
        "content": "async fsList(args) {\n    const root = args.path ? expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false })) : '.';\n    const recursive = args.recursive === true;\n    const maxDepth = Number.isInteger(args.max_depth) ? Math.max(0, args.max_depth) : 3;\n    const withStats = args.with_stats === true;\n\n    const entries = [];\n\n    const walk = async (currentPath, depth) => {\n      const list = await fs.readdir(currentPath, { withFileTypes: true });\n      for (const entry of list) {\n        const fullPath = path.join(currentPath, entry.name);\n        const item = {\n          path: fullPath,\n          name: entry.name,\n          type: entry.isDirectory()\n            ? 'dir'\n            : entry.isFile()\n              ? 'file'\n              : entry.isSymbolicLink()\n                ? 'link'\n                : 'other',\n        };\n\n        if (withStats) {\n          const stat = await fs.lstat(fullPath).catch(() => null);\n          if (stat) {\n            item.size = stat.size;\n            item.mtime_ms = stat.mtimeMs;\n          }\n        }\n\n        entries.push(item);\n\n        if (recursive && entry.isDirectory() && depth < maxDepth) {\n          await walk(fullPath, depth + 1);\n        }\n      }\n    };\n\n    await walk(root, 0);\n    this.stats.fs_ops += 1;\n\n    return { success: true, path: root, entries };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 338,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 388,
        "end_line": 406,
        "content": "async fsStat(args) {\n    const target = expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false }));\n    const stat = await fs.lstat(target);\n    this.stats.fs_ops += 1;\n    return {\n      success: true,\n      path: target,\n      type: stat.isDirectory()\n        ? 'dir'\n        : stat.isFile()\n          ? 'file'\n          : stat.isSymbolicLink()\n            ? 'link'\n            : 'other',\n      size: stat.size,\n      mode: stat.mode,\n      mtime_ms: stat.mtimeMs,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 127,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 408,
        "end_line": 414,
        "content": "async fsMkdir(args) {\n    const target = expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false }));\n    const recursive = args.recursive !== false;\n    await fs.mkdir(target, { recursive, mode: 0o700 });\n    this.stats.fs_ops += 1;\n    return { success: true, path: target, recursive };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 81,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 416,
        "end_line": 423,
        "content": "async fsRm(args) {\n    const target = expandHomePath(this.validation.ensureString(args.path, 'path', { trim: false }));\n    const recursive = args.recursive === true;\n    const force = args.force === true;\n    await fs.rm(target, { recursive, force });\n    this.stats.fs_ops += 1;\n    return { success: true, path: target, recursive, force };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 89,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 425,
        "end_line": 427,
        "content": "getStats() {\n    return { ...this.stats };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/LocalManager.ts",
        "start_line": 429,
        "end_line": 431,
        "content": "async cleanup() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "LocalManager",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/PipelineManager.ts": [
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 23,
        "end_line": 32,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return null;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 34,
        "end_line": 53,
        "content": "function resolveStreamToArtifactMode() {\n  const raw = process.env.SENTRYFROGG_PIPELINE_STREAM_TO_ARTIFACT\n    || process.env.SF_PIPELINE_STREAM_TO_ARTIFACT\n    || process.env.SENTRYFROGG_STREAM_TO_ARTIFACT\n    || process.env.SF_STREAM_TO_ARTIFACT;\n  if (raw === undefined || raw === null) {\n    return null;\n  }\n  const normalized = String(raw).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n  if (normalized === 'full') {\n    return 'full';\n  }\n  if (normalized === 'capped') {\n    return 'capped';\n  }\n  return isTruthy(normalized) ? 'capped' : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveStreamToArtifactMode",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 143,
          "qualified_name": "resolveStreamToArtifactMode",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 55,
        "end_line": 63,
        "content": "function resolveMaxCaptureBytes() {\n  const fromEnv = readPositiveInt(\n    process.env.SENTRYFROGG_PIPELINE_MAX_CAPTURE_BYTES\n    || process.env.SF_PIPELINE_MAX_CAPTURE_BYTES\n    || process.env.SENTRYFROGG_MAX_CAPTURE_BYTES\n    || process.env.SF_MAX_CAPTURE_BYTES\n  );\n  return fromEnv ?? DEFAULT_MAX_CAPTURE_BYTES;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveMaxCaptureBytes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 79,
          "qualified_name": "resolveMaxCaptureBytes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 66,
        "end_line": 75,
        "content": "constructor(writer, { limitBytes, onDone }) {\n    super();\n    this.writer = writer;\n    this.limitBytes = limitBytes;\n    this.totalBytes = 0;\n    this.writtenBytes = 0;\n    this.truncated = false;\n    this.done = false;\n    this.onDone = typeof onDone === 'function' ? onDone : () => null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactCaptureTransform",
          "estimated_tokens": 79,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 77,
        "end_line": 109,
        "content": "_transform(chunk, encoding, callback) {\n    const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk ?? '', encoding);\n    this.totalBytes += buf.length;\n\n    if (this.writer && this.writtenBytes < this.limitBytes) {\n      const remaining = this.limitBytes - this.writtenBytes;\n      const slice = buf.length <= remaining ? buf : buf.subarray(0, remaining);\n      if (slice.length < buf.length) {\n        this.truncated = true;\n      }\n\n      try {\n        const ok = this.writer.stream.write(slice);\n        this.writtenBytes += slice.length;\n        this.push(buf);\n        if (!ok) {\n          this.writer.stream.once('drain', () => callback());\n          return;\n        }\n        callback();\n        return;\n      } catch (error) {\n        void this.writer.abort().catch(() => null);\n        this.writer = null;\n        this.truncated = true;\n      }\n    } else if (this.limitBytes !== Number.POSITIVE_INFINITY) {\n      this.truncated = true;\n    }\n\n    this.push(buf);\n    callback();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactCaptureTransform",
          "estimated_tokens": 256,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 111,
        "end_line": 151,
        "content": "_final(callback) {\n    if (this.done) {\n      callback();\n      return;\n    }\n    this.done = true;\n\n    if (!this.writer || this.writtenBytes === 0) {\n      const cleanup = this.writer ? this.writer.abort().catch(() => null) : Promise.resolve();\n      cleanup\n        .then(() => {\n          this.onDone(null);\n          callback();\n        })\n        .catch(() => {\n          this.onDone(null);\n          callback();\n        });\n      return;\n    }\n\n    this.writer.finalize()\n      .then((artifact) => {\n        this.onDone({\n          uri: artifact.uri,\n          rel: artifact.rel,\n          bytes: artifact.bytes,\n          captured_bytes: this.writtenBytes,\n          total_bytes: this.totalBytes,\n          truncated: this.truncated,\n        });\n        callback();\n      })\n      .catch(() => {\n        this.writer.abort().catch(() => null)\n          .finally(() => {\n            this.onDone(null);\n            callback();\n          });\n      });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactCaptureTransform",
          "estimated_tokens": 245,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 153,
        "end_line": 169,
        "content": "_destroy(error, callback) {\n    if (this.done) {\n      callback(error);\n      return;\n    }\n    this.done = true;\n    if (this.writer) {\n      this.writer.abort().catch(() => null)\n        .finally(() => {\n          this.onDone(null);\n          callback(error);\n        });\n      return;\n    }\n    this.onDone(null);\n    callback(error);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ArtifactCaptureTransform",
          "estimated_tokens": 91,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 173,
        "end_line": 182,
        "content": "constructor(logger, validation, apiManager, sshManager, postgresqlManager, cacheService, auditService, projectResolver) {\n    this.logger = logger.child('pipeline');\n    this.validation = validation;\n    this.apiManager = apiManager;\n    this.sshManager = sshManager;\n    this.postgresqlManager = postgresqlManager;\n    this.cacheService = cacheService;\n    this.auditService = auditService;\n    this.projectResolver = projectResolver;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 112,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 184,
        "end_line": 195,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'run':\n        return this.runPipeline(args);\n      case 'describe':\n        return this.describe();\n      default:\n        throw new Error(`Unknown pipeline action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 73,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 197,
        "end_line": 209,
        "content": "describe() {\n    return {\n      success: true,\n      flows: [\n        'http_to_sftp',\n        'sftp_to_http',\n        'http_to_postgres',\n        'sftp_to_postgres',\n        'postgres_to_sftp',\n        'postgres_to_http',\n      ],\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 63,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 211,
        "end_line": 233,
        "content": "async runPipeline(args) {\n    const flow = String(args.flow || '').toLowerCase();\n    if (!flow) {\n      throw new Error('pipeline flow is required');\n    }\n\n    switch (flow) {\n      case 'http_to_sftp':\n        return this.httpToSftp(args);\n      case 'sftp_to_http':\n        return this.sftpToHttp(args);\n      case 'http_to_postgres':\n        return this.httpToPostgres(args);\n      case 'sftp_to_postgres':\n        return this.sftpToPostgres(args);\n      case 'postgres_to_sftp':\n        return this.postgresToSftp(args);\n      case 'postgres_to_http':\n        return this.postgresToHttp(args);\n      default:\n        throw new Error(`Unknown pipeline flow: ${flow}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 173,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 235,
        "end_line": 240,
        "content": "buildTrace(args) {\n    return {\n      trace_id: args.trace_id || crypto.randomUUID(),\n      parent_span_id: args.span_id || args.parent_span_id,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 41,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 242,
        "end_line": 275,
        "content": "mergeProjectContext(childArgs, rootArgs) {\n    if (!childArgs || typeof childArgs !== 'object') {\n      return childArgs;\n    }\n\n    const merged = { ...childArgs };\n\n    if (merged.project === undefined && merged.project_name === undefined) {\n      const rootProject = rootArgs?.project ?? rootArgs?.project_name;\n      if (rootProject !== undefined) {\n        merged.project = rootProject;\n      }\n    }\n\n    const hasTarget = merged.target !== undefined || merged.project_target !== undefined || merged.environment !== undefined;\n    if (!hasTarget) {\n      const rootTarget = rootArgs?.target ?? rootArgs?.project_target ?? rootArgs?.environment;\n      if (rootTarget !== undefined) {\n        merged.target = rootTarget;\n      }\n    }\n\n    if (merged.vault_profile_name === undefined && merged.vault_profile === undefined) {\n      const rootVaultProfileName = rootArgs?.vault_profile_name;\n      const rootVaultProfile = rootArgs?.vault_profile;\n      if (rootVaultProfileName !== undefined) {\n        merged.vault_profile_name = rootVaultProfileName;\n      } else if (rootVaultProfile !== undefined) {\n        merged.vault_profile = rootVaultProfile;\n      }\n    }\n\n    return merged;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 301,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 277,
        "end_line": 322,
        "content": "async hydrateProjectDefaults(args) {\n    if (!this.projectResolver) {\n      return args;\n    }\n\n    const needsSftpProfile = !!(args.sftp && typeof args.sftp === 'object' && !args.sftp.profile_name && !args.sftp.connection);\n    const needsPostgresProfile = !!(args.postgres && typeof args.postgres === 'object'\n      && !args.postgres.profile_name && !args.postgres.connection && !args.postgres.connection_url);\n    const explicitlyScoped = args.project !== undefined || args.project_name !== undefined\n      || args.target !== undefined || args.project_target !== undefined || args.environment !== undefined;\n\n    if (!explicitlyScoped && !needsSftpProfile && !needsPostgresProfile) {\n      return args;\n    }\n\n    const context = await this.projectResolver.resolveContext(args);\n    const target = context?.target || {};\n\n    const hydrated = { ...args };\n\n    if (args.http && typeof args.http === 'object') {\n      const httpArgs = this.mergeProjectContext(args.http, args);\n      if (!httpArgs.profile_name && target.api_profile) {\n        httpArgs.profile_name = String(target.api_profile);\n      }\n      hydrated.http = httpArgs;\n    }\n\n    if (args.postgres && typeof args.postgres === 'object') {\n      const postgresArgs = this.mergeProjectContext(args.postgres, args);\n      if (!postgresArgs.profile_name && target.postgres_profile) {\n        postgresArgs.profile_name = String(target.postgres_profile);\n      }\n      hydrated.postgres = postgresArgs;\n    }\n\n    if (args.sftp && typeof args.sftp === 'object') {\n      const sftpArgs = this.mergeProjectContext(args.sftp, args);\n      if (!sftpArgs.profile_name && target.ssh_profile) {\n        sftpArgs.profile_name = String(target.ssh_profile);\n      }\n      hydrated.sftp = sftpArgs;\n    }\n\n    return hydrated;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 448,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 324,
        "end_line": 345,
        "content": "async auditStage(stage, trace, details = {}, error = null) {\n    if (!this.auditService) {\n      return;\n    }\n\n    const entry = {\n      timestamp: new Date().toISOString(),\n      status: error ? 'error' : 'ok',\n      tool: 'mcp_pipeline',\n      action: stage,\n      trace_id: trace.trace_id,\n      span_id: crypto.randomUUID(),\n      parent_span_id: trace.parent_span_id,\n      details: redactObject(details),\n    };\n\n    if (error) {\n      entry.error = error.message;\n    }\n\n    await this.auditService.append(entry);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 347,
        "end_line": 365,
        "content": "normalizeCache(cacheConfig, requestCache, profileCache) {\n    if (!cacheConfig && !requestCache && !profileCache) {\n      return { enabled: false };\n    }\n\n    const base = { enabled: true };\n    const merged = {\n      ...base,\n      ...(profileCache || {}),\n      ...(requestCache || {}),\n      ...(cacheConfig || {}),\n    };\n\n    if (merged.enabled === false) {\n      return { enabled: false };\n    }\n\n    return merged;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 109,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 367,
        "end_line": 375,
        "content": "normalizeStream(response) {\n    if (response?.body) {\n      if (typeof response.body.pipe === 'function') {\n        return response.body;\n      }\n      return Readable.fromWeb(response.body);\n    }\n    return null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 377,
        "end_line": 387,
        "content": "async resolveHttpProfile(httpArgs) {\n    const profile = await this.apiManager.resolveProfile(httpArgs.profile_name, httpArgs);\n    let auth = httpArgs.auth !== undefined ? httpArgs.auth : profile.auth;\n    const authProvider = httpArgs.auth_provider !== undefined ? httpArgs.auth_provider : profile.authProvider;\n\n    if (authProvider) {\n      auth = await this.apiManager.resolveAuthProvider(authProvider, profile.name, httpArgs);\n    }\n\n    return { profile, auth };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 121,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 389,
        "end_line": 407,
        "content": "buildExportArgs(args) {\n    return {\n      ...args.postgres,\n      format: args.format,\n      batch_size: args.batch_size,\n      limit: args.limit,\n      offset: args.offset,\n      csv_header: args.csv_header,\n      csv_delimiter: args.csv_delimiter,\n      columns: args.columns,\n      columns_sql: args.columns_sql,\n      order_by: args.order_by,\n      order_by_sql: args.order_by_sql,\n      filters: args.filters,\n      where_sql: args.where_sql,\n      where_params: args.where_params,\n      timeout_ms: args.timeout_ms,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 136,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 409,
        "end_line": 446,
        "content": "async captureStreamToArtifact(stream, trace, { prefix = 'stream' } = {}) {\n    const mode = resolveStreamToArtifactMode();\n    const contextRoot = mode ? resolveContextRepoRoot() : null;\n    if (!mode || !contextRoot || !stream) {\n      return { stream, artifact: null };\n    }\n\n    const limitBytes = mode === 'full' ? Number.POSITIVE_INFINITY : resolveMaxCaptureBytes();\n    const traceId = trace?.trace_id || 'run';\n    const spanId = trace?.parent_span_id || crypto.randomUUID();\n    const filename = `${prefix}-${crypto.randomUUID()}.bin`;\n    const ref = buildToolCallFileRef({ traceId, spanId, filename });\n\n    let writer;\n    try {\n      writer = await createArtifactWriteStream(contextRoot, ref);\n    } catch (error) {\n      this.logger.warn('Failed to initialize pipeline artifact stream', { error: error.message });\n      return { stream, artifact: null };\n    }\n\n    let resolveDone;\n    const done = new Promise((resolve) => {\n      resolveDone = resolve;\n    });\n\n    const tap = new ArtifactCaptureTransform(writer, { limitBytes, onDone: resolveDone });\n    void pipeline(stream, tap).catch(() => null);\n\n    return {\n      stream: tap,\n      artifact: {\n        uri: ref.uri,\n        rel: ref.rel,\n        done,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 315,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 448,
        "end_line": 545,
        "content": "async openHttpStream(httpArgs, cacheArgs, trace) {\n    if (!httpArgs || typeof httpArgs !== 'object') {\n      throw new Error('http config is required');\n    }\n\n    const { profile, auth } = await this.resolveHttpProfile(httpArgs);\n\n    const config = this.apiManager.buildRequestConfig(httpArgs, profile, auth);\n    const cachePolicy = this.normalizeCache(cacheArgs, httpArgs.cache, profile.data.cache);\n    const cacheKey = cachePolicy.enabled && this.cacheService\n      ? (this.cacheService.normalizeKey(cachePolicy.key) || this.cacheService.buildKey({\n        url: config.url,\n        method: config.method,\n        headers: config.headers,\n        body: httpArgs.body ?? httpArgs.data ?? httpArgs.form ?? httpArgs.body_base64,\n      }))\n      : null;\n\n    if (cachePolicy.enabled && this.cacheService && cacheKey) {\n      const cached = await this.cacheService.getFile(cacheKey, cachePolicy.ttl_ms);\n      if (cached) {\n        await this.auditStage('http_cache_hit', trace, { url: config.url, cache_key: cacheKey });\n        const captured = await this.captureStreamToArtifact(\n          createReadStream(cached.file_path),\n          trace,\n          { prefix: 'http-body' }\n        );\n        return {\n          stream: captured.stream,\n          artifact: captured.artifact,\n          cache: { hit: true, key: cacheKey },\n          response: { url: config.url, method: config.method },\n        };\n      }\n    }\n\n    const fetched = await this.apiManager.fetchWithRetry(httpArgs, profile, auth);\n    const response = fetched.response;\n\n    if (!response.ok) {\n      const text = await response.text().catch(() => '');\n      throw new Error(`HTTP source failed (${response.status}): ${text}`);\n    }\n\n    const stream = this.normalizeStream(response);\n    if (!stream) {\n      const buffer = Buffer.from(await response.arrayBuffer());\n      const captured = await this.captureStreamToArtifact(\n        Readable.from(buffer),\n        trace,\n        { prefix: 'http-body' }\n      );\n      return {\n        stream: captured.stream,\n        artifact: captured.artifact,\n        cache: { hit: false, key: cacheKey },\n        response: { url: config.url, method: config.method, status: response.status },\n      };\n    }\n\n    if (cachePolicy.enabled && this.cacheService && cacheKey) {\n      const writer = await this.cacheService.createFileWriter(cacheKey, {\n        ttl_ms: cachePolicy.ttl_ms,\n        meta: { url: config.url, method: config.method },\n      });\n\n      try {\n        await pipeline(stream, writer.stream);\n        await writer.finalize();\n      } catch (error) {\n        await writer.abort();\n        throw error;\n      }\n\n      await this.auditStage('http_cache_store', trace, { url: config.url, cache_key: cacheKey });\n\n      const captured = await this.captureStreamToArtifact(\n        createReadStream(this.cacheService.dataPath(cacheKey)),\n        trace,\n        { prefix: 'http-body' }\n      );\n      return {\n        stream: captured.stream,\n        artifact: captured.artifact,\n        cache: { hit: false, key: cacheKey },\n        response: { url: config.url, method: config.method, status: response.status },\n      };\n    }\n\n    const captured = await this.captureStreamToArtifact(stream, trace, { prefix: 'http-body' });\n\n    return {\n      stream: captured.stream,\n      artifact: captured.artifact,\n      cache: cachePolicy.enabled ? { hit: false, key: cacheKey } : undefined,\n      response: { url: config.url, method: config.method, status: response.status },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 878,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 547,
        "end_line": 578,
        "content": "async uploadStreamToSftp(stream, sftpArgs) {\n    const remotePath = this.validation.ensureString(sftpArgs.remote_path, 'remote_path');\n    const overwrite = sftpArgs.overwrite === true;\n    const mkdirs = sftpArgs.mkdirs === true;\n\n    await this.sshManager.withSftp(sftpArgs, async (sftp) => {\n      if (!overwrite) {\n        await new Promise((resolve, reject) => {\n          sftp.stat(remotePath, (error) => {\n            if (!error) {\n              reject(new Error(`Remote path already exists: ${remotePath}`));\n              return;\n            }\n            if (error.code !== 2) {\n              reject(error);\n              return;\n            }\n            resolve();\n          });\n        });\n      }\n\n      if (mkdirs) {\n        await this.sshManager.ensureRemoteDir(sftp, remotePath);\n      }\n\n      const writeStream = sftp.createWriteStream(remotePath);\n      await pipeline(stream, writeStream);\n    });\n\n    return { remote_path: remotePath };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 243,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 580,
        "end_line": 605,
        "content": "async httpToSftp(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const { stream, cache, response, artifact } = await this.openHttpStream(hydrated.http, hydrated.cache, trace);\n\n    await this.auditStage('http_fetch', trace, { url: response.url, method: response.method, cache });\n    const result = await this.uploadStreamToSftp(stream, hydrated.sftp || {});\n    await this.auditStage('sftp_upload', trace, { remote_path: result.remote_path });\n\n    const bodyArtifact = artifact?.done ? await artifact.done : null;\n    const httpResponse = bodyArtifact\n      ? {\n        ...response,\n        body_ref: { uri: bodyArtifact.uri, rel: bodyArtifact.rel, bytes: bodyArtifact.bytes },\n        body_ref_truncated: bodyArtifact.truncated,\n      }\n      : response;\n\n    return {\n      success: true,\n      flow: 'http_to_sftp',\n      http: httpResponse,\n      sftp: result,\n      cache,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 243,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 607,
        "end_line": 683,
        "content": "async sftpToHttp(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const httpArgs = hydrated.http || {};\n    const sftpArgs = hydrated.sftp || {};\n\n    const { profile, auth } = await this.resolveHttpProfile(httpArgs);\n\n    const baseConfig = this.apiManager.buildRequestConfig(httpArgs, profile, auth, {\n      body: undefined,\n    });\n\n    const method = baseConfig.method || 'PUT';\n    const policy = this.apiManager.normalizeRetryPolicy(httpArgs.retry, profile.retry, method);\n\n    let attempt = 0;\n    let lastError = null;\n    let lastStatus = null;\n\n    const remotePath = this.validation.ensureString(sftpArgs.remote_path, 'remote_path');\n\n    while (attempt < policy.max_attempts) {\n      attempt += 1;\n      try {\n        const response = await this.sshManager.withSftp(sftpArgs, async (sftp) => {\n          const stream = sftp.createReadStream(remotePath);\n          const controller = new AbortController();\n          const timeout = baseConfig.timeoutMs\n            ? setTimeout(() => controller.abort(), baseConfig.timeoutMs)\n            : null;\n\n          try {\n            const result = await this.apiManager.fetch(baseConfig.url, {\n              method,\n              headers: baseConfig.headers,\n              body: stream,\n              signal: controller.signal,\n              redirect: baseConfig.redirect,\n              duplex: 'half',\n            });\n            return result;\n          } finally {\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n          }\n        });\n\n        lastStatus = response.status;\n        const headers = Object.fromEntries(response.headers.entries());\n        const summary = { status: response.status, headers };\n\n        if (!this.apiManager.shouldRetryResponse(summary, policy) || attempt >= policy.max_attempts) {\n          const text = await response.text().catch(() => '');\n          await this.auditStage('http_upload', trace, { url: baseConfig.url, status: response.status });\n          return {\n            success: response.ok,\n            flow: 'sftp_to_http',\n            http: { url: baseConfig.url, method, status: response.status, response: text },\n          };\n        }\n\n        const delay = this.apiManager.computeRetryDelay(attempt, policy, summary);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      } catch (error) {\n        lastError = error;\n        if (!policy.retry_on_network_error || attempt >= policy.max_attempts) {\n          break;\n        }\n        const delay = this.apiManager.computeRetryDelay(attempt, policy);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n\n    await this.auditStage('http_upload', trace, { url: baseConfig.url, status: lastStatus }, lastError || new Error('Upload failed'));\n    throw lastError || new Error('Upload failed after retries');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 730,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 685,
        "end_line": 713,
        "content": "parseCsvLine(line, delimiter) {\n    const output = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i += 1) {\n      const char = line[i];\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          current += '\"';\n          i += 1;\n        } else {\n          inQuotes = !inQuotes;\n        }\n        continue;\n      }\n\n      if (char === delimiter && !inQuotes) {\n        output.push(current);\n        current = '';\n        continue;\n      }\n\n      current += char;\n    }\n\n    output.push(current);\n    return output;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 149,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 715,
        "end_line": 789,
        "content": "async ingestStream(stream, config) {\n    const format = String(config.format || 'jsonl').toLowerCase();\n    if (!['jsonl', 'csv'].includes(format)) {\n      throw new Error('format must be jsonl or csv');\n    }\n\n    const batchSize = Number(config.batch_size || 500);\n    const maxRows = Number.isFinite(config.max_rows) ? config.max_rows : null;\n\n    let rows = [];\n    let inserted = 0;\n    let columns = Array.isArray(config.columns) ? config.columns : null;\n\n    const useHeader = config.csv_header !== undefined\n      ? config.csv_header === true\n      : !columns;\n\n    const delimiter = config.csv_delimiter ? String(config.csv_delimiter) : ',';\n\n    const rl = readline.createInterface({ input: stream, crlfDelay: Infinity });\n\n    for await (const line of rl) {\n      if (maxRows !== null && inserted + rows.length >= maxRows) {\n        break;\n      }\n\n      const trimmed = line.trim();\n      if (!trimmed) {\n        continue;\n      }\n\n      if (format === 'jsonl') {\n        const parsed = JSON.parse(trimmed);\n        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {\n          throw new Error('jsonl line must be an object');\n        }\n        rows.push(parsed);\n      } else {\n        const values = this.parseCsvLine(trimmed, delimiter);\n        if (useHeader && !columns) {\n          columns = values.map((entry) => entry.trim());\n          continue;\n        }\n        if (!columns) {\n          throw new Error('csv columns are required');\n        }\n        const row = {};\n        columns.forEach((col, index) => {\n          row[col] = values[index] ?? null;\n        });\n        rows.push(row);\n      }\n\n      if (rows.length >= batchSize) {\n        const result = await this.postgresqlManager.insertBulk({\n          ...config,\n          rows,\n          columns,\n        });\n        inserted += result.inserted || rows.length;\n        rows = [];\n      }\n    }\n\n    if (rows.length > 0) {\n      const result = await this.postgresqlManager.insertBulk({\n        ...config,\n        rows,\n        columns,\n      });\n      inserted += result.inserted || rows.length;\n    }\n\n    return { inserted };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 535,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 791,
        "end_line": 823,
        "content": "async httpToPostgres(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const { stream, cache, response, artifact } = await this.openHttpStream(hydrated.http, hydrated.cache, trace);\n\n    await this.auditStage('http_fetch', trace, { url: response.url, method: response.method, cache });\n    const ingest = await this.ingestStream(stream, {\n      ...hydrated.postgres,\n      format: hydrated.format,\n      batch_size: hydrated.batch_size,\n      max_rows: hydrated.max_rows,\n      csv_header: hydrated.csv_header,\n      csv_delimiter: hydrated.csv_delimiter,\n    });\n    await this.auditStage('postgres_insert', trace, { inserted: ingest.inserted, table: hydrated.postgres?.table });\n\n    const bodyArtifact = artifact?.done ? await artifact.done : null;\n    const httpResponse = bodyArtifact\n      ? {\n        ...response,\n        body_ref: { uri: bodyArtifact.uri, rel: bodyArtifact.rel, bytes: bodyArtifact.bytes },\n        body_ref_truncated: bodyArtifact.truncated,\n      }\n      : response;\n\n    return {\n      success: true,\n      flow: 'http_to_postgres',\n      http: httpResponse,\n      postgres: { inserted: ingest.inserted },\n      cache,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 309,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 825,
        "end_line": 853,
        "content": "async sftpToPostgres(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const sftpArgs = hydrated.sftp || {};\n\n    let ingest = { inserted: 0 };\n    await this.sshManager.withSftp(sftpArgs, async (sftp) => {\n      const remotePath = this.validation.ensureString(sftpArgs.remote_path, 'remote_path');\n      const stream = sftp.createReadStream(remotePath);\n      await this.auditStage('sftp_download', trace, { remote_path: remotePath });\n      ingest = await this.ingestStream(stream, {\n        ...hydrated.postgres,\n        format: hydrated.format,\n        batch_size: hydrated.batch_size,\n        max_rows: hydrated.max_rows,\n        csv_header: hydrated.csv_header,\n        csv_delimiter: hydrated.csv_delimiter,\n      });\n    });\n\n    await this.auditStage('postgres_insert', trace, { inserted: ingest.inserted, table: hydrated.postgres?.table });\n\n    return {\n      success: true,\n      flow: 'sftp_to_postgres',\n      sftp: { remote_path: sftpArgs.remote_path },\n      postgres: { inserted: ingest.inserted },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 276,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 855,
        "end_line": 891,
        "content": "async postgresToSftp(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const exportArgs = this.buildExportArgs(hydrated);\n    const { stream, completion } = this.postgresqlManager.exportStream(exportArgs);\n\n    await this.auditStage('postgres_export', trace, {\n      table: exportArgs.table,\n      schema: exportArgs.schema,\n      format: exportArgs.format,\n    });\n\n    const uploadPromise = this.uploadStreamToSftp(stream, hydrated.sftp || {});\n\n    try {\n      const [sftpResult, exportResult] = await Promise.all([uploadPromise, completion]);\n      await this.auditStage('sftp_upload', trace, { remote_path: sftpResult.remote_path });\n\n      return {\n        success: true,\n        flow: 'postgres_to_sftp',\n        postgres: {\n          rows_written: exportResult.rows_written,\n          format: exportResult.format,\n          table: exportResult.table,\n          schema: exportResult.schema,\n          duration_ms: exportResult.duration_ms,\n        },\n        sftp: sftpResult,\n      };\n    } catch (error) {\n      stream.destroy(error);\n      await completion.catch(() => null);\n      await this.auditStage('sftp_upload', trace, { remote_path: hydrated.sftp?.remote_path }, error);\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 324,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 893,
        "end_line": 956,
        "content": "async postgresToHttp(args) {\n    const hydrated = await this.hydrateProjectDefaults(args);\n    const trace = this.buildTrace(hydrated);\n    const httpArgs = { ...(hydrated.http || {}) };\n    const exportArgs = this.buildExportArgs(hydrated);\n    const format = String(exportArgs.format || 'csv').toLowerCase();\n\n    httpArgs.method = httpArgs.method || 'POST';\n    const headers = this.validation.ensureHeaders(httpArgs.headers);\n    if (!Object.keys(headers).some((key) => key.toLowerCase() === 'content-type')) {\n      headers['Content-Type'] = format === 'jsonl' ? 'application/jsonl' : 'text/csv';\n    }\n    httpArgs.headers = headers;\n\n    const { profile, auth } = await this.resolveHttpProfile(httpArgs);\n    const { stream, completion } = this.postgresqlManager.exportStream(exportArgs);\n\n    await this.auditStage('postgres_export', trace, {\n      table: exportArgs.table,\n      schema: exportArgs.schema,\n      format,\n    });\n\n    let fetched;\n    try {\n      fetched = await this.apiManager.fetchWithRetry(httpArgs, profile, auth, {\n        body: stream,\n        duplex: 'half',\n      });\n    } catch (error) {\n      stream.destroy(error);\n      await completion.catch(() => null);\n      await this.auditStage('http_upload', trace, { url: httpArgs.url }, error);\n      throw error;\n    }\n\n    const exportResult = await completion;\n    const response = fetched.response;\n    const headersSnapshot = Object.fromEntries(response.headers.entries());\n    const responseText = await response.text().catch(() => '');\n\n    await this.auditStage('http_upload', trace, { url: fetched.config?.url ?? httpArgs.url, status: response.status });\n\n    return {\n      success: response.ok,\n      flow: 'postgres_to_http',\n      postgres: {\n        rows_written: exportResult.rows_written,\n        format: exportResult.format,\n        table: exportResult.table,\n        schema: exportResult.schema,\n        duration_ms: exportResult.duration_ms,\n      },\n      http: {\n        url: fetched.config?.url ?? httpArgs.url,\n        method: httpArgs.method,\n        status: response.status,\n        headers: headersSnapshot,\n        response: responseText,\n        attempts: fetched.attempts,\n        retries: fetched.retries,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 561,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 958,
        "end_line": 960,
        "content": "getStats() {\n    return {};\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 10,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PipelineManager.ts",
        "start_line": 962,
        "end_line": 964,
        "content": "async cleanup() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PipelineManager",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/PostgreSQLManager.ts": [
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 25,
        "end_line": 38,
        "content": "constructor(logger, validation, profileService, projectResolver, secretRefResolver) {\n    this.logger = logger.child('postgres');\n    this.validation = validation;\n    this.profileService = profileService;\n    this.projectResolver = projectResolver;\n    this.secretRefResolver = secretRefResolver;\n    this.pools = new Map();\n    this.stats = {\n      queries: 0,\n      pools: 0,\n      errors: 0,\n      profiles_created: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 112,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 40,
        "end_line": 85,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'profile_upsert':\n        return this.profileUpsert(args.profile_name, args);\n      case 'profile_get':\n        return this.profileGet(args.profile_name, args.include_secrets);\n      case 'profile_list':\n        return this.profileList();\n      case 'profile_delete':\n        return this.profileDelete(args.profile_name);\n      case 'profile_test':\n        return this.profileTest(args);\n      case 'query':\n        return this.query(args);\n      case 'batch':\n        return this.batch(args);\n      case 'transaction':\n        return this.transaction(args);\n      case 'insert':\n        return this.insert(args);\n      case 'insert_bulk':\n        return this.insertBulk(args);\n      case 'update':\n        return this.update(args);\n      case 'delete':\n        return this.remove(args);\n      case 'select':\n        return this.select(args);\n      case 'count':\n        return this.count(args);\n      case 'exists':\n        return this.exists(args);\n      case 'export':\n        return this.exportData(args);\n      case 'catalog_tables':\n        return this.catalogTables(args);\n      case 'catalog_columns':\n        return this.catalogColumns(args);\n      case 'database_info':\n        return this.databaseInfo(args);\n      default:\n        throw new Error(`Unknown PostgreSQL action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 355,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 87,
        "end_line": 119,
        "content": "parseConnectionUrl(connectionUrl) {\n    try {\n      const url = new URL(connectionUrl);\n      if (!/^postgres(ql)?:$/.test(url.protocol)) {\n        throw new Error('Only postgres:// urls are supported');\n      }\n\n      const database = url.pathname ? url.pathname.replace(/^\\//, '') : undefined;\n      const params = Object.fromEntries(url.searchParams.entries());\n\n      const username = url.username ? decodeURIComponent(url.username) : undefined;\n      const password = url.password ? decodeURIComponent(url.password) : undefined;\n\n      const { ssl, sslSecrets, remainingParams } = this.parseSslParams(params, url.hostname);\n\n      return {\n        data: {\n          host: url.hostname || undefined,\n          port: url.port ? Number(url.port) : undefined,\n          username,\n          database,\n          ssl,\n          options: remainingParams,\n        },\n        secrets: {\n          password,\n          ...sslSecrets,\n        },\n      };\n    } catch (error) {\n      throw new Error(`Failed to parse connection_url: ${error.message}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 267,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 121,
        "end_line": 172,
        "content": "parseSslParams(params, hostFromUrl) {\n    const sslSecrets = {};\n    const remainingParams = { ...params };\n\n    const sslFlags = new Set(['true', '1', 'require', 'verify-ca', 'verify-full']);\n    const sslEnv = params.ssl?.toLowerCase();\n    const sslMode = params.sslmode?.toLowerCase();\n\n    let ssl = undefined;\n\n    if (sslEnv && sslFlags.has(sslEnv)) {\n      ssl = { enabled: true };\n    }\n\n    if (sslMode) {\n      ssl = ssl || { enabled: true };\n      ssl.mode = sslMode;\n    }\n\n    if (params.sslrejectunauthorized !== undefined) {\n      ssl = ssl || { enabled: true };\n      ssl.rejectUnauthorized = params.sslrejectunauthorized !== 'false';\n    }\n\n    if (params.sslservername) {\n      ssl = ssl || { enabled: true };\n      ssl.servername = params.sslservername;\n    }\n\n    const pullSecret = (key, target) => {\n      if (params[key]) {\n        sslSecrets[target] = params[key];\n        delete remainingParams[key];\n      }\n    };\n\n    pullSecret('sslrootcert', 'ssl_ca');\n    pullSecret('sslcert', 'ssl_cert');\n    pullSecret('sslkey', 'ssl_key');\n    pullSecret('sslpassword', 'ssl_passphrase');\n\n    if (ssl && ssl.mode === 'verify-full' && !ssl.servername) {\n      ssl.servername = hostFromUrl;\n    }\n\n    const cleanupParams = ['ssl', 'sslmode', 'sslrejectunauthorized', 'sslservername'];\n    for (const key of cleanupParams) {\n      delete remainingParams[key];\n    }\n\n    return { ssl, sslSecrets, remainingParams };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 363,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 174,
        "end_line": 206,
        "content": "normalizeSslConfig(ssl, secrets) {\n    if (ssl === undefined || ssl === null || ssl === false) {\n      return undefined;\n    }\n\n    if (ssl === true) {\n      return true;\n    }\n\n    if (typeof ssl !== 'object') {\n      return ssl;\n    }\n\n    const config = { ...ssl };\n\n    if (secrets.ssl_ca) {\n      config.ca = secrets.ssl_ca;\n    }\n    if (secrets.ssl_cert) {\n      config.cert = secrets.ssl_cert;\n    }\n    if (secrets.ssl_key) {\n      config.key = secrets.ssl_key;\n    }\n    if (secrets.ssl_passphrase) {\n      config.passphrase = secrets.ssl_passphrase;\n    }\n\n    delete config.enabled;\n    delete config.mode;\n\n    return config;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 164,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 208,
        "end_line": 243,
        "content": "splitConnectionSecrets(connection) {\n    const data = { ...connection };\n    const secrets = {};\n\n    if (data.password) {\n      secrets.password = data.password;\n      delete data.password;\n    }\n\n    if (data.ssl && typeof data.ssl === 'object') {\n      const sslData = { ...data.ssl };\n      if (sslData.ca) {\n        secrets.ssl_ca = sslData.ca;\n        delete sslData.ca;\n      }\n      if (sslData.cert) {\n        secrets.ssl_cert = sslData.cert;\n        delete sslData.cert;\n      }\n      if (sslData.key) {\n        secrets.ssl_key = sslData.key;\n        delete sslData.key;\n      }\n      if (sslData.passphrase) {\n        secrets.ssl_passphrase = sslData.passphrase;\n        delete sslData.passphrase;\n      }\n      data.ssl = sslData;\n    }\n\n    if (data.connectionString) {\n      delete data.connectionString;\n    }\n\n    return { data, secrets };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 218,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 245,
        "end_line": 270,
        "content": "mergeConnectionProfile(profile) {\n    const data = { ...(profile.data || {}) };\n    const secrets = { ...(profile.secrets || {}) };\n\n    if (secrets.password) {\n      data.password = secrets.password;\n    }\n\n    if (data.ssl && typeof data.ssl === 'object') {\n      data.ssl = { ...data.ssl };\n      if (secrets.ssl_ca) {\n        data.ssl.ca = secrets.ssl_ca;\n      }\n      if (secrets.ssl_cert) {\n        data.ssl.cert = secrets.ssl_cert;\n      }\n      if (secrets.ssl_key) {\n        data.ssl.key = secrets.ssl_key;\n      }\n      if (secrets.ssl_passphrase) {\n        data.ssl.passphrase = secrets.ssl_passphrase;\n      }\n    }\n\n    return data;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 166,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 272,
        "end_line": 296,
        "content": "buildPoolConfig(connection) {\n    const config = { ...connection };\n    if (config.username && !config.user) {\n      config.user = config.username;\n      delete config.username;\n    }\n\n    if (config.ssl) {\n      config.ssl = this.normalizeSslConfig(config.ssl, config);\n    }\n\n    const poolOptions = config.pool || {};\n    delete config.pool;\n\n    const options = config.options || {};\n    delete config.options;\n\n    return {\n      config: {\n        ...options,\n        ...config,\n      },\n      poolOptions,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 298,
        "end_line": 305,
        "content": "buildPoolKey(connection, poolOptions, profileName) {\n    if (profileName) {\n      return `profile:${profileName}`;\n    }\n    const payload = JSON.stringify({ connection, poolOptions });\n    const hash = crypto.createHash('sha256').update(payload).digest('hex');\n    return `inline:${hash}`;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 307,
        "end_line": 331,
        "content": "async getPool(connection, poolOptions = {}, profileName) {\n    const key = this.buildPoolKey(connection, poolOptions, profileName);\n    if (this.pools.has(key)) {\n      return this.pools.get(key);\n    }\n\n    const pool = new Pool({\n      ...connection,\n      ...poolOptions,\n      max: poolOptions.max ?? Constants.LIMITS.MAX_CONNECTIONS,\n      idleTimeoutMillis: poolOptions.idleTimeoutMillis ?? Constants.TIMEOUTS.IDLE_TIMEOUT,\n      connectionTimeoutMillis: poolOptions.connectionTimeoutMillis ?? Constants.TIMEOUTS.CONNECTION_TIMEOUT,\n    });\n\n    pool.on('error', (error) => {\n      this.logger.warn('PostgreSQL pool error, recreating on next query', {\n        error: error.message,\n      });\n      this.pools.delete(key);\n    });\n\n    this.pools.set(key, pool);\n    this.stats.pools += 1;\n    return pool;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 207,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 333,
        "end_line": 359,
        "content": "async resolveProfileName(profileName, args = {}) {\n    if (profileName) {\n      return this.validation.ensureString(profileName, 'Profile name');\n    }\n\n    if (this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args);\n      const postgresProfile = context?.target?.postgres_profile;\n      if (postgresProfile) {\n        return this.validation.ensureString(String(postgresProfile), 'Profile name');\n      }\n      if (context) {\n        throw new Error(`Project target '${context.targetName}' is missing postgres_profile`);\n      }\n    }\n\n    const profiles = await this.profileService.listProfiles('postgresql');\n    if (profiles.length === 1) {\n      return profiles[0].name;\n    }\n\n    if (profiles.length === 0) {\n      return undefined;\n    }\n\n    throw new Error('profile_name is required when multiple profiles exist');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 220,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 361,
        "end_line": 387,
        "content": "async resolveConnection(args) {\n    const hasInlineConnection = args.connection || args.connection_url;\n    if (!hasInlineConnection) {\n      const profileName = await this.resolveProfileName(args.profile_name, args);\n      if (!profileName) {\n        throw new Error('profile_name or connection is required');\n      }\n\n      const profile = await this.profileService.getProfile(profileName, 'postgresql');\n      const connection = this.mergeConnectionProfile(profile);\n      const { config, poolOptions } = this.buildPoolConfig(connection);\n      const resolved = this.secretRefResolver ? await this.secretRefResolver.resolveDeep(config, args) : config;\n      return { connection: resolved, poolOptions, profileName };\n    }\n\n    const input = args.connection || {};\n    const connectionUrl = args.connection_url;\n    const base = { ...input };\n\n    if (connectionUrl) {\n      base.connectionString = connectionUrl;\n    }\n\n    const { config, poolOptions } = this.buildPoolConfig(base);\n    const resolved = this.secretRefResolver ? await this.secretRefResolver.resolveDeep(config, args) : config;\n    return { connection: resolved, poolOptions, profileName: undefined };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 298,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 389,
        "end_line": 430,
        "content": "async profileUpsert(profileName, params) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const connection = params.connection || {};\n\n    let parsed = { data: {}, secrets: {} };\n    if (params.connection_url) {\n      parsed = this.parseConnectionUrl(params.connection_url);\n    }\n\n    const mergedConnection = {\n      ...parsed.data,\n      ...connection,\n    };\n\n    const { data, secrets } = this.splitConnectionSecrets(mergedConnection);\n    const profileData = { ...data };\n\n    if (params.pool) {\n      profileData.pool = { ...params.pool };\n    }\n\n    if (params.options) {\n      profileData.options = { ...params.options };\n    }\n\n    const connectionForTest = this.mergeConnectionProfile({ data: profileData, secrets: { ...parsed.secrets, ...secrets } });\n    const resolvedForTest = this.secretRefResolver\n      ? await this.secretRefResolver.resolveDeep(connectionForTest, params)\n      : connectionForTest;\n    await this.testConnection(resolvedForTest, params.pool);\n\n    await this.profileService.setProfile(name, {\n      type: 'postgresql',\n      data: profileData,\n      secrets: { ...parsed.secrets, ...secrets },\n    });\n\n    await this.invalidatePool(name);\n    this.stats.profiles_created += 1;\n\n    return { success: true, profile: { name, ...profileData } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 333,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 432,
        "end_line": 452,
        "content": "async profileGet(profileName, includeSecrets = false) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const profile = await this.profileService.getProfile(name, 'postgresql');\n\n    const allow = isTruthy(process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT) || isTruthy(process.env.SF_ALLOW_SECRET_EXPORT);\n    if (includeSecrets && allow) {\n      return { success: true, profile };\n    }\n\n    const secretKeys = profile.secrets ? Object.keys(profile.secrets).sort() : [];\n    return {\n      success: true,\n      profile: {\n        name: profile.name,\n        type: profile.type,\n        data: profile.data,\n        secrets: secretKeys,\n        secrets_redacted: true,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 182,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 454,
        "end_line": 457,
        "content": "async profileList() {\n    const profiles = await this.profileService.listProfiles('postgresql');\n    return { success: true, profiles };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 459,
        "end_line": 464,
        "content": "async profileDelete(profileName) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    await this.profileService.deleteProfile(name);\n    await this.invalidatePool(name);\n    return { success: true, profile: name };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 65,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 466,
        "end_line": 470,
        "content": "async profileTest(args) {\n    const { connection, poolOptions } = await this.resolveConnection(args);\n    await this.testConnection(connection, poolOptions);\n    return { success: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 51,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 472,
        "end_line": 488,
        "content": "async invalidatePool(profileName) {\n    const key = `profile:${profileName}`;\n    const existingPool = this.pools.get(key);\n    if (!existingPool) {\n      return;\n    }\n\n    this.pools.delete(key);\n    try {\n      await existingPool.end();\n    } catch (error) {\n      this.logger.warn('Failed to close PostgreSQL pool during invalidation', {\n        profile: profileName,\n        error: error.message,\n      });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 109,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 490,
        "end_line": 504,
        "content": "async testConnection(connection, poolOptions) {\n    const pool = new Pool({\n      ...connection,\n      ...poolOptions,\n      max: 1,\n    });\n\n    try {\n      const client = await pool.connect();\n      await client.query('SELECT 1');\n      client.release();\n    } finally {\n      await pool.end();\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 80,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 506,
        "end_line": 545,
        "content": "async executeQuery(pool, sql, params, mode, timeoutMs) {\n    const queryConfig = { text: sql };\n    if (Array.isArray(params)) {\n      queryConfig.values = params;\n    }\n    if (timeoutMs !== undefined && timeoutMs !== null) {\n      queryConfig.query_timeout = Number(timeoutMs);\n    }\n\n    const started = Date.now();\n    const result = await pool.query(queryConfig);\n    this.stats.queries += 1;\n\n    const payload = {\n      success: true,\n      command: result.command,\n      rowCount: result.rowCount,\n      fields: result.fields?.map((field) => ({ name: field.name, dataTypeId: field.dataTypeID })),\n      duration_ms: Date.now() - started,\n    };\n\n    const normalizedMode = (mode || 'rows').toLowerCase();\n    if (normalizedMode === 'row') {\n      payload.row = result.rows[0] ?? null;\n      return payload;\n    }\n\n    if (normalizedMode === 'value') {\n      const firstRow = result.rows[0];\n      payload.value = firstRow ? firstRow[Object.keys(firstRow)[0]] : null;\n      return payload;\n    }\n\n    if (normalizedMode === 'command') {\n      return payload;\n    }\n\n    payload.rows = result.rows;\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 286,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 547,
        "end_line": 556,
        "content": "normalizeLimit(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    const numeric = Number(value);\n    if (!Number.isInteger(numeric) || numeric < 0) {\n      throw new Error(`${label} must be a non-negative integer`);\n    }\n    return numeric;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 558,
        "end_line": 579,
        "content": "normalizeColumns(columns, columnsSql) {\n    if (columnsSql) {\n      return String(columnsSql);\n    }\n    if (!columns) {\n      return '*';\n    }\n    if (Array.isArray(columns)) {\n      if (columns.length === 0) {\n        throw new Error('columns must be a non-empty array');\n      }\n      return columns.map((col) => quoteQualifiedIdentifier(col)).join(', ');\n    }\n    const trimmed = String(columns).trim();\n    if (trimmed === '*') {\n      return '*';\n    }\n    if (!trimmed) {\n      throw new Error('columns must be a non-empty string');\n    }\n    return quoteQualifiedIdentifier(trimmed);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 153,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 581,
        "end_line": 615,
        "content": "buildOrderBy(orderBy, orderBySql) {\n    if (orderBySql) {\n      return ` ORDER BY ${orderBySql}`;\n    }\n    if (!orderBy) {\n      return '';\n    }\n    const normalizeEntry = (entry) => {\n      if (typeof entry === 'string') {\n        return { column: entry, direction: 'ASC' };\n      }\n      if (entry && typeof entry === 'object') {\n        return {\n          column: entry.column || entry.field,\n          direction: entry.direction || entry.dir || 'ASC',\n        };\n      }\n      throw new Error('order_by entries must be strings or objects');\n    };\n\n    const entries = Array.isArray(orderBy) ? orderBy : [orderBy];\n    const parts = entries.map((entry) => {\n      const normalized = normalizeEntry(entry);\n      if (!normalized.column) {\n        throw new Error('order_by entry missing column');\n      }\n      const direction = String(normalized.direction || 'ASC').toUpperCase();\n      if (!['ASC', 'DESC'].includes(direction)) {\n        throw new Error('order_by direction must be ASC or DESC');\n      }\n      return `${quoteQualifiedIdentifier(normalized.column)} ${direction}`;\n    });\n\n    return parts.length > 0 ? ` ORDER BY ${parts.join(', ')}` : '';\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 296,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 617,
        "end_line": 641,
        "content": "buildSelectQuery(args, { mode } = {}) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const columnsSql = this.normalizeColumns(args.columns, args.columns_sql);\n\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: 1,\n    });\n\n    const orderBySql = mode === 'select'\n      ? this.buildOrderBy(args.order_by, args.order_by_sql)\n      : '';\n\n    const limit = mode === 'select' ? this.normalizeLimit(args.limit, 'limit') : undefined;\n    const offset = mode === 'select' ? this.normalizeLimit(args.offset, 'offset') : undefined;\n\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const limitSql = limit !== undefined ? ` LIMIT ${limit}` : '';\n    const offsetSql = offset !== undefined ? ` OFFSET ${offset}` : '';\n\n    const sql = `SELECT ${columnsSql} FROM ${context.qualified}${whereSql}${orderBySql}${limitSql}${offsetSql}`;\n    return { sql, params: where.params, context };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 261,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 643,
        "end_line": 655,
        "content": "async query(args) {\n    const text = this.validation.ensureSql(args.sql);\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    try {\n      return await this.executeQuery(pool, text, args.params, args.mode, args.timeout_ms);\n    } catch (error) {\n      this.stats.errors += 1;\n      this.logger.error('Query failed', { error: error.message });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 125,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 657,
        "end_line": 697,
        "content": "async batch(args) {\n    const statements = Array.isArray(args.statements) ? args.statements : [];\n    if (statements.length === 0) {\n      throw new Error('statements must be a non-empty array');\n    }\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    const transactional = !!args.transactional;\n    const results = [];\n\n    const runStatement = async (statement) => {\n      const sql = this.validation.ensureSql(statement.sql);\n      return this.executeQuery(pool, sql, statement.params, statement.mode, statement.timeout_ms);\n    };\n\n    if (!transactional) {\n      for (const statement of statements) {\n        results.push(await runStatement(statement));\n      }\n      return { success: true, results };\n    }\n\n    const client = await pool.connect();\n    try {\n      await client.query('BEGIN');\n      for (const statement of statements) {\n        const sql = this.validation.ensureSql(statement.sql);\n        const result = await this.executeQuery(client, sql, statement.params, statement.mode, statement.timeout_ms);\n        results.push(result);\n      }\n      await client.query('COMMIT');\n      return { success: true, results };\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 350,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 699,
        "end_line": 701,
        "content": "async transaction(args) {\n    return this.batch({ ...args, transactional: true });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 25,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 703,
        "end_line": 727,
        "content": "async insert(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const payload = this.validation.ensureDataObject(args.data);\n    const returning = args.returning;\n\n    const columns = Object.keys(payload).map((col) => quoteQualifiedIdentifier(col));\n    const values = Object.values(payload);\n    const placeholders = values.map((_, index) => `$${index + 1}`);\n\n    const returnSql = Array.isArray(returning)\n      ? ` RETURNING ${returning.map((col) => quoteQualifiedIdentifier(col)).join(', ')}`\n      : typeof returning === 'string'\n        ? ` RETURNING ${quoteQualifiedIdentifier(returning)}`\n        : returning\n          ? ' RETURNING *'\n          : '';\n\n    const sql = `INSERT INTO ${context.qualified} (${columns.join(', ')}) VALUES (${placeholders.join(', ')})${returnSql}`;\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    const result = await this.executeQuery(pool, sql, values, args.mode, args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, ...result };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 294,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 729,
        "end_line": 812,
        "content": "async insertBulk(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const rows = args.rows || args.data;\n    if (!Array.isArray(rows) || rows.length === 0) {\n      throw new Error('rows must be a non-empty array');\n    }\n\n    const returning = args.returning;\n    let columns = Array.isArray(args.columns) ? args.columns : null;\n\n    if (!columns) {\n      const first = rows[0];\n      if (!first || typeof first !== 'object' || Array.isArray(first)) {\n        throw new Error('rows must be objects or provide columns');\n      }\n      columns = Object.keys(first);\n    }\n\n    if (!Array.isArray(columns) || columns.length === 0) {\n      throw new Error('columns must be a non-empty array');\n    }\n\n    const columnSql = columns.map((col) => quoteQualifiedIdentifier(col));\n    const returnSql = Array.isArray(returning)\n      ? ` RETURNING ${returning.map((col) => quoteQualifiedIdentifier(col)).join(', ')}`\n      : typeof returning === 'string'\n        ? ` RETURNING ${quoteQualifiedIdentifier(returning)}`\n        : returning\n          ? ' RETURNING *'\n          : '';\n\n    const maxParams = 65535;\n    const maxBatchSize = Math.max(1, Math.floor(maxParams / columnSql.length));\n    const requestedBatch = Number.isFinite(args.batch_size) ? Number(args.batch_size) : 500;\n    const batchSize = Math.min(requestedBatch, maxBatchSize);\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    let inserted = 0;\n    const allRows = [];\n\n    for (let offset = 0; offset < rows.length; offset += batchSize) {\n      const batch = rows.slice(offset, offset + batchSize);\n      const values = [];\n      const placeholders = batch.map((row, rowIndex) => {\n        let payload = row;\n        if (Array.isArray(row)) {\n          payload = {};\n          columns.forEach((col, colIndex) => {\n            payload[col] = row[colIndex];\n          });\n        }\n        if (!payload || typeof payload !== 'object') {\n          throw new Error('Each row must be an object or array');\n        }\n        const rowValues = columns.map((col) => payload[col]);\n        rowValues.forEach((value) => values.push(value));\n        const startIndex = rowIndex * columnSql.length;\n        const rowPlaceholders = columnSql.map((_, colIndex) => `$${startIndex + colIndex + 1}`);\n        return `(${rowPlaceholders.join(', ')})`;\n      });\n\n      const sql = `INSERT INTO ${context.qualified} (${columnSql.join(', ')}) VALUES ${placeholders.join(', ')}${returnSql}`;\n      const result = await this.executeQuery(pool, sql, values, args.mode, args.timeout_ms);\n      inserted += batch.length;\n      if (returning) {\n        if (Array.isArray(result.rows)) {\n          allRows.push(...result.rows);\n        } else if (result.row) {\n          allRows.push(result.row);\n        }\n      }\n    }\n\n    return {\n      success: true,\n      table: context.table,\n      schema: context.schema,\n      inserted,\n      batches: Math.ceil(rows.length / batchSize),\n      rows: returning ? allRows : undefined,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 783,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 814,
        "end_line": 845,
        "content": "async update(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const payload = this.validation.ensureDataObject(args.data);\n\n    const columns = Object.keys(payload).map((col) => quoteQualifiedIdentifier(col));\n    const values = Object.values(payload);\n    const assignments = columns.map((col, index) => `${col} = $${index + 1}`);\n\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: values.length + 1,\n    });\n\n    const returnSql = Array.isArray(args.returning)\n      ? ` RETURNING ${args.returning.map((col) => quoteQualifiedIdentifier(col)).join(', ')}`\n      : typeof args.returning === 'string'\n        ? ` RETURNING ${quoteQualifiedIdentifier(args.returning)}`\n        : args.returning\n          ? ' RETURNING *'\n          : '';\n\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const sql = `UPDATE ${context.qualified} SET ${assignments.join(', ')}${whereSql}${returnSql}`;\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    const result = await this.executeQuery(pool, sql, [...values, ...where.params], args.mode, args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, ...result };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 355,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 847,
        "end_line": 873,
        "content": "async remove(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: 1,\n    });\n\n    const returnSql = Array.isArray(args.returning)\n      ? ` RETURNING ${args.returning.map((col) => quoteQualifiedIdentifier(col)).join(', ')}`\n      : typeof args.returning === 'string'\n        ? ` RETURNING ${quoteQualifiedIdentifier(args.returning)}`\n        : args.returning\n          ? ' RETURNING *'\n          : '';\n\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const sql = `DELETE FROM ${context.qualified}${whereSql}${returnSql}`;\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    const result = await this.executeQuery(pool, sql, where.params, args.mode, args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, ...result };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 273,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 875,
        "end_line": 881,
        "content": "async select(args) {\n    const { sql, params, context } = this.buildSelectQuery(args, { mode: 'select' });\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n    const result = await this.executeQuery(pool, sql, params, args.mode, args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, ...result };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 117,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 883,
        "end_line": 898,
        "content": "async count(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: 1,\n    });\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const sql = `SELECT COUNT(*) AS count FROM ${context.qualified}${whereSql}`;\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n    const result = await this.executeQuery(pool, sql, where.params, 'row', args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, count: Number(result.row?.count || 0) };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 198,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 900,
        "end_line": 915,
        "content": "async exists(args) {\n    const context = normalizeTableContext(args.table, args.schema);\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: 1,\n    });\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const sql = `SELECT EXISTS(SELECT 1 FROM ${context.qualified}${whereSql}) AS exists`;\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n    const result = await this.executeQuery(pool, sql, where.params, 'row', args.timeout_ms);\n    return { success: true, table: context.table, schema: context.schema, exists: result.row?.exists === true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 200,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 917,
        "end_line": 1020,
        "content": "async exportToStream(args, stream) {\n    const format = String(args.format || 'csv').toLowerCase();\n    if (!['csv', 'jsonl'].includes(format)) {\n      throw new Error('format must be csv or jsonl');\n    }\n\n    const batchSize = this.normalizeLimit(args.batch_size ?? 1000, 'batch_size') ?? 1000;\n    const baseOffset = this.normalizeLimit(args.offset ?? 0, 'offset') ?? 0;\n    const limit = this.normalizeLimit(args.limit, 'limit');\n    const headerEnabled = args.csv_header !== false;\n    const delimiter = args.csv_delimiter ? String(args.csv_delimiter) : ',';\n\n    const context = normalizeTableContext(args.table, args.schema);\n    const columnsSql = this.normalizeColumns(args.columns, args.columns_sql);\n    const orderBySql = this.buildOrderBy(args.order_by, args.order_by_sql);\n\n    const where = buildWhereClause({\n      filters: args.filters,\n      whereSql: args.where_sql,\n      whereParams: args.where_params,\n      startIndex: 1,\n    });\n\n    const whereSql = where.clause ? ` WHERE ${where.clause}` : '';\n    const started = Date.now();\n\n    const writeLine = (line) => new Promise((resolve, reject) => {\n      stream.write(line, (error) => (error ? reject(error) : resolve()));\n    });\n\n    const { connection, poolOptions, profileName } = await this.resolveConnection(args);\n    const pool = await this.getPool(connection, poolOptions, profileName);\n\n    let offset = baseOffset;\n    let rowsWritten = 0;\n    let headerWritten = false;\n    let columns = null;\n\n    const csvEscape = (value) => {\n      if (value === null || value === undefined) {\n        return '';\n      }\n      const raw = String(value);\n      if (raw.includes('\"') || raw.includes(delimiter) || raw.includes('\\n')) {\n        return `\"${raw.replace(/\"/g, '\"\"')}\"`;\n      }\n      return raw;\n    };\n\n    try {\n      while (true) {\n        const pageLimit = limit !== undefined ? Math.min(batchSize, limit - rowsWritten) : batchSize;\n        if (pageLimit <= 0) {\n          break;\n        }\n\n        const sql = `SELECT ${columnsSql} FROM ${context.qualified}${whereSql}${orderBySql} LIMIT ${pageLimit} OFFSET ${offset}`;\n        const result = await this.executeQuery(pool, sql, where.params, 'rows', args.timeout_ms);\n        const rows = result.rows || [];\n\n        if (!headerWritten && format === 'csv' && headerEnabled) {\n          columns = result.fields?.map((field) => field.name) || (rows[0] ? Object.keys(rows[0]) : []);\n          if (columns.length > 0) {\n            await writeLine(`${columns.map(csvEscape).join(delimiter)}\\n`);\n          }\n          headerWritten = true;\n        }\n\n        if (rows.length === 0) {\n          break;\n        }\n\n        for (const row of rows) {\n          if (format === 'jsonl') {\n            await writeLine(`${JSON.stringify(row)}\\n`);\n          } else {\n            const rowColumns = columns || Object.keys(row);\n            await writeLine(`${rowColumns.map((col) => csvEscape(row[col])).join(delimiter)}\\n`);\n          }\n          rowsWritten += 1;\n          if (limit !== undefined && rowsWritten >= limit) {\n            break;\n          }\n        }\n\n        if (limit !== undefined && rowsWritten >= limit) {\n          break;\n        }\n\n        offset += pageLimit;\n      }\n    } finally {\n      await new Promise((resolve) => stream.end(resolve));\n    }\n\n    return {\n      success: true,\n      table: context.table,\n      schema: context.schema,\n      format,\n      rows_written: rowsWritten,\n      duration_ms: Date.now() - started,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 876,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1022,
        "end_line": 1030,
        "content": "exportStream(args) {\n    const stream = new PassThrough();\n    const completion = this.exportToStream(args, stream).catch((error) => {\n      stream.destroy(error);\n      throw error;\n    });\n\n    return { stream, completion };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 61,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1032,
        "end_line": 1060,
        "content": "async exportData(args) {\n    const filePath = args.file_path;\n    if (!filePath) {\n      throw new Error('file_path is required');\n    }\n\n    const overwrite = args.overwrite === true;\n    if (!overwrite && await pathExists(filePath)) {\n      throw new Error(`Local path already exists: ${filePath}`);\n    }\n\n    await ensureDirForFile(filePath);\n    const tmpPath = tempSiblingPath(filePath, '.part');\n    const stream = createWriteStream(tmpPath, { encoding: 'utf8', mode: 0o600 });\n\n    let result;\n    try {\n      result = await this.exportToStream(args, stream);\n      await atomicReplaceFile(tmpPath, filePath, { overwrite, mode: 0o600 });\n    } catch (error) {\n      await fs.unlink(tmpPath).catch(() => null);\n      throw error;\n    }\n\n    return {\n      ...result,\n      file_path: filePath,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 206,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1062,
        "end_line": 1078,
        "content": "async catalogTables(args) {\n    const schema = args.schema ? this.validation.ensureSchemaName(args.schema) : undefined;\n    const sql = `\n      SELECT schemaname AS schema,\n             tablename AS name,\n             tableowner AS owner,\n             hasindexes,\n             hasrules,\n             hastriggers\n      FROM pg_tables\n      WHERE schemaname NOT IN ('pg_catalog', 'information_schema')\n      ${schema ? 'AND schemaname = $1' : ''}\n      ORDER BY schemaname, tablename\n    `;\n\n    return this.query({ ...args, sql, params: schema ? [schema] : [] });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 145,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1080,
        "end_line": 1099,
        "content": "async catalogColumns(args) {\n    const name = this.validation.ensureTableName(args.table);\n    const schema = this.validation.ensureSchemaName(args.schema ?? 'public');\n\n    const sql = `\n      SELECT column_name,\n             data_type,\n             is_nullable,\n             column_default,\n             character_maximum_length,\n             numeric_precision,\n             numeric_scale\n      FROM information_schema.columns\n      WHERE table_schema = $1 AND table_name = $2\n      ORDER BY ordinal_position\n    `;\n\n    const result = await this.query({ ...args, sql, params: [schema, name], mode: 'rows' });\n    return { success: true, table: name, schema, columns: result.rows };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 176,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1101,
        "end_line": 1107,
        "content": "async databaseInfo(args) {\n    const sql = `SELECT current_database() AS database_name,\n                        current_user AS current_user,\n                        version() AS version,\n                        pg_size_pretty(pg_database_size(current_database())) AS size`;\n    return this.query({ ...args, sql });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 83,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1109,
        "end_line": 1111,
        "content": "getStats() {\n    return { ...this.stats, activePools: this.pools.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 23,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PostgreSQLManager.ts",
        "start_line": 1113,
        "end_line": 1118,
        "content": "async cleanup() {\n    for (const pool of this.pools.values()) {\n      await pool.end();\n    }\n    this.pools.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PostgreSQLManager",
          "estimated_tokens": 34,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/PresetManager.ts": [
      {
        "file_path": "src/managers/PresetManager.ts",
        "start_line": 9,
        "end_line": 12,
        "content": "constructor(logger, presetService) {\n    this.logger = logger.child('preset');\n    this.presetService = presetService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetManager",
          "estimated_tokens": 33,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PresetManager.ts",
        "start_line": 14,
        "end_line": 29,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'preset_upsert':\n        return this.presetService.setPreset(args.tool, args.name, args.preset || args);\n      case 'preset_get':\n        return this.presetService.getPreset(args.tool, args.name);\n      case 'preset_list':\n        return this.presetService.listPresets(args.tool);\n      case 'preset_delete':\n        return this.presetService.deletePreset(args.tool, args.name);\n      default:\n        throw new Error(`Unknown preset action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetManager",
          "estimated_tokens": 142,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PresetManager.ts",
        "start_line": 31,
        "end_line": 33,
        "content": "getStats() {\n    return this.presetService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/PresetManager.ts",
        "start_line": 35,
        "end_line": 37,
        "content": "async cleanup() {\n    await this.presetService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/ProjectManager.ts": [
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 11,
        "end_line": 16,
        "content": "constructor(logger, validation, projectService, stateService) {\n    this.logger = logger.child('project');\n    this.validation = validation;\n    this.projectService = projectService;\n    this.stateService = stateService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 18,
        "end_line": 39,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'project_upsert':\n        return this.projectUpsert(args.name, args);\n      case 'project_get':\n        return this.projectGet(args.name);\n      case 'project_list':\n        return this.projectList();\n      case 'project_delete':\n        return this.projectDelete(args.name);\n      case 'project_use':\n        return this.projectUse(args.name, args.scope);\n      case 'project_active':\n        return this.projectActive(args.scope);\n      case 'project_unuse':\n        return this.projectUnuse(args.scope);\n      default:\n        throw new Error(`Unknown project action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 175,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 41,
        "end_line": 48,
        "content": "buildProjectPayload(args) {\n    const payload = args.project && typeof args.project === 'object' ? args.project : {\n      description: args.description,\n      default_target: args.default_target,\n      targets: args.targets,\n    };\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 66,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 50,
        "end_line": 54,
        "content": "async projectUpsert(name, args) {\n    const projectName = this.validation.ensureString(name, 'Project name');\n    const payload = this.buildProjectPayload(args);\n    return this.projectService.setProject(projectName, payload);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 60,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 56,
        "end_line": 59,
        "content": "async projectGet(name) {\n    const projectName = this.validation.ensureString(name, 'Project name');\n    return this.projectService.getProject(projectName);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 43,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 61,
        "end_line": 63,
        "content": "async projectList() {\n    return this.projectService.listProjects();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 65,
        "end_line": 68,
        "content": "async projectDelete(name) {\n    const projectName = this.validation.ensureString(name, 'Project name');\n    return this.projectService.deleteProject(projectName);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 44,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 70,
        "end_line": 77,
        "content": "async projectUse(name, scope) {\n    const projectName = this.validation.ensureString(name, 'Project name');\n    await this.projectService.getProject(projectName);\n\n    const targetScope = scope || 'persistent';\n    await this.stateService.set(ACTIVE_PROJECT_KEY, projectName, targetScope);\n    return { success: true, project: projectName, scope: targetScope };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 94,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 79,
        "end_line": 82,
        "content": "async projectActive(scope) {\n    const state = await this.stateService.get(ACTIVE_PROJECT_KEY, scope || 'any');\n    return { success: true, project: state.value, scope: state.scope };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 49,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 84,
        "end_line": 87,
        "content": "async projectUnuse(scope) {\n    const cleared = await this.stateService.unset(ACTIVE_PROJECT_KEY, scope || 'any');\n    return { success: true, ...cleared };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 43,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 89,
        "end_line": 91,
        "content": "getStats() {\n    return this.projectService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/ProjectManager.ts",
        "start_line": 93,
        "end_line": 95,
        "content": "async cleanup() {\n    await this.projectService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/RepoManager.ts": [
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 63,
        "end_line": 88,
        "content": "function findKubectlToken(argv, startIndex) {\n  for (let idx = startIndex; idx < argv.length; idx += 1) {\n    const token = argv[idx];\n    if (typeof token !== 'string' || !token.trim()) {\n      continue;\n    }\n    if (token === '--') {\n      const next = argv[idx + 1];\n      if (typeof next === 'string' && next.trim()) {\n        return { token: next, index: idx + 1 };\n      }\n      return null;\n    }\n    if (token.startsWith('-')) {\n      if (token.startsWith('--') && token.includes('=')) {\n        continue;\n      }\n      if (KUBECTL_FLAGS_WITH_VALUE.has(token)) {\n        idx += 1;\n      }\n      continue;\n    }\n    return { token, index: idx };\n  }\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "findKubectlToken",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 168,
          "qualified_name": "findKubectlToken",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 90,
        "end_line": 116,
        "content": "function extractKubectlNamespace(argv) {\n  if (!Array.isArray(argv)) {\n    return null;\n  }\n  for (let idx = 0; idx < argv.length; idx += 1) {\n    const token = argv[idx];\n    if (token === '--') {\n      break;\n    }\n    if (token === '-n' || token === '--namespace') {\n      const next = argv[idx + 1];\n      if (typeof next === 'string' && next.trim()) {\n        return next.trim();\n      }\n      return null;\n    }\n    if (typeof token === 'string' && token.startsWith('--namespace=')) {\n      const value = token.slice('--namespace='.length).trim();\n      return value || null;\n    }\n    if (typeof token === 'string' && token.startsWith('-n=')) {\n      const value = token.slice(3).trim();\n      return value || null;\n    }\n  }\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "extractKubectlNamespace",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 187,
          "qualified_name": "extractKubectlNamespace",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 118,
        "end_line": 137,
        "content": "function isKubectlReadOnly(argv) {\n  const found = findKubectlToken(argv, 0);\n  if (!found) {\n    return false;\n  }\n  const subcommand = found.token;\n  const subcommandIndex = found.index;\n  if (READ_ONLY_EXEC_SUBCOMMANDS.kubectl?.has(subcommand)) {\n    return true;\n  }\n  const nested = READ_ONLY_EXEC_SUBSUBCOMMANDS.kubectl?.[subcommand];\n  if (!nested) {\n    return false;\n  }\n  const second = findKubectlToken(argv, subcommandIndex + 1);\n  if (!second) {\n    return false;\n  }\n  return nested.has(second.token);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isKubectlReadOnly",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 129,
          "qualified_name": "isKubectlReadOnly",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 148,
        "end_line": 157,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return null;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 159,
        "end_line": 168,
        "content": "function splitAllowlist(value) {\n  if (!value || typeof value !== 'string') {\n    return null;\n  }\n  const tokens = value\n    .split(/[\\s,]+/)\n    .map((item) => item.trim())\n    .filter(Boolean);\n  return tokens.length > 0 ? tokens : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "splitAllowlist",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "splitAllowlist",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 170,
        "end_line": 175,
        "content": "function allowsAllCommands(allowedCommands) {\n  if (!Array.isArray(allowedCommands)) {\n    return false;\n  }\n  return allowedCommands.includes('*') || allowedCommands.includes('all');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "allowsAllCommands",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 46,
          "qualified_name": "allowsAllCommands",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 177,
        "end_line": 187,
        "content": "function stripYamlComment(value) {\n  if (typeof value !== 'string') {\n    return '';\n  }\n  const trimmed = value.trim();\n  if (!trimmed || trimmed.startsWith('#')) {\n    return '';\n  }\n  const match = trimmed.match(/^(.*?)\\s+#/);\n  return match ? match[1].trim() : trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "stripYamlComment",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 68,
          "qualified_name": "stripYamlComment",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 189,
        "end_line": 202,
        "content": "function stripYamlQuotes(value) {\n  if (typeof value !== 'string') {\n    return '';\n  }\n  const trimmed = value.trim();\n  if (trimmed.length >= 2) {\n    const first = trimmed[0];\n    const last = trimmed[trimmed.length - 1];\n    if ((first === '\"' && last === '\"') || (first === \"'\" && last === \"'\")) {\n      return trimmed.slice(1, -1);\n    }\n  }\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "stripYamlQuotes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 91,
          "qualified_name": "stripYamlQuotes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 204,
        "end_line": 235,
        "content": "function parseContainerImageRef(raw) {\n  const image = stripYamlQuotes(stripYamlComment(String(raw ?? '')));\n  if (!image) {\n    return null;\n  }\n\n  const atIndex = image.indexOf('@');\n  const withTag = atIndex === -1 ? image : image.slice(0, atIndex);\n  const digest = atIndex === -1 ? null : image.slice(atIndex + 1).trim() || null;\n\n  const lastSlash = withTag.lastIndexOf('/');\n  const lastColon = withTag.lastIndexOf(':');\n\n  let name = withTag;\n  let tag = null;\n  if (lastColon > lastSlash) {\n    name = withTag.slice(0, lastColon);\n    tag = withTag.slice(lastColon + 1) || null;\n  }\n\n  const pinned = Boolean(digest);\n  const usesLatest = !pinned && (!tag || tag === 'latest');\n\n  return {\n    image,\n    name,\n    tag,\n    digest,\n    pinned,\n    uses_latest: usesLatest,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseContainerImageRef",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 197,
          "qualified_name": "parseContainerImageRef",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 237,
        "end_line": 329,
        "content": "function extractK8sImages(renderedText) {\n  const text = typeof renderedText === 'string' ? renderedText : String(renderedText ?? '');\n  const lines = text.split(/\\r?\\n/);\n\n  const seen = new Set();\n  const images = [];\n\n  let kind = null;\n  let name = null;\n  let metadataIndent = null;\n\n  const resetDoc = () => {\n    kind = null;\n    name = null;\n    metadataIndent = null;\n  };\n\n  for (const line of lines) {\n    if (line.trim() === '---') {\n      resetDoc();\n      continue;\n    }\n\n    const indentMatch = line.match(/^\\s*/);\n    const indent = indentMatch ? indentMatch[0].length : 0;\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) {\n      continue;\n    }\n\n    const kindMatch = trimmed.match(/^kind:\\s*(\\S+)/i);\n    if (kindMatch && indent === 0) {\n      kind = kindMatch[1];\n      continue;\n    }\n\n    if (/^metadata:\\s*$/i.test(trimmed)) {\n      metadataIndent = indent;\n      continue;\n    }\n\n    if (metadataIndent !== null) {\n      if (indent <= metadataIndent) {\n        metadataIndent = null;\n      } else {\n        const nameMatch = trimmed.match(/^name:\\s*(\\S+)/i);\n        if (nameMatch && name === null) {\n          name = stripYamlQuotes(stripYamlComment(nameMatch[1]));\n        }\n      }\n    }\n\n    const imageMatch = trimmed.match(/^image:\\s*(.+)$/i);\n    if (!imageMatch) {\n      continue;\n    }\n\n    const parsed = parseContainerImageRef(imageMatch[1]);\n    if (!parsed) {\n      continue;\n    }\n\n    if (seen.has(parsed.image)) {\n      continue;\n    }\n    seen.add(parsed.image);\n    images.push({\n      ...parsed,\n      resource_kind: kind,\n      resource_name: name,\n    });\n  }\n\n  const unpinned = images.filter((entry) => !entry.pinned);\n  const latest = images.filter((entry) => entry.uses_latest);\n\n  return {\n    images,\n    summary: {\n      total: images.length,\n      unpinned: unpinned.length,\n      latest: latest.length,\n    },\n    violations: {\n      unpinned: unpinned.slice(0, 25).map((entry) => entry.image),\n      latest: latest.slice(0, 25).map((entry) => entry.image),\n      truncated: {\n        unpinned: unpinned.length > 25,\n        latest: latest.length > 25,\n      },\n    },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "extractK8sImages",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 539,
          "qualified_name": "extractK8sImages",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 332,
        "end_line": 344,
        "content": "constructor(logger, security, validation, projectResolver, policyService) {\n    this.logger = logger.child('repo');\n    this.security = security;\n    this.validation = validation;\n    this.projectResolver = projectResolver;\n    this.policyService = policyService;\n\n    this.stats = {\n      calls: 0,\n      errors: 0,\n      exec: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 87,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 346,
        "end_line": 373,
        "content": "async handleAction(args = {}) {\n    const action = args.action;\n    this.stats.calls += 1;\n\n    switch (action) {\n      case 'exec':\n        return this.exec(args);\n      case 'repo_info':\n        return this.repoInfo(args);\n      case 'assert_clean':\n        return this.assertClean(args);\n      case 'git_diff':\n        return this.gitDiff(args);\n      case 'render':\n        return this.render(args);\n      case 'apply_patch':\n        return this.applyPatch(args);\n      case 'git_commit':\n        return this.gitCommit(args);\n      case 'git_revert':\n        return this.gitRevert(args);\n      case 'git_push':\n        return this.gitPush(args);\n      default:\n        this.stats.errors += 1;\n        throw new Error(`Unknown repo action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 193,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 375,
        "end_line": 399,
        "content": "async assertClean(args) {\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n    const status = await this.runGit({\n      cwd: gitRoot,\n      argv: ['status', '--porcelain'],\n      timeoutMs,\n      maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024),\n    });\n\n    if (status.exit_code !== 0) {\n      throw new Error(status.stderr_buffer.toString('utf8').trim() || 'git status failed');\n    }\n\n    const output = status.stdout_buffer.toString('utf8').trimEnd();\n    if (output.trim().length > 0) {\n      const preview = output.split(/\\r?\\n/).slice(0, 20).join('\\n');\n      throw new Error(`Repository is dirty (uncommitted changes). Refusing to continue.\\n\\n${preview}`);\n    }\n\n    return { success: true, repo_root: gitRoot, clean: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 238,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 401,
        "end_line": 404,
        "content": "resolveAllowedCommands() {\n    const raw = process.env.SENTRYFROGG_REPO_ALLOWED_COMMANDS || process.env.SF_REPO_ALLOWED_COMMANDS;\n    return splitAllowlist(raw) || DEFAULT_ALLOWED_COMMANDS;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 50,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 406,
        "end_line": 416,
        "content": "resolveExecBudgets() {\n    const captureEnv = process.env.SENTRYFROGG_REPO_EXEC_MAX_CAPTURE_BYTES || process.env.SF_REPO_EXEC_MAX_CAPTURE_BYTES;\n    const inlineEnv = process.env.SENTRYFROGG_REPO_EXEC_MAX_INLINE_BYTES || process.env.SF_REPO_EXEC_MAX_INLINE_BYTES;\n    const timeoutEnv = process.env.SENTRYFROGG_REPO_EXEC_TIMEOUT_MS || process.env.SF_REPO_EXEC_TIMEOUT_MS;\n\n    const maxCaptureBytes = readPositiveInt(captureEnv) ?? DEFAULT_MAX_CAPTURE_BYTES;\n    const maxInlineBytes = readPositiveInt(inlineEnv) ?? DEFAULT_MAX_INLINE_BYTES;\n    const timeoutMs = readPositiveInt(timeoutEnv) ?? DEFAULT_TIMEOUT_MS;\n\n    return { maxCaptureBytes, maxInlineBytes, timeoutMs };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 171,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 418,
        "end_line": 421,
        "content": "resolvePatchBudgetBytes() {\n    const patchEnv = process.env.SENTRYFROGG_REPO_MAX_PATCH_BYTES || process.env.SF_REPO_MAX_PATCH_BYTES;\n    return readPositiveInt(patchEnv) ?? DEFAULT_MAX_PATCH_BYTES;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 52,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 423,
        "end_line": 435,
        "content": "resolveRenderBudgets() {\n    const bytesEnv = process.env.SENTRYFROGG_REPO_RENDER_MAX_BYTES || process.env.SF_REPO_RENDER_MAX_BYTES;\n    const timeoutEnv = process.env.SENTRYFROGG_REPO_RENDER_TIMEOUT_MS || process.env.SF_REPO_RENDER_TIMEOUT_MS;\n\n    const maxBytes = readPositiveInt(bytesEnv) ?? DEFAULT_MAX_RENDER_BYTES;\n    const timeoutMs = readPositiveInt(timeoutEnv) ?? this.resolveExecBudgets().timeoutMs;\n\n    return {\n      maxBytes,\n      maxStderrBytes: DEFAULT_MAX_RENDER_STDERR_BYTES,\n      timeoutMs,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 133,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 437,
        "end_line": 451,
        "content": "normalizeCommand(rawCommand, allowedCommands) {\n    const command = this.security.cleanCommand(rawCommand);\n    if (command.includes(' ') || command.includes('\\t') || command.includes('\\n')) {\n      throw new Error('command must be a single executable (no whitespace)');\n    }\n    if (command.includes('/') || command.includes('\\\\')) {\n      throw new Error('command must not contain path separators');\n    }\n\n    if (!allowsAllCommands(allowedCommands) && !allowedCommands.includes(command)) {\n      throw new Error(`Command not allowed: ${command}`);\n    }\n\n    return command;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 147,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 453,
        "end_line": 461,
        "content": "normalizeArgs(argv) {\n    if (argv === undefined || argv === null) {\n      return [];\n    }\n    if (!Array.isArray(argv)) {\n      throw new Error('args must be an array of strings');\n    }\n    return argv.map((item) => String(item));\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 61,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 463,
        "end_line": 487,
        "content": "normalizeEnv(env) {\n    if (env === undefined || env === null) {\n      return undefined;\n    }\n    if (typeof env !== 'object' || Array.isArray(env)) {\n      throw new Error('env must be an object');\n    }\n\n    const blocked = new Set(['PATH', 'LD_PRELOAD', 'DYLD_INSERT_LIBRARIES', 'NODE_OPTIONS']);\n    return Object.fromEntries(\n      Object.entries(env).flatMap(([key, value]) => {\n        if (!key || typeof key !== 'string') {\n          return [];\n        }\n        const trimmed = key.trim();\n        if (!trimmed || blocked.has(trimmed)) {\n          return [];\n        }\n        if (value === undefined || value === null) {\n          return [];\n        }\n        return [[trimmed, String(value)]];\n      })\n    );\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 183,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 489,
        "end_line": 503,
        "content": "async resolveRepoRoot(args) {\n    if (args.repo_root) {\n      return this.validation.ensureString(String(args.repo_root), 'repo_root', { trim: false });\n    }\n\n    if (this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args).catch(() => null);\n      const cwd = context?.target?.cwd;\n      if (cwd) {\n        return this.validation.ensureString(String(cwd), 'repo_root', { trim: false });\n      }\n    }\n\n    throw new Error('repo_root is required (or resolve it via project target cwd)');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 505,
        "end_line": 589,
        "content": "async runGit({ cwd, argv, stdin, timeoutMs, maxCaptureBytes }) {\n    const child = spawn('git', ['--no-pager', ...argv], {\n      cwd,\n      env: {\n        ...process.env,\n        GIT_TERMINAL_PROMPT: '0',\n      },\n      shell: false,\n      windowsHide: true,\n    });\n\n    if (stdin !== undefined && stdin !== null) {\n      child.stdin?.end(String(stdin));\n    } else {\n      child.stdin?.end();\n    }\n\n    let stdoutBuffers = [];\n    let stderrBuffers = [];\n    const stdoutState = { total: 0, captured: 0, buffers: stdoutBuffers, truncated: false };\n    const stderrState = { total: 0, captured: 0, buffers: stderrBuffers, truncated: false };\n\n    const capture = (chunk, state) => {\n      const size = chunk.length;\n      state.total += size;\n      if (state.captured >= maxCaptureBytes) {\n        state.truncated = true;\n        return;\n      }\n      const remaining = maxCaptureBytes - state.captured;\n      if (size <= remaining) {\n        state.buffers.push(chunk);\n        state.captured += size;\n        return;\n      }\n      state.buffers.push(chunk.subarray(0, remaining));\n      state.captured += remaining;\n      state.truncated = true;\n    };\n\n    child.stdout?.on('data', (chunk) => capture(chunk, stdoutState));\n    child.stderr?.on('data', (chunk) => capture(chunk, stderrState));\n\n    let timedOut = false;\n    let timeout;\n    if (timeoutMs) {\n      timeout = setTimeout(() => {\n        timedOut = true;\n        try {\n          child.kill('SIGKILL');\n        } catch (error) {\n        }\n      }, timeoutMs);\n    }\n\n    const finished = await new Promise((resolve, reject) => {\n      child.once('error', reject);\n      child.once('close', (code, sig) => resolve({ code, sig }));\n    });\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    const stdoutBuffer = stdoutState.captured\n      ? Buffer.concat(stdoutBuffers, stdoutState.captured)\n      : Buffer.alloc(0);\n    const stderrBuffer = stderrState.captured\n      ? Buffer.concat(stderrBuffers, stderrState.captured)\n      : Buffer.alloc(0);\n\n    return {\n      exit_code: typeof finished.code === 'number' ? finished.code : 1,\n      signal: finished.sig,\n      timed_out: timedOut,\n      stdout_bytes: stdoutState.total,\n      stderr_bytes: stderrState.total,\n      stdout_captured_bytes: stdoutState.captured,\n      stderr_captured_bytes: stderrState.captured,\n      stdout_truncated: stdoutState.truncated,\n      stderr_truncated: stderrState.truncated,\n      stdout_buffer: stdoutBuffer,\n      stderr_buffer: stderrBuffer,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 630,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 591,
        "end_line": 616,
        "content": "async resolveGitRoot(repoRoot) {\n    const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n    const result = await this.runGit({\n      cwd: repoRoot,\n      argv: ['rev-parse', '--show-toplevel'],\n      timeoutMs,\n      maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024),\n    });\n\n    if (result.exit_code !== 0) {\n      const stderr = result.stderr_buffer.toString('utf8').trim();\n      throw new Error(stderr || 'Not a git repository');\n    }\n\n    const top = result.stdout_buffer.toString('utf8').trim();\n    if (!top) {\n      throw new Error('Unable to resolve git root');\n    }\n\n    const resolved = await resolveSandboxPath(repoRoot, top);\n    if (resolved !== repoRoot) {\n      throw new Error('repo_root must be the git toplevel directory');\n    }\n\n    return resolved;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 201,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 618,
        "end_line": 637,
        "content": "async writeArtifact(filename, buffer, { traceId, spanId, truncated } = {}) {\n    const contextRoot = resolveContextRepoRoot();\n    if (!contextRoot || !buffer || !buffer.length) {\n      return null;\n    }\n\n    const artifact = await writeBinaryArtifact(\n      contextRoot,\n      buildToolCallFileRef({ traceId, spanId, filename }),\n      buffer\n    );\n\n    return {\n      uri: artifact.uri,\n      rel: artifact.rel,\n      path: artifact.path,\n      bytes: artifact.bytes,\n      truncated: Boolean(truncated),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 131,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 639,
        "end_line": 666,
        "content": "async detectRenderType({ repoRoot, renderType, overlay, chart }) {\n    if (renderType) {\n      return renderType;\n    }\n\n    if (chart) {\n      return 'helm';\n    }\n\n    if (overlay) {\n      const candidate = await resolveSandboxPath(repoRoot, overlay, { mustExist: true });\n      const stat = await fs.stat(candidate);\n      if (stat.isDirectory()) {\n        const markers = ['kustomization.yaml', 'kustomization.yml', 'Kustomization'];\n        for (const marker of markers) {\n          const exists = await fs\n            .stat(path.join(candidate, marker))\n            .then((entry) => entry.isFile())\n            .catch(() => false);\n          if (exists) {\n            return 'kustomize';\n          }\n        }\n      }\n    }\n\n    return 'plain';\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 190,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 668,
        "end_line": 720,
        "content": "async renderPlain({ repoRoot, overlayAbs, maxBytes }) {\n    const stat = await fs.stat(overlayAbs);\n\n    if (stat.isFile()) {\n      if (stat.size > maxBytes) {\n        throw new Error(`Plain render output exceeds max_bytes (${stat.size} > ${maxBytes})`);\n      }\n      const buffer = await fs.readFile(overlayAbs);\n      return { buffer, sources: [path.relative(repoRoot, overlayAbs)] };\n    }\n\n    if (!stat.isDirectory()) {\n      throw new Error('overlay must be a file or directory');\n    }\n\n    const entries = await fs.readdir(overlayAbs, { withFileTypes: true });\n    const yamlFiles = entries\n      .filter((entry) => entry.isFile() && /\\.(ya?ml)$/i.test(entry.name))\n      .map((entry) => entry.name)\n      .sort((a, b) => a.localeCompare(b));\n\n    if (yamlFiles.length === 0) {\n      throw new Error('overlay directory contains no .yaml/.yml files');\n    }\n\n    const sep = Buffer.from('\\n---\\n', 'utf8');\n    const buffers = [];\n    const sources = [];\n    let total = 0;\n\n    for (const name of yamlFiles) {\n      const filePath = path.join(overlayAbs, name);\n      const fileStat = await fs.stat(filePath);\n      total += fileStat.size;\n      if (buffers.length > 0) {\n        total += sep.length;\n      }\n      if (total > maxBytes) {\n        throw new Error(`Plain render output exceeds max_bytes (${total} > ${maxBytes})`);\n      }\n      buffers.push(await fs.readFile(filePath));\n      sources.push(path.relative(repoRoot, filePath));\n    }\n\n    const combined = buffers.length === 1\n      ? buffers[0]\n      : Buffer.concat(\n        buffers.flatMap((buf, idx) => (idx === 0 ? [buf] : [sep, buf])),\n        total\n      );\n\n    return { buffer: combined, sources };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 423,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 722,
        "end_line": 795,
        "content": "async runCommandCapture({ cwd, command, argv, env, timeoutMs, maxBytes, maxStderrBytes }) {\n    const child = spawn(command, argv, {\n      cwd,\n      env,\n      shell: false,\n      windowsHide: true,\n    });\n\n    let stdoutBuffers = [];\n    let stderrBuffers = [];\n    const stdoutState = { total: 0, captured: 0, buffers: stdoutBuffers, truncated: false };\n    const stderrState = { total: 0, captured: 0, buffers: stderrBuffers, truncated: false };\n\n    const capture = (chunk, state, limit) => {\n      const size = chunk.length;\n      state.total += size;\n      if (state.captured >= limit) {\n        state.truncated = true;\n        return;\n      }\n      const remaining = limit - state.captured;\n      if (size <= remaining) {\n        state.buffers.push(chunk);\n        state.captured += size;\n        return;\n      }\n      state.buffers.push(chunk.subarray(0, remaining));\n      state.captured += remaining;\n      state.truncated = true;\n    };\n\n    child.stdout?.on('data', (chunk) => capture(chunk, stdoutState, maxBytes));\n    child.stderr?.on('data', (chunk) => capture(chunk, stderrState, maxStderrBytes));\n\n    let timedOut = false;\n    let timeout;\n    if (timeoutMs) {\n      timeout = setTimeout(() => {\n        timedOut = true;\n        try {\n          child.kill('SIGKILL');\n        } catch (error) {\n        }\n      }, timeoutMs);\n    }\n\n    const finished = await new Promise((resolve, reject) => {\n      child.once('error', reject);\n      child.once('close', (code, sig) => resolve({ code, sig }));\n    });\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    const stdoutBuffer = stdoutState.captured\n      ? Buffer.concat(stdoutBuffers, stdoutState.captured)\n      : Buffer.alloc(0);\n    const stderrBuffer = stderrState.captured\n      ? Buffer.concat(stderrBuffers, stderrState.captured)\n      : Buffer.alloc(0);\n\n    return {\n      exit_code: typeof finished.code === 'number' ? finished.code : 1,\n      signal: finished.sig,\n      timed_out: timedOut,\n      stdout_bytes: stdoutState.total,\n      stderr_bytes: stderrState.total,\n      stdout_truncated: stdoutState.truncated,\n      stderr_truncated: stderrState.truncated,\n      stdout_buffer: stdoutBuffer,\n      stderr_buffer: stderrBuffer,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 560,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 797,
        "end_line": 963,
        "content": "async render(args) {\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const overlay = args.overlay ? this.validation.ensureString(String(args.overlay), 'overlay', { trim: false }) : null;\n    const chart = args.chart ? this.validation.ensureString(String(args.chart), 'chart', { trim: false }) : null;\n    const values = args.values ? this.normalizeArgs(args.values) : [];\n    const requestedType = args.render_type\n      ? this.validation.ensureString(String(args.render_type), 'render_type')\n      : null;\n\n    const renderType = await this.detectRenderType({\n      repoRoot: gitRoot,\n      renderType: requestedType,\n      overlay,\n      chart,\n    });\n\n    const { maxBytes, maxStderrBytes, timeoutMs } = this.resolveRenderBudgets();\n    const traceId = args.trace_id || 'run';\n    const spanId = args.span_id;\n\n    let rendered;\n    let sources;\n    let stderrBuffer = Buffer.alloc(0);\n    let stderrTruncated = false;\n\n    if (renderType === 'plain') {\n      if (!overlay) {\n        throw new Error('overlay is required for render_type=plain');\n      }\n      const overlayAbs = await resolveSandboxPath(gitRoot, overlay, { mustExist: true });\n      const plain = await this.renderPlain({ repoRoot: gitRoot, overlayAbs, maxBytes });\n      rendered = plain.buffer;\n      sources = plain.sources;\n    } else if (renderType === 'kustomize') {\n      if (!overlay) {\n        throw new Error('overlay is required for render_type=kustomize');\n      }\n\n      const allowedCommands = this.resolveAllowedCommands();\n      const command = this.normalizeCommand('kubectl', allowedCommands);\n      this.ensureExecAllowed({ command, argv: ['kustomize'], apply: false });\n\n      const overlayAbs = await resolveSandboxPath(gitRoot, overlay, { mustExist: true });\n      const result = await this.runCommandCapture({\n        cwd: gitRoot,\n        command,\n        argv: ['kustomize', path.relative(gitRoot, overlayAbs)],\n        env: {\n          ...process.env,\n          ...(this.normalizeEnv(args.env) || {}),\n        },\n        timeoutMs,\n        maxBytes,\n        maxStderrBytes,\n      });\n\n      if (result.exit_code !== 0 || result.timed_out) {\n        const message = result.stderr_buffer.toString('utf8').trim() || 'kubectl kustomize failed';\n        throw new Error(message);\n      }\n      if (result.stdout_truncated) {\n        throw new Error(`kubectl kustomize output exceeded max_bytes (${maxBytes})`);\n      }\n\n      rendered = result.stdout_buffer;\n      stderrBuffer = result.stderr_buffer;\n      stderrTruncated = result.stderr_truncated;\n      sources = [overlay];\n    } else if (renderType === 'helm') {\n      if (!chart) {\n        throw new Error('chart is required for render_type=helm');\n      }\n\n      const allowedCommands = this.resolveAllowedCommands();\n      const command = this.normalizeCommand('helm', allowedCommands);\n      this.ensureExecAllowed({ command, argv: ['template'], apply: false });\n\n      const chartAbs = await resolveSandboxPath(gitRoot, chart, { mustExist: true });\n      const chartRel = path.relative(gitRoot, chartAbs);\n      const valueArgs = [];\n\n      for (const file of values) {\n        const valueAbs = await resolveSandboxPath(gitRoot, file, { mustExist: true });\n        valueArgs.push('-f', path.relative(gitRoot, valueAbs));\n      }\n\n      const result = await this.runCommandCapture({\n        cwd: gitRoot,\n        command,\n        argv: ['template', 'release-name', chartRel, ...valueArgs],\n        env: {\n          ...process.env,\n          ...(this.normalizeEnv(args.env) || {}),\n        },\n        timeoutMs,\n        maxBytes,\n        maxStderrBytes,\n      });\n\n      if (result.exit_code !== 0 || result.timed_out) {\n        const message = result.stderr_buffer.toString('utf8').trim() || 'helm template failed';\n        throw new Error(message);\n      }\n      if (result.stdout_truncated) {\n        throw new Error(`helm template output exceeded max_bytes (${maxBytes})`);\n      }\n\n      rendered = result.stdout_buffer;\n      stderrBuffer = result.stderr_buffer;\n      stderrTruncated = result.stderr_truncated;\n      sources = [chart, ...values];\n    } else {\n      throw new Error(`Unsupported render_type: ${renderType}`);\n    }\n\n    if (!rendered || !rendered.length) {\n      throw new Error('Render produced empty output');\n    }\n\n    const extractedImages = extractK8sImages(rendered.toString('utf8'));\n    const imagesRef = await this.writeArtifact(\n      'images.json',\n      Buffer.from(`${JSON.stringify(extractedImages, null, 2)}\\n`, 'utf8'),\n      { traceId, spanId, truncated: false }\n    );\n\n    const renderRef = await this.writeArtifact('render.yaml', rendered, { traceId, spanId, truncated: false });\n\n    const stderrRef = stderrBuffer.length\n      ? await this.writeArtifact('render.stderr.log', stderrBuffer, { traceId, spanId, truncated: stderrTruncated })\n      : null;\n\n    const { maxInlineBytes } = this.resolveExecBudgets();\n    const inlineLimit = Math.min(maxInlineBytes, 64 * 1024);\n    const renderInline = !renderRef\n      ? rendered.subarray(0, inlineLimit).toString('utf8').trimEnd()\n      : undefined;\n    const stderrInline = !stderrRef && stderrBuffer.length\n      ? stderrBuffer.subarray(0, inlineLimit).toString('utf8').trimEnd()\n      : undefined;\n\n    const MAX_IMAGES_INLINE = 200;\n    const imagesInline = extractedImages.images.length > MAX_IMAGES_INLINE\n      ? extractedImages.images.slice(0, MAX_IMAGES_INLINE)\n      : extractedImages.images;\n\n    return {\n      success: true,\n      repo_root: gitRoot,\n      render_type: renderType,\n      sources: sources || [],\n      render_ref: renderRef,\n      render_inline: renderInline,\n      render_inline_truncated: !renderRef && rendered.length > inlineLimit,\n      stderr_ref: stderrRef,\n      stderr_inline: stderrInline,\n      stderr_inline_truncated: !stderrRef && stderrBuffer.length > inlineLimit,\n      images: imagesInline,\n      images_truncated: extractedImages.images.length > MAX_IMAGES_INLINE,\n      images_summary: extractedImages.summary,\n      images_violations: extractedImages.violations,\n      images_ref: imagesRef,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 1559,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 965,
        "end_line": 1006,
        "content": "parseRemoteProvider(remoteUrl) {\n    if (!remoteUrl || typeof remoteUrl !== 'string') {\n      return { provider: 'unknown', owner: null, repo: null };\n    }\n\n    const normalized = remoteUrl.trim();\n    const lower = normalized.toLowerCase();\n    const provider = lower.includes('github.com')\n      ? 'github'\n      : lower.includes('gitlab')\n        ? 'gitlab'\n        : 'unknown';\n\n    let owner = null;\n    let repo = null;\n\n    const stripGit = (value) => value.endsWith('.git') ? value.slice(0, -4) : value;\n\n    if (normalized.startsWith('git@')) {\n      const idx = normalized.indexOf(':');\n      if (idx !== -1) {\n        const rest = stripGit(normalized.slice(idx + 1));\n        const parts = rest.split('/');\n        if (parts.length >= 2) {\n          owner = parts[0];\n          repo = parts[1];\n        }\n      }\n    } else {\n      try {\n        const url = new URL(normalized);\n        const parts = stripGit(url.pathname.replace(/^\\/+/, '')).split('/');\n        if (parts.length >= 2) {\n          owner = parts[0];\n          repo = parts[1];\n        }\n      } catch (error) {\n      }\n    }\n\n    return { provider, owner, repo };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 288,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1008,
        "end_line": 1047,
        "content": "extractPatchPaths(patch) {\n    const paths = new Set();\n    const text = typeof patch === 'string' ? patch : String(patch ?? '');\n    const lines = text.split(/\\r?\\n/);\n\n    for (const line of lines) {\n      if (line.startsWith('diff --git ')) {\n        const parts = line.split(' ');\n        if (parts.length >= 4) {\n          const a = parts[2];\n          const b = parts[3];\n          for (const token of [a, b]) {\n            if (token === '/dev/null') {\n              continue;\n            }\n            if (token.startsWith('a/')) {\n              paths.add(token.slice(2));\n            } else if (token.startsWith('b/')) {\n              paths.add(token.slice(2));\n            }\n          }\n        }\n        continue;\n      }\n\n      if (line.startsWith('+++ ') || line.startsWith('--- ')) {\n        const token = line.slice(4).trim();\n        if (!token || token === '/dev/null') {\n          continue;\n        }\n        if (token.startsWith('a/')) {\n          paths.add(token.slice(2));\n        } else if (token.startsWith('b/')) {\n          paths.add(token.slice(2));\n        }\n      }\n    }\n\n    return Array.from(paths);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 285,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1049,
        "end_line": 1068,
        "content": "async ensurePatchSafe(repoRoot, patch) {\n    const paths = this.extractPatchPaths(patch);\n    for (const rel of paths) {\n      if (!rel || typeof rel !== 'string') {\n        continue;\n      }\n\n      if (rel.includes('\\0')) {\n        throw new Error('Patch contains null bytes in path');\n      }\n      if (rel.startsWith('/') || rel.includes('\\\\')) {\n        throw new Error(`Patch path is not allowed: ${rel}`);\n      }\n      if (rel.split('/').includes('..')) {\n        throw new Error(`Patch path escapes repo_root: ${rel}`);\n      }\n\n      await resolveSandboxPath(repoRoot, rel, { mustExist: false });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 155,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1070,
        "end_line": 1143,
        "content": "async repoInfo(args) {\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n    const run = (argv) => this.runGit({ cwd: gitRoot, argv, timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n\n    const head = await run(['rev-parse', 'HEAD']);\n    const branch = await run(['rev-parse', '--abbrev-ref', 'HEAD']);\n    const status = await run(['status', '--porcelain']);\n    const remotes = await run(['remote', '-v']);\n\n    const sha = head.exit_code === 0 ? head.stdout_buffer.toString('utf8').trim() : null;\n    const branchName = branch.exit_code === 0 ? branch.stdout_buffer.toString('utf8').trim() : null;\n    const dirty = status.exit_code === 0 ? status.stdout_buffer.toString('utf8').trim().length > 0 : null;\n\n    const remoteLines = remotes.exit_code === 0\n      ? remotes.stdout_buffer.toString('utf8').trim().split(/\\r?\\n/).filter(Boolean)\n      : [];\n\n    const remotesByName = {};\n    for (const line of remoteLines) {\n      const parts = line.trim().split(/\\s+/);\n      if (parts.length >= 2) {\n        const name = parts[0];\n        const url = parts[1];\n        if (!remotesByName[name]) {\n          remotesByName[name] = { name, urls: [] };\n        }\n        if (!remotesByName[name].urls.includes(url)) {\n          remotesByName[name].urls.push(url);\n        }\n      }\n    }\n\n    let defaultBranch = null;\n    const originHead = await run(['symbolic-ref', 'refs/remotes/origin/HEAD']).catch(() => null);\n    if (originHead && originHead.exit_code === 0) {\n      const ref = originHead.stdout_buffer.toString('utf8').trim();\n      const parts = ref.split('/');\n      defaultBranch = parts[parts.length - 1] || null;\n    }\n\n    const originUrls = remotesByName.origin?.urls || [];\n    const preferredOriginUrl = originUrls.find((url) => String(url).toLowerCase().includes('github.com'))\n      || originUrls.find((url) => String(url).toLowerCase().includes('gitlab'))\n      || originUrls[0];\n    const provider = this.parseRemoteProvider(preferredOriginUrl);\n\n    const log = await run(['log', '-n', '5', '--pretty=format:%H\\t%s']).catch(() => null);\n    const commits = log && log.exit_code === 0\n      ? log.stdout_buffer\n        .toString('utf8')\n        .split(/\\r?\\n/)\n        .filter(Boolean)\n        .map((line) => {\n          const [hash, ...rest] = line.split('\\t');\n          return { sha: hash, subject: rest.join('\\t') };\n        })\n      : [];\n\n    return {\n      success: true,\n      repo_root: gitRoot,\n      branch: branchName,\n      head: sha,\n      dirty,\n      default_branch: defaultBranch,\n      remotes: Object.values(remotesByName),\n      provider,\n      recent_commits: commits,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 712,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1145,
        "end_line": 1177,
        "content": "async gitDiff(args) {\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n    const diff = await this.runGit({ cwd: gitRoot, argv: ['diff'], timeoutMs, maxCaptureBytes });\n    if (diff.exit_code !== 0) {\n      throw new Error(diff.stderr_buffer.toString('utf8').trim() || 'git diff failed');\n    }\n\n    const diffSha256 = crypto\n      .createHash('sha256')\n      .update(diff.stdout_buffer)\n      .digest('hex');\n\n    const stat = await this.runGit({ cwd: gitRoot, argv: ['diff', '--stat'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n    const diffstat = stat.exit_code === 0 ? stat.stdout_buffer.toString('utf8').trimEnd() : null;\n\n    const traceId = args.trace_id || 'run';\n    const spanId = args.span_id;\n    const diffRef = await this.writeArtifact('diff.patch', diff.stdout_buffer, { traceId, spanId, truncated: diff.stdout_truncated });\n\n    return {\n      success: true,\n      repo_root: gitRoot,\n      diffstat,\n      diff_ref: diffRef,\n      diff_truncated: diff.stdout_truncated,\n      diff_sha256: diffSha256,\n      stderr: diff.stderr_buffer.toString('utf8').trimEnd() || undefined,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 335,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1179,
        "end_line": 1249,
        "content": "async applyPatch(args) {\n    if (args.apply !== true) {\n      throw new Error('apply=true is required for apply_patch');\n    }\n\n    const patch = this.validation.ensureString(String(args.patch ?? ''), 'patch', { trim: false });\n    this.security.ensureSizeFits(patch, { maxBytes: this.resolvePatchBudgetBytes() });\n\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const projectContext = this.projectResolver\n      ? await this.projectResolver.resolveContext(args).catch(() => null)\n      : null;\n\n    const policyGuard = this.policyService\n      ? await this.policyService.guardRepoWrite({\n        action: 'apply_patch',\n        inputs: args,\n        traceId,\n        projectContext,\n        repoRoot: gitRoot,\n      })\n      : null;\n\n    try {\n      await this.ensurePatchSafe(gitRoot, patch);\n\n      const spanId = args.span_id;\n      const patchRef = await this.writeArtifact('patch.diff', Buffer.from(patch, 'utf8'), { traceId, spanId, truncated: false });\n\n      const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-git-patch-'));\n      const tmpPath = path.join(tmpDir, 'patch.diff');\n      try {\n        await fs.writeFile(tmpPath, patch, { encoding: 'utf8', mode: 0o600 });\n\n        const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n        const check = await this.runGit({ cwd: gitRoot, argv: ['apply', '--check', tmpPath], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n        if (check.exit_code !== 0) {\n          throw new Error(check.stderr_buffer.toString('utf8').trim() || 'git apply --check failed');\n        }\n\n        const applied = await this.runGit({ cwd: gitRoot, argv: ['apply', '--whitespace=nowarn', tmpPath], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n        if (applied.exit_code !== 0) {\n          throw new Error(applied.stderr_buffer.toString('utf8').trim() || 'git apply failed');\n        }\n\n        const stat = await this.runGit({ cwd: gitRoot, argv: ['diff', '--stat'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n        const diffstat = stat.exit_code === 0 ? stat.stdout_buffer.toString('utf8').trimEnd() : null;\n\n        return {\n          success: true,\n          repo_root: gitRoot,\n          patch_ref: patchRef,\n          diffstat,\n        };\n      } finally {\n        await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => null);\n      }\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 707,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1251,
        "end_line": 1333,
        "content": "async gitCommit(args) {\n    if (args.apply !== true) {\n      throw new Error('apply=true is required for git_commit');\n    }\n\n    const message = this.validation.ensureString(String(args.message ?? ''), 'message', { trim: false });\n    this.security.ensureSizeFits(message, { maxBytes: this.resolvePatchBudgetBytes() });\n\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const projectContext = this.projectResolver\n      ? await this.projectResolver.resolveContext(args).catch(() => null)\n      : null;\n\n    const policyGuard = this.policyService\n      ? await this.policyService.guardRepoWrite({\n        action: 'git_commit',\n        inputs: args,\n        traceId,\n        projectContext,\n        repoRoot: gitRoot,\n      })\n      : null;\n\n    try {\n      const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n\n      const add = await this.runGit({ cwd: gitRoot, argv: ['add', '-A'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n      if (add.exit_code !== 0) {\n        throw new Error(add.stderr_buffer.toString('utf8').trim() || 'git add failed');\n      }\n\n      const staged = await this.runGit({ cwd: gitRoot, argv: ['diff', '--cached', '--name-only'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n      const stagedList = staged.exit_code === 0\n        ? staged.stdout_buffer.toString('utf8').trim().split(/\\r?\\n/).filter(Boolean)\n        : [];\n      if (stagedList.length === 0) {\n        throw new Error('No staged changes to commit');\n      }\n\n      const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-git-commit-'));\n      const msgPath = path.join(tmpDir, 'message.txt');\n      try {\n        await fs.writeFile(msgPath, message, { encoding: 'utf8', mode: 0o600 });\n\n        const commit = await this.runGit({\n          cwd: gitRoot,\n          argv: ['-c', 'commit.gpgSign=false', 'commit', '-F', msgPath],\n          timeoutMs,\n          maxCaptureBytes: maxCaptureBytes,\n        });\n\n        if (commit.exit_code !== 0) {\n          throw new Error(commit.stderr_buffer.toString('utf8').trim() || 'git commit failed');\n        }\n\n        const head = await this.runGit({ cwd: gitRoot, argv: ['rev-parse', 'HEAD'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n        if (head.exit_code !== 0) {\n          throw new Error(head.stderr_buffer.toString('utf8').trim() || 'git rev-parse HEAD failed');\n        }\n\n        return {\n          success: true,\n          repo_root: gitRoot,\n          sha: head.stdout_buffer.toString('utf8').trim(),\n          committed_files: stagedList,\n        };\n      } finally {\n        await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => null);\n      }\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 783,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1335,
        "end_line": 1416,
        "content": "async gitRevert(args) {\n    if (args.apply !== true) {\n      throw new Error('apply=true is required for git_revert');\n    }\n\n    const sha = this.validation.ensureString(String(args.sha ?? ''), 'sha');\n    const mainline = args.mainline === undefined || args.mainline === null || args.mainline === ''\n      ? null\n      : Number(args.mainline);\n    if (mainline !== null) {\n      if (!Number.isFinite(mainline) || mainline <= 0) {\n        throw new Error('mainline must be a positive integer');\n      }\n    }\n\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const projectContext = this.projectResolver\n      ? await this.projectResolver.resolveContext(args).catch(() => null)\n      : null;\n\n    const policyGuard = this.policyService\n      ? await this.policyService.guardRepoWrite({\n        action: 'git_revert',\n        inputs: args,\n        traceId,\n        projectContext,\n        repoRoot: gitRoot,\n      })\n      : null;\n\n    try {\n      const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n\n      const argv = ['-c', 'commit.gpgSign=false', 'revert', '--no-edit'];\n      if (mainline !== null) {\n        argv.push('-m', String(Math.floor(mainline)));\n      }\n      argv.push(sha);\n\n      const revert = await this.runGit({ cwd: gitRoot, argv, timeoutMs, maxCaptureBytes });\n      if (revert.exit_code !== 0) {\n        throw new Error(revert.stderr_buffer.toString('utf8').trim() || 'git revert failed');\n      }\n\n      const spanId = args.span_id;\n      const revertLog = await this.writeArtifact('revert.log', Buffer.concat([revert.stdout_buffer, revert.stderr_buffer]), {\n        traceId,\n        spanId,\n        truncated: revert.stdout_truncated || revert.stderr_truncated,\n      });\n\n      const head = await this.runGit({\n        cwd: gitRoot,\n        argv: ['rev-parse', 'HEAD'],\n        timeoutMs,\n        maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024),\n      });\n      if (head.exit_code !== 0) {\n        throw new Error(head.stderr_buffer.toString('utf8').trim() || 'git rev-parse HEAD failed');\n      }\n\n      return {\n        success: true,\n        repo_root: gitRoot,\n        reverted_sha: sha,\n        head: head.stdout_buffer.toString('utf8').trim(),\n        revert_ref: revertLog,\n      };\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 668,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1418,
        "end_line": 1487,
        "content": "async gitPush(args) {\n    if (args.apply !== true) {\n      throw new Error('apply=true is required for git_push');\n    }\n\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const gitRoot = await this.resolveGitRoot(repoRoot);\n\n    const remote = args.remote ? this.validation.ensureString(String(args.remote), 'remote') : 'origin';\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const projectContext = this.projectResolver\n      ? await this.projectResolver.resolveContext(args).catch(() => null)\n      : null;\n\n    const policyGuard = this.policyService\n      ? await this.policyService.guardRepoWrite({\n        action: 'git_push',\n        inputs: { ...args, remote },\n        traceId,\n        projectContext,\n        repoRoot: gitRoot,\n      })\n      : null;\n\n    try {\n      const { maxCaptureBytes, timeoutMs } = this.resolveExecBudgets();\n\n      let branch = args.branch ? this.validation.ensureString(String(args.branch), 'branch') : null;\n      if (!branch) {\n        const current = await this.runGit({ cwd: gitRoot, argv: ['rev-parse', '--abbrev-ref', 'HEAD'], timeoutMs, maxCaptureBytes: Math.min(maxCaptureBytes, 64 * 1024) });\n        if (current.exit_code !== 0) {\n          throw new Error(current.stderr_buffer.toString('utf8').trim() || 'Unable to resolve current branch');\n        }\n        branch = current.stdout_buffer.toString('utf8').trim();\n        if (!branch || branch === 'HEAD') {\n          throw new Error('Detached HEAD cannot be pushed without explicit branch');\n        }\n      }\n\n      const push = await this.runGit({ cwd: gitRoot, argv: ['push', remote, branch], timeoutMs, maxCaptureBytes });\n      if (push.exit_code !== 0) {\n        throw new Error(push.stderr_buffer.toString('utf8').trim() || 'git push failed');\n      }\n\n      const spanId = args.span_id;\n      const pushLog = await this.writeArtifact('push.log', Buffer.concat([push.stdout_buffer, push.stderr_buffer]), {\n        traceId,\n        spanId,\n        truncated: push.stdout_truncated || push.stderr_truncated,\n      });\n\n      return {\n        success: true,\n        repo_root: gitRoot,\n        remote,\n        branch,\n        push_ref: pushLog,\n      };\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 623,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1489,
        "end_line": 1545,
        "content": "ensureExecAllowed({ command, argv, apply }) {\n    if (apply) {\n      return;\n    }\n\n    if (!argv || argv.length === 0) {\n      throw new Error(`${command} subcommand is required`);\n    }\n\n    let subcommand = argv[0];\n    let subcommandIndex = 0;\n    if (command === 'kubectl') {\n      const found = findKubectlToken(argv, 0);\n      if (!found) {\n        throw new Error('kubectl subcommand is required');\n      }\n      subcommand = found.token;\n      subcommandIndex = found.index;\n    } else {\n      if (typeof subcommand !== 'string' || !subcommand.trim()) {\n        throw new Error(`${command} subcommand is required`);\n      }\n      if (subcommand.startsWith('-')) {\n        throw new Error(`${command} subcommand must be the first argument when apply=false`);\n      }\n    }\n\n    if (command === 'git') {\n      if (!READ_ONLY_GIT_SUBCOMMANDS.has(subcommand)) {\n        throw new Error(`git ${subcommand} requires apply=true`);\n      }\n      return;\n    }\n\n    if (command === 'kubectl') {\n      if (READ_ONLY_EXEC_SUBCOMMANDS.kubectl?.has(subcommand)) {\n        return;\n      }\n      const nested = READ_ONLY_EXEC_SUBSUBCOMMANDS.kubectl?.[subcommand];\n      if (nested) {\n        const second = findKubectlToken(argv, subcommandIndex + 1);\n        if (!second) {\n          throw new Error(`kubectl ${subcommand} subcommand is required`);\n        }\n        if (!nested.has(second.token)) {\n          throw new Error(`kubectl ${subcommand} ${second.token} requires apply=true`);\n        }\n        return;\n      }\n      throw new Error(`kubectl ${subcommand} requires apply=true`);\n    }\n\n    const allowed = READ_ONLY_EXEC_SUBCOMMANDS[command];\n    if (!allowed || !allowed.has(subcommand)) {\n      throw new Error(`${command} ${subcommand} requires apply=true`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 446,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1547,
        "end_line": 1802,
        "content": "async exec(args) {\n    const allowedCommands = this.resolveAllowedCommands();\n    const { maxCaptureBytes, maxInlineBytes, timeoutMs } = this.resolveExecBudgets();\n\n    const apply = args.apply === true;\n    const command = this.normalizeCommand(args.command, allowedCommands);\n    const argv = this.normalizeArgs(args.args);\n\n    if (command === 'git') {\n      const first = argv[0];\n      if (first === '-c' || first === '--config' || first === '--config-env') {\n        throw new Error('git exec forbids global -c/--config flags');\n      }\n      if (typeof first === 'string' && first.startsWith('--config=')) {\n        throw new Error('git exec forbids global --config flags');\n      }\n    }\n\n    this.ensureExecAllowed({ command, argv, apply });\n\n    const isWrite = apply && (() => {\n      if (!argv || argv.length === 0) {\n        return true;\n      }\n      const subcommand = argv[0];\n      if (command === 'git') {\n        return !(typeof subcommand === 'string' && READ_ONLY_GIT_SUBCOMMANDS.has(subcommand));\n      }\n      if (command === 'kubectl') {\n        return !isKubectlReadOnly(argv);\n      }\n      const allowed = READ_ONLY_EXEC_SUBCOMMANDS[command];\n      if (!allowed) {\n        return true;\n      }\n      return !(typeof subcommand === 'string' && allowed.has(subcommand));\n    })();\n\n    const repoRootRaw = await this.resolveRepoRoot(args);\n    const repoRoot = await resolveSandboxPath(repoRootRaw, null);\n    const cwd = args.cwd\n      ? await resolveSandboxPath(repoRoot, this.validation.ensureString(String(args.cwd), 'cwd', { trim: false }))\n      : repoRoot;\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const projectContext = this.projectResolver\n      ? await this.projectResolver.resolveContext(args).catch(() => null)\n      : null;\n\n    const kubectlNamespace = command === 'kubectl' ? extractKubectlNamespace(argv) : null;\n\n    const policyGuard = isWrite && this.policyService\n      ? (command === 'kubectl'\n        ? await this.policyService.guardKubectlWrite({\n          inputs: { ...args, namespace: kubectlNamespace },\n          traceId,\n          projectContext,\n          repoRoot,\n        })\n        : await this.policyService.guardRepoWrite({\n          action: `exec:${command}`,\n          inputs: args,\n          traceId,\n          projectContext,\n          repoRoot,\n        }))\n      : null;\n\n    const env = {\n      ...process.env,\n      ...(this.normalizeEnv(args.env) || {}),\n    };\n\n    const stdin = args.stdin;\n    if (stdin !== undefined && stdin !== null) {\n      this.security.ensureSizeFits(String(stdin), { maxBytes: maxInlineBytes * 32 });\n    }\n\n    const started = Date.now();\n    try {\n      const child = spawn(command, command === 'git' ? ['--no-pager', ...argv] : argv, {\n        cwd,\n        env,\n        shell: false,\n        windowsHide: true,\n      });\n\n      if (stdin !== undefined && stdin !== null) {\n        child.stdin?.end(String(stdin));\n      } else {\n        child.stdin?.end();\n      }\n\n      let stdoutTotal = 0;\n      let stderrTotal = 0;\n      let stdoutBuffers = [];\n      let stderrBuffers = [];\n      let stdoutCaptured = 0;\n      let stderrCaptured = 0;\n      let stdoutTruncated = false;\n      let stderrTruncated = false;\n      let timedOut = false;\n\n    const capture = (chunk, state) => {\n      const size = chunk.length;\n      state.total += size;\n      if (state.captured >= maxCaptureBytes) {\n        state.truncated = true;\n        return;\n      }\n      const remaining = maxCaptureBytes - state.captured;\n      if (size <= remaining) {\n        state.buffers.push(chunk);\n        state.captured += size;\n        return;\n      }\n      state.buffers.push(chunk.subarray(0, remaining));\n      state.captured += remaining;\n      state.truncated = true;\n    };\n\n      const stdoutState = { total: 0, captured: 0, buffers: stdoutBuffers, truncated: false };\n      const stderrState = { total: 0, captured: 0, buffers: stderrBuffers, truncated: false };\n\n      if (child.stdout) {\n        child.stdout.on('data', (chunk) => capture(chunk, stdoutState));\n      }\n      if (child.stderr) {\n        child.stderr.on('data', (chunk) => capture(chunk, stderrState));\n      }\n\n      let timeout;\n      if (timeoutMs) {\n        timeout = setTimeout(() => {\n          timedOut = true;\n          try {\n            child.kill('SIGKILL');\n          } catch (error) {\n          }\n        }, timeoutMs);\n      }\n\n      let exitCode = 1;\n      let signal;\n\n      const finished = await new Promise((resolve, reject) => {\n        child.once('error', reject);\n        child.once('close', (code, sig) => resolve({ code, sig }));\n      });\n\n      exitCode = typeof finished.code === 'number' ? finished.code : 1;\n      signal = finished.sig;\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      stdoutTotal = stdoutState.total;\n      stderrTotal = stderrState.total;\n      stdoutCaptured = stdoutState.captured;\n      stderrCaptured = stderrState.captured;\n      stdoutTruncated = stdoutState.truncated;\n      stderrTruncated = stderrState.truncated;\n\n      const stdoutBuffer = stdoutCaptured ? Buffer.concat(stdoutBuffers, stdoutCaptured) : Buffer.alloc(0);\n      const stderrBuffer = stderrCaptured ? Buffer.concat(stderrBuffers, stderrCaptured) : Buffer.alloc(0);\n\n      const contextRoot = resolveContextRepoRoot();\n      const spanId = args.span_id;\n\n      const stdoutArtifact = contextRoot && stdoutBuffer.length\n        ? await writeBinaryArtifact(\n          contextRoot,\n          buildToolCallFileRef({ traceId, spanId, filename: 'stdout.log' }),\n          stdoutBuffer\n        )\n        : null;\n\n      const stderrArtifact = contextRoot && stderrBuffer.length\n        ? await writeBinaryArtifact(\n          contextRoot,\n          buildToolCallFileRef({ traceId, spanId, filename: 'stderr.log' }),\n          stderrBuffer\n        )\n        : null;\n\n      const inline = args.inline === true;\n      const decodeInline = (buffer) => {\n        if (!inline || !buffer.length) {\n          return { text: undefined, truncated: false };\n        }\n        const sliced = buffer.length > maxInlineBytes ? buffer.subarray(0, maxInlineBytes) : buffer;\n        return {\n          text: sliced.toString('utf8').trimEnd(),\n          truncated: buffer.length > maxInlineBytes,\n        };\n      };\n\n      const stdoutInline = decodeInline(stdoutBuffer);\n      const stderrInline = decodeInline(stderrBuffer);\n\n      let stdoutJson;\n      let stdoutJsonError;\n      if (args.parse_json === true) {\n        if (stdoutTruncated) {\n          stdoutJsonError = 'stdout truncated';\n        } else if (stdoutBuffer.length) {\n          try {\n            stdoutJson = JSON.parse(stdoutBuffer.toString('utf8'));\n          } catch (error) {\n            stdoutJsonError = error.message;\n          }\n        }\n      }\n\n      this.stats.exec += 1;\n\n      return {\n        success: exitCode === 0 && !timedOut,\n        repo_root: repoRoot,\n        cwd,\n        command,\n        args: argv,\n        exit_code: exitCode,\n        signal,\n        timed_out: timedOut,\n        duration_ms: Date.now() - started,\n        stdout_bytes: stdoutTotal,\n        stderr_bytes: stderrTotal,\n        stdout_captured_bytes: stdoutCaptured,\n        stderr_captured_bytes: stderrCaptured,\n        stdout_truncated: stdoutTruncated,\n        stderr_truncated: stderrTruncated,\n        stdout_inline: stdoutInline.text,\n        stderr_inline: stderrInline.text,\n        stdout_inline_truncated: stdoutInline.truncated,\n        stderr_inline_truncated: stderrInline.truncated,\n        stdout_json: stdoutJson,\n        stdout_json_error: stdoutJsonError,\n        stdout_ref: stdoutArtifact\n          ? { uri: stdoutArtifact.uri, rel: stdoutArtifact.rel, bytes: stdoutArtifact.bytes, truncated: stdoutTruncated }\n          : null,\n        stderr_ref: stderrArtifact\n          ? { uri: stderrArtifact.uri, rel: stderrArtifact.rel, bytes: stderrArtifact.bytes, truncated: stderrTruncated }\n          : null,\n      };\n    } finally {\n      if (policyGuard) {\n        try {\n          await policyGuard.release();\n        } catch (error) {\n          this.logger.warn('Failed to release policy lock', { error: error.message });\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 2053,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RepoManager.ts",
        "start_line": 1804,
        "end_line": 1806,
        "content": "getStats() {\n    return { ...this.stats };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RepoManager",
          "estimated_tokens": 13,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/RunbookManager.ts": [
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 19,
        "end_line": 25,
        "content": "function asPositiveInt(value, fallback) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return fallback;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "asPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "asPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 27,
        "end_line": 33,
        "content": "function asNonNegativeInt(value, fallback) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric < 0) {\n    return fallback;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "asNonNegativeInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 46,
          "qualified_name": "asNonNegativeInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 35,
        "end_line": 41,
        "content": "function asPositiveNumber(value, fallback) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return fallback;\n  }\n  return numeric;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "asPositiveNumber",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 43,
          "qualified_name": "asPositiveNumber",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 44,
        "end_line": 49,
        "content": "constructor(logger, runbookService, stateService, toolExecutor) {\n    this.logger = logger.child('runbook');\n    this.runbookService = runbookService;\n    this.stateService = stateService;\n    this.toolExecutor = toolExecutor;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 60,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 51,
        "end_line": 74,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'runbook_upsert':\n        return this.runbookUpsert(args.name, args.runbook || args);\n      case 'runbook_upsert_dsl':\n        return this.runbookUpsert(args.name, this.runbookCompile(args.dsl || args.text || ''));\n      case 'runbook_get':\n        return this.runbookGet(args.name);\n      case 'runbook_list':\n        return this.runbookList();\n      case 'runbook_delete':\n        return this.runbookDelete(args.name);\n      case 'runbook_run':\n        return this.runbookRun(args);\n      case 'runbook_run_dsl':\n        return this.runbookRun({ ...args, runbook: this.runbookCompile(args.dsl || args.text || '') });\n      case 'runbook_compile':\n        return { success: true, runbook: this.runbookCompile(args.dsl || args.text || '') };\n      default:\n        throw new Error(`Unknown runbook action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 233,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 76,
        "end_line": 79,
        "content": "async runbookUpsert(name, payload) {\n    const runbook = payload.runbook || payload;\n    return this.runbookService.setRunbook(name, runbook);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 81,
        "end_line": 83,
        "content": "async runbookGet(name) {\n    return this.runbookService.getRunbook(name);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 22,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 85,
        "end_line": 87,
        "content": "async runbookList() {\n    return this.runbookService.listRunbooks();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 89,
        "end_line": 91,
        "content": "async runbookDelete(name) {\n    return this.runbookService.deleteRunbook(name);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 23,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 93,
        "end_line": 95,
        "content": "runbookCompile(dsl) {\n    return parseRunbookDsl(dsl);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 97,
        "end_line": 169,
        "content": "async runbookRun(args) {\n    const input = args.input && typeof args.input === 'object' ? args.input : {};\n    const stopOnError = args.stop_on_error !== false;\n    const templateMissing = args.template_missing || 'error';\n    const traceId = args.trace_id || crypto.randomUUID();\n    const runbookSpanId = args.span_id || crypto.randomUUID();\n\n    if (args.seed_state && typeof args.seed_state === 'object') {\n      const scope = args.seed_state_scope || 'session';\n      for (const [key, value] of Object.entries(args.seed_state)) {\n        await this.stateService.set(key, value, scope);\n      }\n    }\n\n    let runbookPayload;\n    if (args.runbook) {\n      runbookPayload = args.runbook;\n    } else if (args.name) {\n      const stored = await this.runbookService.getRunbook(args.name);\n      runbookPayload = stored.runbook;\n    } else {\n      throw new Error('runbook_run requires name or runbook');\n    }\n\n    if (!Array.isArray(runbookPayload.steps) || runbookPayload.steps.length === 0) {\n      throw new Error('runbook.steps must be a non-empty array');\n    }\n\n    const results = [];\n    const context = await this.buildContext(input, {}, { traceId, spanId: runbookSpanId, parentSpanId: args.parent_span_id });\n\n    for (let index = 0; index < runbookPayload.steps.length; index += 1) {\n      const step = runbookPayload.steps[index];\n      const stepKey = step.id || step.name || `step_${index + 1}`;\n\n      try {\n        const outcome = await this.executeStep(step, stepKey, context, {\n          missing: templateMissing,\n          traceId,\n          parentSpanId: runbookSpanId,\n        });\n        results.push(outcome);\n        context.steps[stepKey] = outcome.result;\n      } catch (error) {\n        const entry = {\n          id: stepKey,\n          tool: step.tool,\n          action: step.args?.action,\n          success: false,\n          error: error.message,\n        };\n        results.push(entry);\n        if (stopOnError && !step.continue_on_error) {\n          return {\n            success: false,\n            runbook: args.name || runbookPayload.name,\n            steps: results,\n            error: error.message,\n          };\n        }\n      }\n\n      const refreshedState = await this.stateService.dump('any');\n      context.state = refreshedState.state;\n    }\n\n    return {\n      success: results.every((item) => item.success !== false),\n      runbook: args.name || runbookPayload.name,\n      steps: results,\n      trace_id: traceId,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 619,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 171,
        "end_line": 181,
        "content": "async buildContext(input, steps, meta = {}) {\n    const snapshot = await this.stateService.dump('any');\n    return {\n      input,\n      state: snapshot.state,\n      steps,\n      trace_id: meta.traceId,\n      span_id: meta.spanId,\n      parent_span_id: meta.parentSpanId,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 73,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 183,
        "end_line": 262,
        "content": "evaluateWhen(condition, context, options) {\n    if (condition === undefined || condition === null) {\n      return true;\n    }\n\n    if (typeof condition === 'boolean') {\n      return condition;\n    }\n\n    if (typeof condition === 'string') {\n      const resolved = resolveTemplateString(condition, context, options);\n      return !!resolved;\n    }\n\n    if (typeof condition !== 'object') {\n      return false;\n    }\n\n    if (Array.isArray(condition.and)) {\n      return condition.and.every((entry) => this.evaluateWhen(entry, context, options));\n    }\n    if (Array.isArray(condition.or)) {\n      return condition.or.some((entry) => this.evaluateWhen(entry, context, options));\n    }\n    if (condition.not !== undefined) {\n      return !this.evaluateWhen(condition.not, context, options);\n    }\n\n    const path = condition.path ? resolveTemplateString(condition.path, context, options) : undefined;\n    const value = path ? getPathValue(context, path, { defaultValue: undefined }) : condition.value;\n\n    if (condition.exists !== undefined) {\n      return condition.exists ? value !== undefined : value === undefined;\n    }\n\n    if (condition.equals !== undefined) {\n      const expected = resolveTemplates(condition.equals, context, options);\n      return value === expected;\n    }\n\n    if (condition.not_equals !== undefined) {\n      const expected = resolveTemplates(condition.not_equals, context, options);\n      return value !== expected;\n    }\n\n    if (condition.in !== undefined) {\n      const expected = resolveTemplates(condition.in, context, options);\n      return Array.isArray(expected) ? expected.includes(value) : false;\n    }\n\n    if (condition.contains !== undefined) {\n      const expected = resolveTemplates(condition.contains, context, options);\n      if (typeof value === 'string') {\n        return value.includes(String(expected));\n      }\n      if (Array.isArray(value)) {\n        return value.includes(expected);\n      }\n      return false;\n    }\n\n    if (condition.gt !== undefined) {\n      const expected = Number(resolveTemplates(condition.gt, context, options));\n      return Number(value) > expected;\n    }\n    if (condition.gte !== undefined) {\n      const expected = Number(resolveTemplates(condition.gte, context, options));\n      return Number(value) >= expected;\n    }\n    if (condition.lt !== undefined) {\n      const expected = Number(resolveTemplates(condition.lt, context, options));\n      return Number(value) < expected;\n    }\n    if (condition.lte !== undefined) {\n      const expected = Number(resolveTemplates(condition.lte, context, options));\n      return Number(value) <= expected;\n    }\n\n    return !!value;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 667,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 264,
        "end_line": 426,
        "content": "async executeStep(step, stepKey, context, options) {\n    if (!step || typeof step !== 'object') {\n      throw new Error('runbook step must be an object');\n    }\n    if (!step.tool) {\n      throw new Error(`runbook step '${stepKey}' missing tool`);\n    }\n\n    if (step.tool === 'mcp_runbook') {\n      throw new Error('Nested runbook execution is not supported');\n    }\n\n    const shouldRun = this.evaluateWhen(step.when, context, options);\n    if (!shouldRun) {\n      return { id: stepKey, tool: step.tool, action: step.args?.action, skipped: true, success: true };\n    }\n\n    const baseArgs = step.args || {};\n    const resolvedArgs = step.foreach ? baseArgs : resolveTemplates(baseArgs, context, options);\n    const retryConfig = step.retry ? resolveTemplates(step.retry, context, options) : null;\n    const applyTrace = (args) => {\n      const merged = { ...args };\n      if (options?.traceId && merged.trace_id === undefined) {\n        merged.trace_id = options.traceId;\n      }\n      if (options?.parentSpanId && merged.parent_span_id === undefined) {\n        merged.parent_span_id = options.parentSpanId;\n      }\n      return merged;\n    };\n\n    if (step.foreach) {\n      if (retryConfig) {\n        throw new Error(`runbook step '${stepKey}' cannot combine foreach with retry`);\n      }\n      const foreachConfig = resolveTemplates(step.foreach, context, options);\n      const items = foreachConfig.items;\n      if (!Array.isArray(items)) {\n        throw new Error(`runbook step '${stepKey}' foreach.items must be an array`);\n      }\n\n      const results = [];\n      const parallel = foreachConfig.parallel === true;\n\n      const runItem = async (item, index) => {\n        const itemContext = {\n          ...context,\n          item,\n          index,\n        };\n        const argsForItem = resolveTemplates(baseArgs, itemContext, options);\n        return this.toolExecutor.execute(step.tool, applyTrace(argsForItem));\n      };\n\n      if (parallel) {\n        const output = await Promise.all(items.map((item, index) => runItem(item, index)));\n        output.forEach((entry) => results.push(entry.result));\n      } else {\n        for (let idx = 0; idx < items.length; idx += 1) {\n          const entry = await runItem(items[idx], idx);\n          results.push(entry.result);\n        }\n      }\n\n      return {\n        id: stepKey,\n        tool: step.tool,\n        action: resolvedArgs.action,\n        success: true,\n        result: results,\n        foreach: { count: items.length },\n      };\n    }\n\n    if (retryConfig && typeof retryConfig === 'object' && retryConfig.max_attempts !== undefined) {\n      const maxAttempts = Math.min(\n        asPositiveInt(retryConfig.max_attempts, 1),\n        MAX_RETRY_ATTEMPTS\n      );\n      const delayMs = Math.min(\n        asNonNegativeInt(retryConfig.delay_ms ?? retryConfig.base_delay_ms, 0),\n        MAX_RETRY_DELAY_MS\n      );\n      const backoffFactor = asPositiveNumber(retryConfig.backoff_factor ?? retryConfig.backoff, 1);\n      const maxDelayMs = retryConfig.max_delay_ms === undefined || retryConfig.max_delay_ms === null\n        ? null\n        : Math.min(asNonNegativeInt(retryConfig.max_delay_ms, delayMs), MAX_RETRY_DELAY_MS);\n      const retryOnError = retryConfig.retry_on_error !== false;\n      const until = retryConfig.until;\n\n      const attempts = [];\n      let totalDelayMs = 0;\n      let lastError = null;\n\n      for (let attemptIndex = 0; attemptIndex < maxAttempts; attemptIndex += 1) {\n        const attempt = { index: attemptIndex, number: attemptIndex + 1, max_attempts: maxAttempts };\n        const attemptContext = { ...context, attempt };\n\n        try {\n          const argsForAttempt = resolveTemplates(baseArgs, attemptContext, options);\n          const output = await this.toolExecutor.execute(step.tool, applyTrace(argsForAttempt));\n          attempts.push({ success: true, result: output.result });\n\n          const untilContext = { ...attemptContext, result: output.result, meta: output.meta };\n          const satisfied = until === undefined || until === null\n            ? true\n            : this.evaluateWhen(until, untilContext, options);\n\n          if (satisfied) {\n            return {\n              id: stepKey,\n              tool: step.tool,\n              action: argsForAttempt.action,\n              success: true,\n              result: output.result,\n              meta: output.meta,\n              retry: { attempts: attemptIndex + 1 },\n            };\n          }\n\n          lastError = new Error(`retry condition not satisfied (attempt ${attemptIndex + 1}/${maxAttempts})`);\n        } catch (error) {\n          lastError = error;\n          attempts.push({ success: false, error: error.message });\n          if (!retryOnError) {\n            throw error;\n          }\n        }\n\n        if (attemptIndex >= maxAttempts - 1) {\n          break;\n        }\n\n        let nextDelay = delayMs;\n        if (backoffFactor !== 1 && delayMs > 0) {\n          nextDelay = Math.floor(delayMs * Math.pow(backoffFactor, attemptIndex));\n        }\n        if (maxDelayMs !== null) {\n          nextDelay = Math.min(nextDelay, maxDelayMs);\n        }\n        if (nextDelay > 0) {\n          if (totalDelayMs + nextDelay > MAX_RETRY_TOTAL_DELAY_MS) {\n            throw new Error(`retry budget exceeded (${MAX_RETRY_TOTAL_DELAY_MS}ms)`);\n          }\n          totalDelayMs += nextDelay;\n          await sleep(nextDelay);\n        }\n      }\n\n      const message = lastError ? lastError.message : 'retry attempts exhausted';\n      throw new Error(`Retry failed after ${maxAttempts} attempts: ${message}`);\n    }\n\n    const output = await this.toolExecutor.execute(step.tool, applyTrace(resolvedArgs));\n    return {\n      id: stepKey,\n      tool: step.tool,\n      action: resolvedArgs.action,\n      success: true,\n      result: output.result,\n      meta: output.meta,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 1461,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 428,
        "end_line": 430,
        "content": "getStats() {\n    return this.runbookService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/RunbookManager.ts",
        "start_line": 432,
        "end_line": 434,
        "content": "async cleanup() {\n    await this.runbookService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/SSHManager.ts": [
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 25,
        "end_line": 27,
        "content": "function profileKey(profileName) {\n  return profileName;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "profileKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 14,
          "qualified_name": "profileKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 29,
        "end_line": 47,
        "content": "function normalizeHostKeyPolicy(value) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  const normalized = String(value).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n  if (normalized === 'accept') {\n    return 'accept';\n  }\n  if (normalized === 'tofu') {\n    return 'tofu';\n  }\n  if (normalized === 'pin') {\n    return 'pin';\n  }\n  throw new Error(`Unknown host_key_policy: ${normalized}`);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeHostKeyPolicy",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 108,
          "qualified_name": "normalizeHostKeyPolicy",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 49,
        "end_line": 62,
        "content": "function normalizeFingerprintSha256(value) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  const trimmed = String(value).trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPadding = trimmed.replace(/=+$/g, '');\n  if (/^sha256:/i.test(withoutPadding)) {\n    return `SHA256:${withoutPadding.slice(7)}`;\n  }\n  return `SHA256:${withoutPadding}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeFingerprintSha256",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 94,
          "qualified_name": "normalizeFingerprintSha256",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 64,
        "end_line": 70,
        "content": "function fingerprintHostKeySha256(key) {\n  if (!Buffer.isBuffer(key)) {\n    throw new Error('SSH host key is not a Buffer');\n  }\n  const hash = crypto.createHash('sha256').update(key).digest('base64');\n  return `SHA256:${hash.replace(/=+$/g, '')}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "fingerprintHostKeySha256",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "fingerprintHostKeySha256",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 72,
        "end_line": 75,
        "content": "function escapeShellValue(value) {\n  const str = String(value);\n  return `'${str.replace(/'/g, \"'\\\\''\")}'`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "escapeShellValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 27,
          "qualified_name": "escapeShellValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 77,
        "end_line": 86,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric) || numeric <= 0) {\n    return null;\n  }\n  return Math.floor(numeric);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 63,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 88,
        "end_line": 90,
        "content": "function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "sleep",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 20,
          "qualified_name": "sleep",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 92,
        "end_line": 111,
        "content": "function resolveStreamToArtifactMode() {\n  const raw = process.env.SENTRYFROGG_SSH_STREAM_TO_ARTIFACT\n    || process.env.SF_SSH_STREAM_TO_ARTIFACT\n    || process.env.SENTRYFROGG_STREAM_TO_ARTIFACT\n    || process.env.SF_STREAM_TO_ARTIFACT;\n  if (raw === undefined || raw === null) {\n    return null;\n  }\n  const normalized = String(raw).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n  if (normalized === 'full') {\n    return 'full';\n  }\n  if (normalized === 'capped') {\n    return 'capped';\n  }\n  return isTruthy(normalized) ? 'capped' : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveStreamToArtifactMode",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 140,
          "qualified_name": "resolveStreamToArtifactMode",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 113,
        "end_line": 115,
        "content": "function isStreamToArtifactEnabled() {\n  return Boolean(resolveStreamToArtifactMode());\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isStreamToArtifactEnabled",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "isStreamToArtifactEnabled",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 117,
        "end_line": 143,
        "content": "function normalizePublicKeyLine(raw) {\n  const normalized = String(raw ?? '').replace(/\\r/g, '');\n  const lines = normalized\n    .split('\\n')\n    .map((line) => line.trim())\n    .filter((line) => line.length > 0 && !line.startsWith('#'));\n\n  if (lines.length === 0) {\n    throw new Error('public_key must contain a single key line');\n  }\n\n  if (lines.length > 1) {\n    throw new Error('public_key must be a single key line');\n  }\n\n  const line = lines[0];\n  if (line.includes('\\0')) {\n    throw new Error('public_key must not contain null bytes');\n  }\n\n  const tokens = line.split(/\\s+/);\n  if (tokens.length < 2) {\n    throw new Error('public_key has invalid format (expected: \"<type> <base64> [comment]\")');\n  }\n\n  return line;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizePublicKeyLine",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 182,
          "qualified_name": "normalizePublicKeyLine",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 145,
        "end_line": 151,
        "content": "function parsePublicKeyTokens(line) {\n  const tokens = String(line || '').trim().split(/\\s+/);\n  if (tokens.length < 2) {\n    throw new Error('public_key has invalid format (expected: \"<type> <base64> [comment]\")');\n  }\n  return { keyType: tokens[0], keyBlob: tokens[1] };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parsePublicKeyTokens",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 68,
          "qualified_name": "parsePublicKeyTokens",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 153,
        "end_line": 158,
        "content": "function fingerprintPublicKeySha256(line) {\n  const { keyBlob } = parsePublicKeyTokens(line);\n  const bytes = Buffer.from(keyBlob, 'base64');\n  const hash = crypto.createHash('sha256').update(bytes.length ? bytes : Buffer.from(keyBlob)).digest('base64');\n  return `SHA256:${hash.replace(/=+$/, '')}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "fingerprintPublicKeySha256",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 75,
          "qualified_name": "fingerprintPublicKeySha256",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 160,
        "end_line": 163,
        "content": "function isChannelOpenFailure(error) {\n  const message = error && error.message !== undefined ? String(error.message) : String(error ?? '');\n  return message.toLowerCase().includes('channel open failure');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isChannelOpenFailure",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 51,
          "qualified_name": "isChannelOpenFailure",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 166,
        "end_line": 185,
        "content": "constructor(logger, security, validation, profileService, projectResolver, secretRefResolver, jobService) {\n    this.logger = logger.child('ssh');\n    this.security = security;\n    this.validation = validation;\n    this.profileService = profileService;\n    this.projectResolver = projectResolver;\n    this.secretRefResolver = secretRefResolver;\n    this.jobService = jobService || null;\n    this.connections = new Map();\n    this.connecting = new Map();\n    this.jobs = new Map();\n    this.maxJobs = readPositiveInt(process.env.SENTRYFROGG_SSH_MAX_JOBS || process.env.SF_SSH_MAX_JOBS) || 200;\n    this.stats = {\n      commands: 0,\n      profiles_created: 0,\n      errors: 0,\n      sftp_ops: 0,\n      jobs_created: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 183,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 187,
        "end_line": 234,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'profile_upsert':\n        return this.profileUpsert(args.profile_name, args);\n      case 'profile_get':\n        return this.profileGet(args.profile_name, args.include_secrets);\n      case 'profile_list':\n        return this.profileList();\n      case 'profile_delete':\n        return this.profileDelete(args.profile_name);\n      case 'profile_test':\n        return this.profileTest(args);\n      case 'authorized_keys_add':\n        return this.authorizedKeysAdd(args);\n      case 'exec':\n        return this.execCommand(args);\n      case 'exec_detached':\n        return this.execDetached(args);\n      case 'job_status':\n        return this.jobStatus(args);\n      case 'job_wait':\n        return this.jobWait(args);\n      case 'job_logs_tail':\n        return this.jobLogsTail(args);\n      case 'job_kill':\n        return this.jobKill(args);\n      case 'job_forget':\n        return this.jobForget(args);\n      case 'batch':\n        return this.batch(args);\n      case 'system_info':\n        return this.systemInfo(args);\n      case 'check_host':\n        return this.checkHost(args);\n      case 'sftp_list':\n        return this.sftpList(args);\n      case 'sftp_exists':\n        return this.sftpExists(args);\n      case 'sftp_upload':\n        return this.sftpUpload(args);\n      case 'sftp_download':\n        return this.sftpDownload(args);\n      default:\n        throw new Error(`Unknown SSH action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 380,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 236,
        "end_line": 248,
        "content": "async resolvePublicKeyLine(args) {\n    if (args.public_key !== undefined) {\n      return normalizePublicKeyLine(this.validation.ensureString(args.public_key, 'public_key', { trim: false }));\n    }\n\n    if (args.public_key_path !== undefined) {\n      const publicKeyPath = this.validation.ensureString(args.public_key_path, 'public_key_path', { trim: false });\n      const raw = await fs.readFile(expandHomePath(publicKeyPath), 'utf8');\n      return normalizePublicKeyLine(raw);\n    }\n\n    throw new Error('public_key or public_key_path is required');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 140,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 250,
        "end_line": 306,
        "content": "async authorizedKeysAdd(args = {}) {\n    const publicKeyLine = await this.resolvePublicKeyLine(args);\n    const { keyType, keyBlob } = parsePublicKeyTokens(publicKeyLine);\n    const fingerprint = fingerprintPublicKeySha256(publicKeyLine);\n\n    const authorizedKeysPath = args.authorized_keys_path !== undefined\n      ? this.validation.ensureString(args.authorized_keys_path, 'authorized_keys_path', { trim: false })\n      : undefined;\n\n    const script = [\n      'set -eu',\n      'umask 077',\n      'auth_path=\"${AUTH_KEYS_PATH:-\"$HOME/.ssh/authorized_keys\"}\"',\n      'ssh_dir=\"${auth_path%/*}\"',\n      'mkdir -p \"$ssh_dir\"',\n      'chmod 700 \"$ssh_dir\" 2>/dev/null || true',\n      '[ -f \"$auth_path\" ] || : > \"$auth_path\"',\n      'chmod 600 \"$auth_path\" 2>/dev/null || true',\n      'IFS= read -r key_line',\n      'key_line=\"$(printf %s \"$key_line\" | tr -d \\'\\\\r\\')\"',\n      'set -- $key_line',\n      'key_type=\"${1:-}\"',\n      'key_blob=\"${2:-}\"',\n      '[ -n \"$key_type\" ] && [ -n \"$key_blob\" ] || { echo \"invalid_key\" >&2; exit 2; }',\n      'if awk -v t=\"$key_type\" -v b=\"$key_blob\" \\'$0 ~ /^[[:space:]]*#/ { next } { for (i = 1; i <= NF; i++) if ($i == t && (i + 1) <= NF && $(i+1) == b) { found = 1; exit } } END { exit found ? 0 : 1 }\\' \"$auth_path\"; then',\n      '  echo present',\n      'else',\n      '  printf \"%s\\\\n\" \"$key_line\" >> \"$auth_path\"',\n      '  echo added',\n      'fi',\n    ].join('\\n');\n\n    const env = authorizedKeysPath\n      ? { ...(args.env || {}), AUTH_KEYS_PATH: authorizedKeysPath }\n      : args.env;\n\n    const result = await this.execCommand({\n      ...args,\n      command: script,\n      env,\n      stdin: `${publicKeyLine}\\n`,\n      pty: false,\n    });\n\n    const marker = String(result.stdout || '').trim().split('\\n').pop();\n    if (result.exitCode !== 0) {\n      throw new Error(`authorized_keys_add failed: ${result.stderr || marker || 'unknown error'}`);\n    }\n\n    return {\n      success: marker === 'added' || marker === 'present',\n      changed: marker === 'added',\n      key_type: keyType,\n      key_fingerprint_sha256: fingerprint,\n      authorized_keys_path: authorizedKeysPath || '~/.ssh/authorized_keys',\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 542,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 308,
        "end_line": 318,
        "content": "async loadPrivateKey(connection) {\n    if (connection.private_key) {\n      return connection.private_key;\n    }\n\n    if (connection.private_key_path) {\n      return fs.readFile(expandHomePath(connection.private_key_path), 'utf8');\n    }\n\n    return undefined;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 67,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 320,
        "end_line": 345,
        "content": "async resolveConnection(args) {\n    if (args.connection) {\n      return { connection: { ...args.connection }, profileName: undefined };\n    }\n\n    const profileName = await this.resolveProfileName(args.profile_name, args);\n    if (!profileName) {\n      throw new Error('SSH connection requires profile_name or connection');\n    }\n\n    const profile = await this.profileService.getProfile(profileName, 'ssh');\n    const data = { ...(profile.data || {}) };\n    const secrets = { ...(profile.secrets || {}) };\n\n    if (secrets.password) {\n      data.password = secrets.password;\n    }\n    if (secrets.private_key) {\n      data.private_key = secrets.private_key;\n    }\n    if (secrets.passphrase) {\n      data.passphrase = secrets.passphrase;\n    }\n\n    return { connection: data, profileName };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 200,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 347,
        "end_line": 361,
        "content": "buildConnectConfig(connection) {\n    const config = {\n      host: connection.host,\n      port: this.validation.ensurePort(connection.port, Constants.NETWORK.SSH_DEFAULT_PORT),\n      username: connection.username,\n      readyTimeout: connection.ready_timeout ?? Constants.NETWORK.TIMEOUT_SSH_READY,\n      keepaliveInterval: connection.keepalive_interval ?? Constants.NETWORK.KEEPALIVE_INTERVAL,\n    };\n\n    if (connection.keepalive_count_max !== undefined) {\n      config.keepaliveCountMax = connection.keepalive_count_max;\n    }\n\n    return config;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 140,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 363,
        "end_line": 413,
        "content": "async materializeConnection(connection, args = {}) {\n    const resolvedConnection = this.secretRefResolver\n      ? await this.secretRefResolver.resolveDeep(connection, args)\n      : connection;\n\n    const config = this.buildConnectConfig(resolvedConnection);\n\n    const policyInput = normalizeHostKeyPolicy(args.host_key_policy ?? resolvedConnection.host_key_policy);\n    const expectedFingerprint = normalizeFingerprintSha256(\n      args.host_key_fingerprint_sha256 ?? resolvedConnection.host_key_fingerprint_sha256\n    );\n\n    const policy = policyInput || (expectedFingerprint ? 'pin' : 'accept');\n    if (policy === 'pin' && !expectedFingerprint) {\n      throw new Error('host_key_fingerprint_sha256 is required for host_key_policy=pin');\n    }\n\n    if (policy !== 'accept') {\n      const state = {\n        policy,\n        expected_fingerprint_sha256: expectedFingerprint,\n        observed_fingerprint_sha256: null,\n        tofu_persist: policy === 'tofu' && !expectedFingerprint,\n      };\n\n      config.hostVerifier = (key) => {\n        const observed = fingerprintHostKeySha256(key);\n        state.observed_fingerprint_sha256 = observed;\n        if (expectedFingerprint && observed !== expectedFingerprint) {\n          return false;\n        }\n        return true;\n      };\n\n      config.__sentryfrogg_host_key_state = state;\n    }\n\n    const privateKey = await this.loadPrivateKey(resolvedConnection);\n    if (privateKey) {\n      config.privateKey = privateKey;\n      if (resolvedConnection.passphrase) {\n        config.passphrase = resolvedConnection.passphrase;\n      }\n    } else if (resolvedConnection.password) {\n      config.password = resolvedConnection.password;\n    } else {\n      throw new Error('Provide password or private_key for SSH connection');\n    }\n\n    return config;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 451,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 415,
        "end_line": 443,
        "content": "async maybePersistTofuHostKey(profileName, hostKeyState) {\n    if (!profileName || typeof profileName !== 'string') {\n      return false;\n    }\n    if (!this.profileService) {\n      return false;\n    }\n    if (!hostKeyState || typeof hostKeyState !== 'object') {\n      return false;\n    }\n    if (hostKeyState.policy !== 'tofu' || hostKeyState.tofu_persist !== true) {\n      return false;\n    }\n\n    const fingerprint = hostKeyState.observed_fingerprint_sha256;\n    if (!fingerprint || typeof fingerprint !== 'string') {\n      return false;\n    }\n\n    await this.profileService.setProfile(profileName, {\n      type: 'ssh',\n      data: {\n        host_key_policy: 'tofu',\n        host_key_fingerprint_sha256: fingerprint,\n      },\n    });\n\n    return true;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 191,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 445,
        "end_line": 476,
        "content": "async profileUpsert(profileName, params) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const connection = params.connection || {};\n\n    const secrets = {\n      password: connection.password,\n      private_key: connection.private_key,\n      passphrase: connection.passphrase,\n    };\n\n    const data = { ...connection };\n    delete data.password;\n    delete data.private_key;\n    delete data.passphrase;\n\n    await this.profileTest({ connection });\n    await this.profileService.setProfile(name, {\n      type: 'ssh',\n      data,\n      secrets,\n    });\n    this.stats.profiles_created += 1;\n\n    return {\n      success: true,\n      profile: {\n        name,\n        ...data,\n        auth: secrets.private_key ? 'private_key' : 'password',\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 199,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 478,
        "end_line": 505,
        "content": "async resolveProfileName(profileName, args = {}) {\n    if (profileName) {\n      return this.validation.ensureString(profileName, 'Profile name');\n    }\n\n    if (this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args);\n      const sshProfile = context?.target?.ssh_profile;\n      if (!sshProfile) {\n        if (context) {\n          throw new Error(`Project target '${context.targetName}' is missing ssh_profile`);\n        }\n      } else {\n        return this.validation.ensureString(String(sshProfile), 'Profile name');\n      }\n    }\n\n    const profiles = await this.profileService.listProfiles('ssh');\n    if (profiles.length === 1) {\n      return profiles[0].name;\n    }\n\n    if (profiles.length === 0) {\n      return undefined;\n    }\n\n    throw new Error('profile_name is required when multiple profiles exist');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 216,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 507,
        "end_line": 527,
        "content": "async profileGet(profileName, includeSecrets = false) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    const profile = await this.profileService.getProfile(name, 'ssh');\n\n    const allow = isTruthy(process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT) || isTruthy(process.env.SF_ALLOW_SECRET_EXPORT);\n    if (includeSecrets && allow) {\n      return { success: true, profile };\n    }\n\n    const secretKeys = profile.secrets ? Object.keys(profile.secrets).sort() : [];\n    return {\n      success: true,\n      profile: {\n        name: profile.name,\n        type: profile.type,\n        data: profile.data,\n        secrets: secretKeys,\n        secrets_redacted: true,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 178,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 529,
        "end_line": 532,
        "content": "async profileList() {\n    const profiles = await this.profileService.listProfiles('ssh');\n    return { success: true, profiles };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 35,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 534,
        "end_line": 539,
        "content": "async profileDelete(profileName) {\n    const name = this.validation.ensureString(profileName, 'Profile name');\n    await this.profileService.deleteProfile(name);\n    this.connections.delete(profileKey(name));\n    return { success: true, profile: name };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 66,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 541,
        "end_line": 550,
        "content": "async profileTest(args) {\n    const { connection } = await this.resolveConnection(args);\n    const entry = await this.createClient(await this.materializeConnection(connection, args), Symbol('test'));\n    try {\n      await this.exec(entry.client, 'echo \"test\"');\n    } finally {\n      entry.client.end();\n    }\n    return { success: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 87,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 552,
        "end_line": 594,
        "content": "async withClient(profileName, args, handler) {\n    if (typeof args === 'function') {\n      handler = args;\n      args = {};\n    }\n\n    const profile = await this.profileService.getProfile(profileName, 'ssh');\n    const key = profileKey(profileName);\n\n    let entry = this.connections.get(key);\n    if (!entry || entry.closed) {\n      let pending = this.connecting.get(key);\n      if (!pending) {\n        const connection = this.mergeProfile(profile);\n        pending = (async () => {\n          const created = await this.createClient(await this.materializeConnection(connection, args), key);\n          this.connections.set(key, created);\n          return created;\n        })();\n        this.connecting.set(key, pending);\n        pending.finally(() => {\n          this.connecting.delete(key);\n        });\n      }\n      entry = await pending;\n    }\n\n    while (entry.busy) {\n      await entry.busy;\n    }\n\n    let release;\n    entry.busy = new Promise((resolve) => {\n      release = resolve;\n    });\n\n    try {\n      return await handler(entry.client);\n    } finally {\n      release();\n      entry.busy = null;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 281,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 596,
        "end_line": 622,
        "content": "async resetProfileConnection(profileName, reason) {\n    const key = profileKey(profileName);\n    const entry = this.connections.get(key);\n    this.connecting.delete(key);\n\n    if (entry) {\n      try {\n        entry.closed = true;\n      } catch (error) {\n        // ignore\n      }\n      this.connections.delete(key);\n      try {\n        entry.client?.end?.();\n      } catch (error) {\n        // ignore\n      }\n      try {\n        entry.client?.destroy?.();\n      } catch (error) {\n        // ignore\n      }\n    }\n\n    this.logger.warn('Reset SSH connection', { profile: profileName, reason });\n    return { success: true, reset: Boolean(entry) };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 164,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 624,
        "end_line": 639,
        "content": "async withClientRetry(profileName, args, handler) {\n    let lastError;\n    for (let attempt = 0; attempt < 2; attempt += 1) {\n      try {\n        return await this.withClient(profileName, args, handler);\n      } catch (error) {\n        lastError = error;\n        if (attempt === 0 && isChannelOpenFailure(error)) {\n          await this.resetProfileConnection(profileName, error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    throw lastError;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 121,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 641,
        "end_line": 656,
        "content": "mergeProfile(profile) {\n    const connection = { ...(profile.data || {}) };\n    const secrets = { ...(profile.secrets || {}) };\n\n    if (secrets.password) {\n      connection.password = secrets.password;\n    }\n    if (secrets.private_key) {\n      connection.private_key = secrets.private_key;\n    }\n    if (secrets.passphrase) {\n      connection.passphrase = secrets.passphrase;\n    }\n\n    return connection;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 104,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 658,
        "end_line": 714,
        "content": "async createClient(connectConfig, key) {\n    return new Promise((resolve, reject) => {\n      const client = new Client();\n      let resolved = false;\n\n      const timeout = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          client.destroy();\n          reject(new Error('SSH connection timeout'));\n        }\n      }, connectConfig.readyTimeout ?? Constants.NETWORK.TIMEOUT_SSH_READY);\n\n      client\n        .on('ready', () => {\n          if (resolved) {\n            return;\n          }\n          resolved = true;\n          clearTimeout(timeout);\n\n          client.on('close', () => {\n            const entry = this.connections.get(key);\n            if (entry) {\n              entry.closed = true;\n              this.connections.delete(key);\n            }\n          });\n\n          const hostKeyState = connectConfig.__sentryfrogg_host_key_state;\n          const profileName = typeof key === 'string' ? key : null;\n\n          (async () => {\n            if (profileName) {\n              await this.maybePersistTofuHostKey(profileName, hostKeyState).catch((error) => {\n                this.logger.warn('Failed to persist TOFU host key fingerprint', { profile: profileName, error: error.message });\n              });\n            }\n            resolve({ client, busy: null, closed: false });\n          })().catch((error) => {\n            client.destroy();\n            reject(error);\n          });\n        })\n        .on('error', (error) => {\n          if (resolved) {\n            return;\n          }\n          resolved = true;\n          clearTimeout(timeout);\n          client.destroy();\n          reject(error);\n        });\n\n      client.connect(connectConfig);\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 426,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 716,
        "end_line": 726,
        "content": "async getSftp(client) {\n    return new Promise((resolve, reject) => {\n      client.sftp((error, sftp) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(sftp);\n      });\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 58,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 728,
        "end_line": 744,
        "content": "async withSftp(args, handler) {\n    const { connection, profileName } = await this.resolveConnection(args);\n    if (profileName) {\n      return this.withClientRetry(profileName, args, async (client) => {\n        const sftp = await this.getSftp(client);\n        return handler(sftp);\n      });\n    }\n\n    const entry = await this.createClient(await this.materializeConnection(connection, args), Symbol('sftp-inline'));\n    try {\n      const sftp = await this.getSftp(entry.client);\n      return await handler(sftp);\n    } finally {\n      entry.client.end();\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 143,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 746,
        "end_line": 779,
        "content": "async ensureRemoteDir(sftp, remotePath) {\n    const dir = path.posix.dirname(remotePath);\n    if (!dir || dir === '.' || dir === '/') {\n      return;\n    }\n    const parts = dir.split('/').filter(Boolean);\n    let current = '';\n    for (const part of parts) {\n      current += `/${part}`;\n      try {\n        await new Promise((resolve, reject) => {\n          sftp.stat(current, (error) => {\n            if (!error) {\n              resolve();\n            } else if (error.code === 2) {\n              sftp.mkdir(current, (mkdirError) => {\n                if (mkdirError && mkdirError.code !== 4) {\n                  reject(mkdirError);\n                } else {\n                  resolve();\n                }\n              });\n            } else {\n              reject(error);\n            }\n          });\n        });\n      } catch (error) {\n        if (error.code !== 4) {\n          throw error;\n        }\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 232,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 781,
        "end_line": 784,
        "content": "resolveToolCallBudgetMs() {\n    const fromEnv = readPositiveInt(process.env.SENTRYFROGG_TOOL_CALL_TIMEOUT_MS || process.env.SF_TOOL_CALL_TIMEOUT_MS);\n    return fromEnv ?? Constants.NETWORK.TIMEOUT_MCP_TOOL_CALL;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 56,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 786,
        "end_line": 789,
        "content": "resolveExecDefaultTimeoutMs() {\n    const fromEnv = readPositiveInt(process.env.SENTRYFROGG_SSH_EXEC_TIMEOUT_MS || process.env.SF_SSH_EXEC_TIMEOUT_MS);\n    return fromEnv ?? Constants.NETWORK.TIMEOUT_SSH_EXEC_DEFAULT;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 791,
        "end_line": 794,
        "content": "resolveExecHardGraceMs() {\n    const fromEnv = readPositiveInt(process.env.SENTRYFROGG_SSH_EXEC_HARD_GRACE_MS || process.env.SF_SSH_EXEC_HARD_GRACE_MS);\n    return fromEnv ?? Constants.NETWORK.TIMEOUT_SSH_EXEC_HARD_GRACE;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 58,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 796,
        "end_line": 799,
        "content": "resolveDetachedStartTimeoutMs() {\n    const fromEnv = readPositiveInt(process.env.SENTRYFROGG_SSH_DETACHED_START_TIMEOUT_MS || process.env.SF_SSH_DETACHED_START_TIMEOUT_MS);\n    return fromEnv ?? Constants.NETWORK.TIMEOUT_SSH_DETACHED_START;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 63,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 801,
        "end_line": 809,
        "content": "resolveExecMaxCaptureBytes() {\n    const fromEnv = readPositiveInt(\n      process.env.SENTRYFROGG_SSH_MAX_CAPTURE_BYTES\n      || process.env.SF_SSH_MAX_CAPTURE_BYTES\n      || process.env.SENTRYFROGG_MAX_CAPTURE_BYTES\n      || process.env.SF_MAX_CAPTURE_BYTES\n    );\n    return fromEnv ?? DEFAULT_MAX_CAPTURE_BYTES;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 81,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 811,
        "end_line": 819,
        "content": "resolveExecMaxInlineBytes() {\n    const fromEnv = readPositiveInt(\n      process.env.SENTRYFROGG_SSH_MAX_INLINE_BYTES\n      || process.env.SF_SSH_MAX_INLINE_BYTES\n      || process.env.SENTRYFROGG_MAX_INLINE_BYTES\n      || process.env.SF_MAX_INLINE_BYTES\n    );\n    return fromEnv ?? DEFAULT_MAX_INLINE_BYTES;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 80,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 821,
        "end_line": 851,
        "content": "registerJob(job) {\n    if (!job || typeof job !== 'object' || !job.job_id) {\n      return;\n    }\n\n    if (this.jobService) {\n      this.jobService.upsert({\n        ...job,\n        kind: job.kind || 'ssh_detached',\n        status: job.status || 'running',\n        provider: job.provider || {\n          tool: 'mcp_ssh_manager',\n          profile_name: job.profile_name || null,\n          pid: job.pid,\n          pid_path: job.pid_path,\n          log_path: job.log_path,\n          exit_path: job.exit_path,\n        },\n      });\n    } else {\n      this.jobs.set(job.job_id, job);\n      while (this.jobs.size > this.maxJobs) {\n        const oldest = this.jobs.keys().next().value;\n        if (!oldest) {\n          break;\n        }\n        this.jobs.delete(oldest);\n      }\n    }\n    this.stats.jobs_created += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 204,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 853,
        "end_line": 859,
        "content": "buildCommand(command, cwd) {\n    const trimmed = this.security.cleanCommand(command);\n    if (cwd) {\n      return `cd ${escapeShellValue(cwd)} && ${trimmed}`;\n    }\n    return trimmed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 49,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 861,
        "end_line": 908,
        "content": "async execCommand(args) {\n    const { connection, profileName } = await this.resolveConnection(args);\n    const command = this.buildCommand(args.command, args.cwd);\n\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const requestedTimeoutMs = readPositiveInt(args.timeout_ms);\n    if (requestedTimeoutMs && requestedTimeoutMs > budgetMs) {\n      const started = await this.execDetached({\n        ...args,\n        timeout_ms: this.resolveDetachedStartTimeoutMs(),\n      });\n      return {\n        ...started,\n        detached: true,\n        requested_timeout_ms: requestedTimeoutMs,\n      };\n    }\n\n    const effectiveTimeoutMs = Math.min(\n      requestedTimeoutMs ?? this.resolveExecDefaultTimeoutMs(),\n      budgetMs\n    );\n    const execArgs = { ...args, timeout_ms: effectiveTimeoutMs };\n\n    const options = {\n      env: args.env,\n      pty: args.pty,\n    };\n\n    try {\n      const result = profileName\n        ? await this.withClientRetry(profileName, execArgs, (client) => this.exec(client, command, options, execArgs))\n        : await this.execOnce(connection, command, options, execArgs);\n\n      this.stats.commands += 1;\n      return {\n        success: result.exitCode === 0 && result.timedOut !== true,\n        command,\n        timeout_ms: effectiveTimeoutMs,\n        requested_timeout_ms: requestedTimeoutMs,\n        ...result,\n      };\n    } catch (error) {\n      this.stats.errors += 1;\n      this.logger.error('SSH command failed', { profile: profileName, error: error.message });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 384,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 910,
        "end_line": 989,
        "content": "async execDetached(args) {\n    const { connection, profileName } = await this.resolveConnection(args);\n    const command = this.buildCommand(args.command, args.cwd);\n\n    const logPath = args.log_path !== undefined\n      ? this.validation.ensureString(args.log_path, 'log_path', { trim: false })\n      : `/tmp/sentryfrogg-detached-${Date.now()}-${crypto.randomBytes(4).toString('hex')}.log`;\n    const pidPath = args.pid_path !== undefined\n      ? this.validation.ensureString(args.pid_path, 'pid_path', { trim: false })\n      : `${logPath}.pid`;\n\n    const exitPath = args.exit_path !== undefined\n      ? this.validation.ensureString(args.exit_path, 'exit_path', { trim: false })\n      : `${logPath}.exit`;\n\n    const jobId = crypto.randomUUID();\n\n    const inner = [\n      `(${command})`,\n      'rc=$?',\n      `echo \"$rc\" > ${escapeShellValue(exitPath)}`,\n      'exit \"$rc\"',\n    ].join('\\n');\n\n    const detachedCommand = [\n      `rm -f ${escapeShellValue(pidPath)} ${escapeShellValue(exitPath)} 2>/dev/null || true`,\n      `nohup sh -lc ${escapeShellValue(inner)} > ${escapeShellValue(logPath)} 2>&1 < /dev/null & echo $! > ${escapeShellValue(pidPath)}`,\n      `cat ${escapeShellValue(pidPath)}`,\n    ].join('; ');\n\n    const options = {\n      env: args.env,\n      pty: false,\n    };\n\n    const execArgs = {\n      ...args,\n      timeout_ms: Math.min(\n        readPositiveInt(args.timeout_ms) ?? this.resolveDetachedStartTimeoutMs(),\n        this.resolveToolCallBudgetMs()\n      ),\n    };\n\n    try {\n      const result = profileName\n        ? await this.withClientRetry(profileName, execArgs, (client) => this.exec(client, detachedCommand, options, execArgs))\n        : await this.execOnce(connection, detachedCommand, options, execArgs);\n\n      const match = String(result.stdout || '').match(/(\\d+)\\s*$/);\n      const pid = match ? Number(match[1]) : null;\n\n      this.registerJob({\n        job_id: jobId,\n        created_at: new Date().toISOString(),\n        profile_name: profileName || null,\n        pid,\n        log_path: logPath,\n        pid_path: pidPath,\n        exit_path: exitPath,\n      });\n\n      this.stats.commands += 1;\n      return {\n        success: result.exitCode === 0 && Number.isInteger(pid),\n        job_id: jobId,\n        command,\n        detached_command: detachedCommand,\n        pid,\n        log_path: logPath,\n        pid_path: pidPath,\n        exit_path: exitPath,\n        start_timeout_ms: execArgs.timeout_ms,\n        ...result,\n      };\n    } catch (error) {\n      this.stats.errors += 1;\n      this.logger.error('SSH detached command failed', { profile: profileName, error: error.message });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 666,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 991,
        "end_line": 999,
        "content": "async execOnce(connection, command, options, args) {\n    const connectConfig = await this.materializeConnection(connection, args);\n    const entry = await this.createClient(connectConfig, Symbol('inline'));\n    try {\n      return await this.exec(entry.client, command, options, args);\n    } finally {\n      entry.client.end();\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 86,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1001,
        "end_line": 1393,
        "content": "exec(client, command, options = {}, args = {}) {\n    const requestedTimeoutMs = readPositiveInt(args.timeout_ms);\n    const stdin = args.stdin;\n\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const timeoutMs = requestedTimeoutMs ? Math.min(requestedTimeoutMs, budgetMs) : null;\n    const hardGraceMs = timeoutMs\n      ? Math.min(this.resolveExecHardGraceMs(), Math.max(0, budgetMs - timeoutMs))\n      : 0;\n\n    const maxCaptureBytes = this.resolveExecMaxCaptureBytes();\n    const maxInlineBytes = this.resolveExecMaxInlineBytes();\n\n    const traceId = args.trace_id || 'run';\n    const spanId = args.span_id || crypto.randomUUID();\n    const contextRoot = resolveContextRepoRoot();\n    const streamArtifactsMode = contextRoot ? resolveStreamToArtifactMode() : null;\n    const streamArtifactsRequested = Boolean(streamArtifactsMode);\n\n    return new Promise((resolve, reject) => {\n      const started = Date.now();\n      const stdoutState = { total: 0, captured: 0, truncated: false };\n      const stderrState = { total: 0, captured: 0, truncated: false };\n      const stdoutChunks = [];\n      const stderrChunks = [];\n      const stdoutInline = { captured: 0, truncated: false };\n      const stderrInline = { captured: 0, truncated: false };\n      let timedOut = false;\n      let settled = false;\n\n      let streamArtifactsEnabled = streamArtifactsRequested;\n      let stdoutWriter = null;\n      let stderrWriter = null;\n\n      const artifactLimit = streamArtifactsMode === 'full' ? Number.POSITIVE_INFINITY : maxCaptureBytes;\n\n      const captureMemoryChunk = (chunk, state, target) => {\n        const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk ?? ''));\n        state.total += buf.length;\n        if (state.captured >= maxCaptureBytes) {\n          state.truncated = true;\n          return;\n        }\n        const remaining = maxCaptureBytes - state.captured;\n        if (buf.length <= remaining) {\n          target.push(buf);\n          state.captured += buf.length;\n          return;\n        }\n        target.push(buf.subarray(0, remaining));\n        state.captured += remaining;\n        state.truncated = true;\n      };\n\n      const captureInlineChunk = (chunk, inlineState, target) => {\n        if (inlineState.captured >= maxInlineBytes) {\n          inlineState.truncated = true;\n          return;\n        }\n\n        const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk ?? ''));\n        const remaining = maxInlineBytes - inlineState.captured;\n        if (buf.length <= remaining) {\n          target.push(buf);\n          inlineState.captured += buf.length;\n          return;\n        }\n        target.push(buf.subarray(0, remaining));\n        inlineState.captured += remaining;\n        inlineState.truncated = true;\n      };\n\n      const writeArtifactChunk = (chunk, state, writer, source) => {\n        if (!writer) {\n          if (artifactLimit !== Number.POSITIVE_INFINITY) {\n            state.truncated = true;\n          }\n          return;\n        }\n        const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk ?? ''));\n        if (state.captured >= artifactLimit) {\n          if (artifactLimit !== Number.POSITIVE_INFINITY) {\n            state.truncated = true;\n          }\n          return;\n        }\n        const remaining = artifactLimit - state.captured;\n        if (buf.length <= remaining) {\n          const ok = writer.stream.write(buf);\n          if (!ok && source && typeof source.pause === 'function') {\n            source.pause();\n            writer.stream.once('drain', () => source.resume());\n          }\n          state.captured += buf.length;\n          return;\n        }\n        const slice = buf.subarray(0, remaining);\n        const ok = writer.stream.write(slice);\n        if (!ok && source && typeof source.pause === 'function') {\n          source.pause();\n          writer.stream.once('drain', () => source.resume());\n        }\n        state.captured += remaining;\n        state.truncated = true;\n      };\n\n      const startExec = async () => {\n        if (streamArtifactsEnabled) {\n          try {\n            stdoutWriter = await createArtifactWriteStream(\n              contextRoot,\n              buildToolCallFileRef({ traceId, spanId, filename: 'stdout.log' })\n            );\n            stderrWriter = await createArtifactWriteStream(\n              contextRoot,\n              buildToolCallFileRef({ traceId, spanId, filename: 'stderr.log' })\n            );\n          } catch (artifactError) {\n            streamArtifactsEnabled = false;\n            if (stdoutWriter) {\n              await stdoutWriter.abort().catch(() => null);\n              stdoutWriter = null;\n            }\n            if (stderrWriter) {\n              await stderrWriter.abort().catch(() => null);\n              stderrWriter = null;\n            }\n            this.logger.warn('Failed to initialize SSH artifact streams', { error: artifactError.message });\n          }\n        }\n\n        client.exec(command, options, (error, stream) => {\n          if (error) {\n            if (stdoutWriter) {\n              void stdoutWriter.abort().catch(() => null);\n              stdoutWriter = null;\n            }\n            if (stderrWriter) {\n              void stderrWriter.abort().catch(() => null);\n              stderrWriter = null;\n            }\n            reject(error);\n            return;\n          }\n\n          const finalize = (fn) => {\n            if (settled) {\n              return;\n            }\n            settled = true;\n            Promise.resolve()\n              .then(fn)\n              .then((value) => resolve(value))\n              .catch((err) => reject(err));\n          };\n\n          const buildResult = async ({ exitCode, signal, hardTimedOut = false }) => {\n            if (streamArtifactsEnabled) {\n              const stdoutInlineBuffer = stdoutInline.captured\n                ? Buffer.concat(stdoutChunks, stdoutInline.captured)\n                : Buffer.alloc(0);\n              const stderrInlineBuffer = stderrInline.captured\n                ? Buffer.concat(stderrChunks, stderrInline.captured)\n                : Buffer.alloc(0);\n\n              const stdoutInlineTruncated = stdoutInline.truncated;\n              const stderrInlineTruncated = stderrInline.truncated;\n\n              let stdoutRef = null;\n              let stderrRef = null;\n\n              if (stdoutWriter) {\n                if (stdoutState.captured > 0) {\n                  try {\n                    const written = await stdoutWriter.finalize();\n                    stdoutRef = { uri: written.uri, rel: written.rel, bytes: written.bytes };\n                  } catch (artifactError) {\n                    this.logger.warn('Failed to finalize SSH stdout artifact', { error: artifactError.message });\n                    await stdoutWriter.abort().catch(() => null);\n                  }\n                } else {\n                  await stdoutWriter.abort().catch(() => null);\n                }\n                stdoutWriter = null;\n              }\n\n              if (stderrWriter) {\n                if (stderrState.captured > 0) {\n                  try {\n                    const written = await stderrWriter.finalize();\n                    stderrRef = { uri: written.uri, rel: written.rel, bytes: written.bytes };\n                  } catch (artifactError) {\n                    this.logger.warn('Failed to finalize SSH stderr artifact', { error: artifactError.message });\n                    await stderrWriter.abort().catch(() => null);\n                  }\n                } else {\n                  await stderrWriter.abort().catch(() => null);\n                }\n                stderrWriter = null;\n              }\n\n              return {\n                stdout: stdoutInlineBuffer.toString('utf8').trim(),\n                stderr: stderrInlineBuffer.toString('utf8').trim(),\n                stdout_bytes: stdoutState.total,\n                stderr_bytes: stderrState.total,\n                stdout_captured_bytes: stdoutState.captured,\n                stderr_captured_bytes: stderrState.captured,\n                stdout_truncated: stdoutState.truncated,\n                stderr_truncated: stderrState.truncated,\n                stdout_inline_truncated: stdoutInlineTruncated,\n                stderr_inline_truncated: stderrInlineTruncated,\n                stdout_ref: stdoutRef,\n                stderr_ref: stderrRef,\n                exitCode,\n                signal,\n                timedOut,\n                hardTimedOut,\n                duration_ms: Date.now() - started,\n              };\n            }\n\n            const stdoutBuffer = stdoutState.captured\n              ? Buffer.concat(stdoutChunks, stdoutState.captured)\n              : Buffer.alloc(0);\n            const stderrBuffer = stderrState.captured\n              ? Buffer.concat(stderrChunks, stderrState.captured)\n              : Buffer.alloc(0);\n\n            const stdoutInlineBuffer = stdoutBuffer.length > maxInlineBytes\n              ? stdoutBuffer.subarray(0, maxInlineBytes)\n              : stdoutBuffer;\n            const stderrInlineBuffer = stderrBuffer.length > maxInlineBytes\n              ? stderrBuffer.subarray(0, maxInlineBytes)\n              : stderrBuffer;\n\n            const stdoutInlineTruncated = stdoutBuffer.length > maxInlineBytes;\n            const stderrInlineTruncated = stderrBuffer.length > maxInlineBytes;\n\n            const shouldWriteStdout = Boolean(\n              contextRoot\n              && stdoutBuffer.length > 0\n              && (stdoutState.truncated || stdoutInlineTruncated)\n            );\n            const shouldWriteStderr = Boolean(\n              contextRoot\n              && stderrBuffer.length > 0\n              && (stderrState.truncated || stderrInlineTruncated)\n            );\n\n            let stdoutRef = null;\n            let stderrRef = null;\n\n            if (shouldWriteStdout) {\n              try {\n                const ref = buildToolCallFileRef({ traceId, spanId, filename: 'stdout.log' });\n                const written = await writeBinaryArtifact(contextRoot, ref, stdoutBuffer);\n                stdoutRef = { uri: written.uri, rel: written.rel, bytes: written.bytes };\n              } catch (artifactError) {\n                this.logger.warn('Failed to write SSH stdout artifact', { error: artifactError.message });\n              }\n            }\n\n            if (shouldWriteStderr) {\n              try {\n                const ref = buildToolCallFileRef({ traceId, spanId, filename: 'stderr.log' });\n                const written = await writeBinaryArtifact(contextRoot, ref, stderrBuffer);\n                stderrRef = { uri: written.uri, rel: written.rel, bytes: written.bytes };\n              } catch (artifactError) {\n                this.logger.warn('Failed to write SSH stderr artifact', { error: artifactError.message });\n              }\n            }\n\n            return {\n              stdout: stdoutInlineBuffer.toString('utf8').trim(),\n              stderr: stderrInlineBuffer.toString('utf8').trim(),\n              stdout_bytes: stdoutState.total,\n              stderr_bytes: stderrState.total,\n              stdout_captured_bytes: stdoutBuffer.length,\n              stderr_captured_bytes: stderrBuffer.length,\n              stdout_truncated: stdoutState.truncated,\n              stderr_truncated: stderrState.truncated,\n              stdout_inline_truncated: stdoutInlineTruncated,\n              stderr_inline_truncated: stderrInlineTruncated,\n              stdout_ref: stdoutRef,\n              stderr_ref: stderrRef,\n              exitCode,\n              signal,\n              timedOut,\n              hardTimedOut,\n              duration_ms: Date.now() - started,\n            };\n          };\n\n        let timeout;\n        let hardTimeout;\n        if (timeoutMs) {\n          timeout = setTimeout(() => {\n            timedOut = true;\n            try {\n              stream.close();\n            } catch (closeError) {\n              // ignore\n            }\n          }, timeoutMs);\n\n          hardTimeout = setTimeout(() => {\n            timedOut = true;\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n            try {\n              stream.close();\n            } catch (closeError) {\n              // ignore\n            }\n            try {\n              stream.destroy();\n            } catch (destroyError) {\n              // ignore\n            }\n            try {\n              client.destroy();\n            } catch (clientError) {\n              // ignore\n            }\n\n            finalize(() => buildResult({ exitCode: null, signal: null, hardTimedOut: true }));\n          }, timeoutMs + hardGraceMs);\n        }\n\n        stream\n          .on('close', (code, signal) => {\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n            if (hardTimeout) {\n              clearTimeout(hardTimeout);\n            }\n            finalize(() => buildResult({ exitCode: code, signal }));\n          })\n          .on('error', (streamError) => {\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n            if (hardTimeout) {\n              clearTimeout(hardTimeout);\n            }\n            finalize(async () => {\n              if (stdoutWriter) {\n                await stdoutWriter.abort().catch(() => null);\n                stdoutWriter = null;\n              }\n              if (stderrWriter) {\n                await stderrWriter.abort().catch(() => null);\n                stderrWriter = null;\n              }\n              throw streamError;\n            });\n          })\n          .on('data', (data) => {\n            if (streamArtifactsEnabled) {\n              const buf = Buffer.isBuffer(data) ? data : Buffer.from(String(data ?? ''));\n              stdoutState.total += buf.length;\n              captureInlineChunk(buf, stdoutInline, stdoutChunks);\n              writeArtifactChunk(buf, stdoutState, stdoutWriter, stream);\n              return;\n            }\n            captureMemoryChunk(data, stdoutState, stdoutChunks);\n          });\n\n        if (stream.stderr && typeof stream.stderr.on === 'function') {\n          stream.stderr.on('data', (data) => {\n            if (streamArtifactsEnabled) {\n              const buf = Buffer.isBuffer(data) ? data : Buffer.from(String(data ?? ''));\n              stderrState.total += buf.length;\n              captureInlineChunk(buf, stderrInline, stderrChunks);\n              writeArtifactChunk(buf, stderrState, stderrWriter, stream.stderr);\n              return;\n            }\n            captureMemoryChunk(data, stderrState, stderrChunks);\n          });\n        }\n\n        if (stdin !== undefined && stdin !== null) {\n          stream.end(String(stdin));\n        }\n      });\n      };\n\n      void startExec().catch(reject);\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 3691,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1395,
        "end_line": 1447,
        "content": "resolveJobSpec(args = {}, { requirePid = true } = {}) {\n    const jobId = args.job_id !== undefined && args.job_id !== null\n      ? this.validation.ensureString(args.job_id, 'job_id')\n      : null;\n\n    const fromRegistry = jobId\n      ? (this.jobService ? this.jobService.get(jobId) : this.jobs.get(jobId))\n      : null;\n\n    const hasExplicitLocator = args.pid !== undefined\n      || args.pid_path !== undefined\n      || args.log_path !== undefined\n      || args.exit_path !== undefined;\n\n    if (jobId && !fromRegistry && !hasExplicitLocator) {\n      return { job_id: jobId, not_found: true };\n    }\n\n    const logPathRaw = args.log_path ?? fromRegistry?.log_path;\n    const logPath = logPathRaw !== undefined && logPathRaw !== null\n      ? this.validation.ensureString(logPathRaw, 'log_path', { trim: false })\n      : undefined;\n\n    const pidPathRaw = args.pid_path ?? fromRegistry?.pid_path ?? (logPath ? `${logPath}.pid` : undefined);\n    const pidPath = pidPathRaw !== undefined && pidPathRaw !== null\n      ? this.validation.ensureString(pidPathRaw, 'pid_path', { trim: false })\n      : undefined;\n\n    const exitPathRaw = args.exit_path ?? fromRegistry?.exit_path ?? (logPath ? `${logPath}.exit` : undefined);\n    const exitPath = exitPathRaw !== undefined && exitPathRaw !== null\n      ? this.validation.ensureString(exitPathRaw, 'exit_path', { trim: false })\n      : undefined;\n\n    const pidRaw = args.pid ?? fromRegistry?.pid;\n    const pid = pidRaw === undefined || pidRaw === null || pidRaw === '' ? null : Number(pidRaw);\n    if (pid !== null && (!Number.isFinite(pid) || !Number.isInteger(pid) || pid <= 0)) {\n      throw new Error('pid must be a positive integer');\n    }\n\n    if (requirePid && !pid && !pidPath) {\n      throw new Error('job requires pid or pid_path (or job_id with known pid_path)');\n    }\n\n    return {\n      job_id: jobId,\n      not_found: false,\n      profile_name: fromRegistry?.profile_name ?? null,\n      pid,\n      pid_path: pidPath,\n      log_path: logPath,\n      exit_path: exitPath,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 512,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1449,
        "end_line": 1519,
        "content": "async jobStatus(args = {}) {\n    const job = this.resolveJobSpec(args);\n    if (job.not_found) {\n      return { success: false, code: 'NOT_FOUND', job_id: job.job_id };\n    }\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const timeoutMs = Math.min(readPositiveInt(args.timeout_ms) ?? 10000, budgetMs);\n\n    const pidValue = job.pid ? String(job.pid) : '';\n    const pidPath = job.pid_path ? String(job.pid_path) : '';\n    const exitPath = job.exit_path ? String(job.exit_path) : '';\n    const logPath = job.log_path ? String(job.log_path) : '';\n\n    const script = [\n      'set -u',\n      `PID_VALUE=${escapeShellValue(pidValue)}`,\n      `PID_PATH=${escapeShellValue(pidPath)}`,\n      `EXIT_PATH=${escapeShellValue(exitPath)}`,\n      `LOG_PATH=${escapeShellValue(logPath)}`,\n      'pid=\"$PID_VALUE\"',\n      'if [ -z \"$pid\" ] && [ -n \"$PID_PATH\" ] && [ -f \"$PID_PATH\" ]; then pid=\"$(cat \"$PID_PATH\" 2>/dev/null | tr -dc \\'0-9\\' | head -c 32)\"; fi',\n      'running=0',\n      'if [ -n \"$pid\" ] && kill -0 \"$pid\" 2>/dev/null; then running=1; fi',\n      'exit_code=\"\"',\n      'if [ -n \"$EXIT_PATH\" ] && [ -f \"$EXIT_PATH\" ]; then exit_code=\"$(cat \"$EXIT_PATH\" 2>/dev/null | tr -d \"\\\\r\\\\n\" | head -c 64)\"; fi',\n      'log_bytes=\"\"',\n      'if [ -n \"$LOG_PATH\" ] && [ -f \"$LOG_PATH\" ]; then log_bytes=\"$(wc -c < \"$LOG_PATH\" 2>/dev/null | tr -d \" \")\"; fi',\n      'echo \"__SF_PID__=$pid\"',\n      'echo \"__SF_RUNNING__=$running\"',\n      'echo \"__SF_EXIT_CODE__=$exit_code\"',\n      'echo \"__SF_LOG_BYTES__=$log_bytes\"',\n    ].join('\\n');\n\n    const exec = await this.execCommand({\n      ...args,\n      cwd: undefined,\n      pty: false,\n      timeout_ms: timeoutMs,\n      command: script,\n    });\n\n    const lines = String(exec.stdout || '').split(/\\n/);\n    const pick = (prefix) => {\n      const line = lines.find((item) => item.startsWith(prefix));\n      return line ? line.slice(prefix.length) : '';\n    };\n\n    const pidStr = pick('__SF_PID__=');\n    const runningStr = pick('__SF_RUNNING__=');\n    const exitStr = pick('__SF_EXIT_CODE__=');\n    const logBytesStr = pick('__SF_LOG_BYTES__=');\n\n    const resolvedPid = pidStr ? Number(pidStr) : null;\n    const running = runningStr === '1';\n    const exitCode = exitStr === '' ? null : Number(exitStr);\n    const exited = exitStr !== '' && Number.isFinite(exitCode);\n    const logBytes = logBytesStr === '' ? null : Number(logBytesStr);\n\n    return {\n      success: true,\n      job_id: job.job_id,\n      pid: Number.isInteger(resolvedPid) ? resolvedPid : job.pid,\n      running,\n      exited,\n      exit_code: exited ? exitCode : null,\n      log_path: job.log_path,\n      pid_path: job.pid_path,\n      exit_path: job.exit_path,\n      log_bytes: Number.isFinite(logBytes) ? logBytes : null,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 690,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1521,
        "end_line": 1551,
        "content": "async jobWait(args = {}) {\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const requested = readPositiveInt(args.timeout_ms) ?? 30000;\n    const timeoutMs = Math.min(requested, budgetMs);\n    const pollMs = Math.min(readPositiveInt(args.poll_interval_ms) ?? 1000, 5000);\n    const started = Date.now();\n\n    let status = await this.jobStatus({ ...args, timeout_ms: Math.min(10000, budgetMs) });\n    if (!status.success && status.code === 'NOT_FOUND') {\n      return {\n        success: false,\n        code: 'NOT_FOUND',\n        job_id: args.job_id,\n      };\n    }\n    while (!status.exited && Date.now() - started + pollMs <= timeoutMs) {\n      await sleep(pollMs);\n      status = await this.jobStatus({ ...args, timeout_ms: Math.min(10000, budgetMs) });\n    }\n\n    const waitedMs = Date.now() - started;\n    return {\n      success: true,\n      completed: status.exited,\n      timed_out: !status.exited,\n      waited_ms: waitedMs,\n      timeout_ms: timeoutMs,\n      poll_interval_ms: pollMs,\n      status,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 258,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1553,
        "end_line": 1583,
        "content": "async jobLogsTail(args = {}) {\n    const spec = this.resolveJobSpec(args, { requirePid: false });\n    if (spec.not_found) {\n      return { success: false, code: 'NOT_FOUND', job_id: spec.job_id };\n    }\n    const logPath = spec.log_path;\n    if (!logPath) {\n      throw new Error('log_path is required (or job_id with known log_path)');\n    }\n\n    const lines = Math.min(readPositiveInt(args.lines) ?? 200, 2000);\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const timeoutMs = Math.min(readPositiveInt(args.timeout_ms) ?? 10000, budgetMs);\n\n    const cmd = `tail -n ${lines} ${escapeShellValue(logPath)} 2>/dev/null || true`;\n    const out = await this.execCommand({\n      ...args,\n      cwd: undefined,\n      pty: false,\n      timeout_ms: timeoutMs,\n      command: cmd,\n    });\n\n    return {\n      success: true,\n      job_id: spec.job_id,\n      log_path: logPath,\n      lines,\n      text: out.stdout || '',\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 234,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1585,
        "end_line": 1633,
        "content": "async jobKill(args = {}) {\n    const job = this.resolveJobSpec(args);\n    if (job.not_found) {\n      return { success: false, code: 'NOT_FOUND', job_id: job.job_id };\n    }\n    const budgetMs = this.resolveToolCallBudgetMs();\n    const timeoutMs = Math.min(readPositiveInt(args.timeout_ms) ?? 10000, budgetMs);\n\n    const rawSignal = args.signal === undefined || args.signal === null ? 'TERM' : String(args.signal).trim();\n    if (!/^[A-Za-z0-9]+$/.test(rawSignal)) {\n      throw new Error('signal must be an alphanumeric string (e.g. TERM, KILL, 9)');\n    }\n    const signal = rawSignal.toUpperCase();\n\n    const pidValue = job.pid ? String(job.pid) : '';\n    const pidPath = job.pid_path ? String(job.pid_path) : '';\n\n    const script = [\n      'set -u',\n      `PID_VALUE=${escapeShellValue(pidValue)}`,\n      `PID_PATH=${escapeShellValue(pidPath)}`,\n      `SIG=${escapeShellValue(signal)}`,\n      'pid=\"$PID_VALUE\"',\n      'if [ -z \"$pid\" ] && [ -n \"$PID_PATH\" ] && [ -f \"$PID_PATH\" ]; then pid=\"$(cat \"$PID_PATH\" 2>/dev/null | tr -dc \\'0-9\\' | head -c 32)\"; fi',\n      'if [ -z \"$pid\" ]; then echo \"__SF_KILL__=no_pid\"; exit 2; fi',\n      'kill -s \"$SIG\" \"$pid\" 2>/dev/null || kill \"$pid\" 2>/dev/null',\n      'echo \"__SF_KILL__=ok\"',\n    ].join('\\n');\n\n    const exec = await this.execCommand({\n      ...args,\n      cwd: undefined,\n      pty: false,\n      timeout_ms: timeoutMs,\n      command: script,\n    });\n\n    if (exec.exitCode !== 0) {\n      throw new Error(exec.stderr || `job_kill failed (exitCode=${exec.exitCode})`);\n    }\n\n    return {\n      success: true,\n      job_id: job.job_id,\n      pid: job.pid,\n      pid_path: job.pid_path,\n      signal,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 420,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1635,
        "end_line": 1639,
        "content": "async jobForget(args = {}) {\n    const jobId = this.validation.ensureString(args.job_id, 'job_id');\n    const removed = this.jobService ? this.jobService.forget(jobId) : this.jobs.delete(jobId);\n    return { success: true, job_id: jobId, removed };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 65,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1641,
        "end_line": 1674,
        "content": "async batch(args) {\n    const commands = Array.isArray(args.commands) ? args.commands : [];\n    if (commands.length === 0) {\n      throw new Error('commands must be a non-empty array');\n    }\n\n    const parallel = !!args.parallel;\n    const stopOnError = args.stop_on_error !== false;\n\n    if (parallel) {\n      const results = await Promise.all(\n        commands.map((command) => this.execCommand({ ...args, ...command }))\n      );\n      return { success: results.every((item) => item.exitCode === 0), results };\n    }\n\n    const results = [];\n    for (const command of commands) {\n      try {\n        const result = await this.execCommand({ ...args, ...command });\n        results.push(result);\n        if (stopOnError && result.exitCode !== 0) {\n          break;\n        }\n      } catch (error) {\n        results.push({ success: false, command: command.command, error: error.message });\n        if (stopOnError) {\n          break;\n        }\n      }\n    }\n\n    return { success: results.every((item) => item.exitCode === 0), results };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 262,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1676,
        "end_line": 1721,
        "content": "async sftpList(args) {\n    const remotePath = this.validation.ensureString(args.path || '.', 'Path');\n    const recursive = args.recursive === true;\n    const maxDepth = Number.isInteger(args.max_depth) ? args.max_depth : 3;\n\n    const entries = [];\n\n    const walk = (sftp, currentPath, depth) => new Promise((resolve, reject) => {\n      sftp.readdir(currentPath, (error, list) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        const run = async () => {\n          for (const entry of list) {\n            const isDir = entry.attrs && typeof entry.attrs.isDirectory === 'function'\n              ? entry.attrs.isDirectory()\n              : (entry.attrs?.mode & 0o40000) === 0o40000;\n            const fullPath = path.posix.join(currentPath, entry.filename);\n            entries.push({\n              path: fullPath,\n              filename: entry.filename,\n              longname: entry.longname,\n              type: isDir ? 'dir' : 'file',\n              size: entry.attrs?.size,\n              mode: entry.attrs?.mode,\n              mtime: entry.attrs?.mtime,\n              atime: entry.attrs?.atime,\n            });\n            if (recursive && isDir && depth < maxDepth) {\n              await walk(sftp, fullPath, depth + 1);\n            }\n          }\n        };\n\n        run().then(resolve).catch(reject);\n      });\n    });\n\n    await this.withSftp(args, async (sftp) => {\n      await walk(sftp, remotePath, 0);\n    });\n\n    this.stats.sftp_ops += 1;\n    return { success: true, path: remotePath, entries };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 388,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1723,
        "end_line": 1783,
        "content": "async sftpExists(args) {\n    const remotePath = this.validation.ensureString(args.remote_path ?? args.path, 'remote_path');\n    const timeoutMs = Math.min(readPositiveInt(args.timeout_ms) ?? 10000, this.resolveToolCallBudgetMs());\n\n    let exists = false;\n    let stat = null;\n\n    await this.withSftp(args, async (sftp) => {\n      await new Promise((resolve, reject) => {\n        let settled = false;\n        const timeout = setTimeout(() => {\n          if (settled) {\n            return;\n          }\n          settled = true;\n          reject(new Error('sftp_exists timeout'));\n        }, timeoutMs);\n\n        sftp.stat(remotePath, (error, attrs) => {\n          if (settled) {\n            return;\n          }\n          settled = true;\n          clearTimeout(timeout);\n\n          if (!error) {\n            exists = true;\n            stat = attrs\n              ? {\n                size: attrs.size,\n                mode: attrs.mode,\n                uid: attrs.uid,\n                gid: attrs.gid,\n                atime: attrs.atime,\n                mtime: attrs.mtime,\n              }\n              : null;\n            resolve();\n            return;\n          }\n\n          if (error.code === 2) {\n            exists = false;\n            stat = null;\n            resolve();\n            return;\n          }\n\n          reject(error);\n        });\n      });\n    });\n\n    this.stats.sftp_ops += 1;\n    return {\n      success: true,\n      remote_path: remotePath,\n      exists,\n      stat,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 375,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1785,
        "end_line": 1837,
        "content": "async sftpUpload(args) {\n    const localPath = expandHomePath(this.validation.ensureString(args.local_path, 'local_path'));\n    const remotePath = this.validation.ensureString(args.remote_path, 'remote_path');\n    const overwrite = args.overwrite === true;\n\n    await this.withSftp(args, async (sftp) => {\n      if (!overwrite) {\n        await new Promise((resolve, reject) => {\n          sftp.stat(remotePath, (error) => {\n            if (!error) {\n              reject(new Error(`Remote path already exists: ${remotePath}`));\n              return;\n            }\n            if (error.code !== 2) {\n              reject(error);\n              return;\n            }\n            resolve();\n          });\n        });\n      }\n\n      if (args.mkdirs) {\n        await this.ensureRemoteDir(sftp, remotePath);\n      }\n\n      await new Promise((resolve, reject) => {\n        sftp.fastPut(localPath, remotePath, (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n\n      if (args.preserve_mtime) {\n        const stat = await fs.stat(localPath);\n        await new Promise((resolve, reject) => {\n          sftp.utimes(remotePath, stat.atime, stat.mtime, (error) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      }\n    });\n\n    this.stats.sftp_ops += 1;\n    return { success: true, local_path: localPath, remote_path: remotePath };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 379,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1839,
        "end_line": 1929,
        "content": "async sftpDownload(args) {\n    const remotePath = this.validation.ensureString(args.remote_path, 'remote_path');\n    const localPath = expandHomePath(this.validation.ensureString(args.local_path, 'local_path'));\n    const overwrite = args.overwrite === true;\n    const tmpPath = `${localPath}.sentryfrogg.tmp-${crypto.randomBytes(4).toString('hex')}`;\n\n    if (!overwrite) {\n      try {\n        await fs.access(localPath);\n        throw new Error(`Local path already exists: ${localPath}`);\n      } catch (error) {\n        if (error.code !== 'ENOENT') {\n          throw error;\n        }\n      }\n    }\n\n    if (args.mkdirs) {\n      await fs.mkdir(path.dirname(localPath), { recursive: true });\n    }\n\n    let remoteTimes = null;\n    try {\n      await this.withSftp(args, async (sftp) => {\n        if (args.preserve_mtime) {\n          remoteTimes = await new Promise((resolve, reject) => {\n            sftp.stat(remotePath, (error, stat) => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve(stat);\n              }\n            });\n          });\n        }\n\n        await new Promise((resolve, reject) => {\n          sftp.fastGet(remotePath, tmpPath, (error) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    } catch (error) {\n      await fs.rm(tmpPath, { force: true }).catch(() => null);\n\n      if (error && (error.code === 2 || error.code === 'ENOENT')) {\n        this.stats.sftp_ops += 1;\n        return {\n          success: false,\n          remote_path: remotePath,\n          local_path: localPath,\n          code: 'ENOENT',\n          error: error.message || 'Remote path does not exist',\n        };\n      }\n\n      throw error;\n    }\n\n    if (remoteTimes && typeof remoteTimes === 'object') {\n      await fs.utimes(tmpPath, remoteTimes.atime, remoteTimes.mtime).catch(() => null);\n    }\n\n    const localExists = await fs.access(localPath).then(() => true).catch(() => false);\n    let backupPath = null;\n    if (overwrite && localExists) {\n      backupPath = `${localPath}.sentryfrogg.bak-${crypto.randomBytes(4).toString('hex')}`;\n      await fs.rename(localPath, backupPath);\n    }\n\n    try {\n      await fs.rename(tmpPath, localPath);\n    } catch (error) {\n      await fs.rm(tmpPath, { force: true }).catch(() => null);\n      if (backupPath) {\n        await fs.rename(backupPath, localPath).catch(() => null);\n      }\n      throw error;\n    }\n\n    if (backupPath) {\n      await fs.rm(backupPath, { force: true }).catch(() => null);\n    }\n\n    this.stats.sftp_ops += 1;\n    return { success: true, remote_path: remotePath, local_path: localPath };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 681,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1931,
        "end_line": 1951,
        "content": "async systemInfo(args) {\n    const commands = {\n      uname: 'uname -a',\n      os: 'cat /etc/os-release 2>/dev/null || sw_vers 2>/dev/null || echo \"OS info unavailable\"',\n      disk: 'df -h',\n      memory: 'free -h 2>/dev/null || vm_stat',\n      uptime: 'uptime',\n    };\n\n    const report = {};\n    for (const [key, cmd] of Object.entries(commands)) {\n      try {\n        const result = await this.execCommand({ ...args, command: cmd });\n        report[key] = { success: true, ...result };\n      } catch (error) {\n        report[key] = { success: false, error: error.message };\n      }\n    }\n\n    return { success: true, system_info: report };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 163,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1953,
        "end_line": 1963,
        "content": "async checkHost(args) {\n    try {\n      const result = await this.execCommand({\n        ...args,\n        command: 'echo \"Connection OK\" && whoami && hostname',\n      });\n      return { success: result.exitCode === 0, response: result.stdout };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 84,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1965,
        "end_line": 1968,
        "content": "getStats() {\n    const activeJobs = this.jobService ? this.jobService.getStats().jobs : this.jobs.size;\n    return { ...this.stats, active_connections: this.connections.size, active_jobs: activeJobs };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 53,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/SSHManager.ts",
        "start_line": 1970,
        "end_line": 1979,
        "content": "async cleanup() {\n    for (const entry of this.connections.values()) {\n      try {\n        entry.client.end();\n      } catch (error) {\n        // ignore cleanup errors\n      }\n    }\n    this.connections.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SSHManager",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/StateManager.ts": [
      {
        "file_path": "src/managers/StateManager.ts",
        "start_line": 9,
        "end_line": 12,
        "content": "constructor(logger, stateService) {\n    this.logger = logger.child('state');\n    this.stateService = stateService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateManager",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/StateManager.ts",
        "start_line": 14,
        "end_line": 37,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'set':\n        return this.stateService.set(args.key, args.value, args.scope);\n      case 'get':\n        return this.stateService.get(args.key, args.scope);\n      case 'list':\n        return this.stateService.list({\n          prefix: args.prefix,\n          scope: args.scope,\n          includeValues: args.include_values,\n        });\n      case 'unset':\n        return this.stateService.unset(args.key, args.scope);\n      case 'clear':\n        return this.stateService.clear(args.scope);\n      case 'dump':\n        return this.stateService.dump(args.scope);\n      default:\n        throw new Error(`Unknown state action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateManager",
          "estimated_tokens": 187,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/StateManager.ts",
        "start_line": 39,
        "end_line": 41,
        "content": "getStats() {\n    return this.stateService.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateManager",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/StateManager.ts",
        "start_line": 43,
        "end_line": 45,
        "content": "async cleanup() {\n    await this.stateService.cleanup();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateManager",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/VaultManager.ts": [
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 13,
        "end_line": 18,
        "content": "constructor(logger, validation, profileService, vaultClient) {\n    this.logger = logger.child('vault');\n    this.validation = validation;\n    this.profileService = profileService;\n    this.vaultClient = vaultClient;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 20,
        "end_line": 37,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n\n    switch (action) {\n      case 'profile_upsert':\n        return this.profileUpsert(args.profile_name, args);\n      case 'profile_get':\n        return this.profileGet(args.profile_name, args.include_secrets);\n      case 'profile_list':\n        return this.profileList();\n      case 'profile_delete':\n        return this.profileDelete(args.profile_name);\n      case 'profile_test':\n        return this.profileTest(args.profile_name, args);\n      default:\n        throw new Error(`Unknown vault action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 149,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 39,
        "end_line": 123,
        "content": "async profileUpsert(profileName, params = {}) {\n    const name = this.validation.ensureString(profileName, 'profile_name');\n    const addr = this.validation.ensureString(params.addr, 'addr', { trim: true });\n    const namespace = params.namespace === undefined\n      ? undefined\n      : (params.namespace === null || !String(params.namespace).trim() ? null : String(params.namespace).trim());\n\n    const authType = params.auth_type !== undefined && params.auth_type !== null && String(params.auth_type).trim()\n      ? String(params.auth_type).trim().toLowerCase()\n      : undefined;\n\n    const token = params.token === undefined ? undefined : (params.token === null ? null : String(params.token));\n    const roleId = params.role_id === undefined ? undefined : (params.role_id === null ? null : String(params.role_id));\n    const secretId = params.secret_id === undefined ? undefined : (params.secret_id === null ? null : String(params.secret_id));\n\n    const tokenValue = typeof token === 'string' && token.trim() ? token : null;\n    const roleIdValue = typeof roleId === 'string' && roleId.trim() ? roleId : null;\n    const secretIdValue = typeof secretId === 'string' && secretId.trim() ? secretId : null;\n\n    const inferredAuth = authType || (tokenValue ? 'token' : (roleIdValue || secretIdValue ? 'approle' : 'none'));\n    if (!['token', 'approle', 'none'].includes(inferredAuth)) {\n      throw new Error(`Unknown vault auth_type: ${String(inferredAuth)}`);\n    }\n\n    if (inferredAuth === 'token' && !tokenValue) {\n      throw new Error('token is required for vault auth_type=token');\n    }\n\n    if (inferredAuth === 'approle') {\n      if (!roleIdValue) {\n        throw new Error('role_id is required for vault auth_type=approle');\n      }\n      if (!secretIdValue) {\n        throw new Error('secret_id is required for vault auth_type=approle');\n      }\n    }\n\n    let previous = null;\n    try {\n      previous = await this.profileService.getProfile(name, VAULT_PROFILE_TYPE);\n    } catch (error) {\n      if (!String(error?.message || '').includes('not found')) {\n        throw error;\n      }\n    }\n\n    await this.profileService.setProfile(name, {\n      type: VAULT_PROFILE_TYPE,\n      data: { addr, namespace, auth_type: inferredAuth === 'none' ? null : inferredAuth },\n      secrets: {\n        token,\n        role_id: roleId,\n        secret_id: secretId,\n      },\n    });\n\n    try {\n      await this.vaultClient.sysHealth(name, { timeout_ms: params.timeout_ms });\n      if (tokenValue) {\n        await this.vaultClient.tokenLookupSelf(name, { timeout_ms: params.timeout_ms });\n      }\n    } catch (error) {\n      // Roll back on validation failure.\n      if (previous) {\n        await this.profileService.setProfile(name, {\n          type: VAULT_PROFILE_TYPE,\n          data: previous.data || {},\n          secrets: previous.secrets || {},\n        }).catch(() => null);\n      } else {\n        await this.profileService.deleteProfile(name).catch(() => null);\n      }\n      throw error;\n    }\n\n    return {\n      success: true,\n      profile: {\n        name,\n        type: VAULT_PROFILE_TYPE,\n        data: { addr, namespace, auth_type: inferredAuth === 'none' ? undefined : inferredAuth },\n        auth: inferredAuth === 'approle' ? 'approle' : (tokenValue ? 'token' : 'none'),\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 829,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 125,
        "end_line": 145,
        "content": "async profileGet(profileName, includeSecrets = false) {\n    const name = this.validation.ensureString(profileName, 'profile_name');\n    const profile = await this.profileService.getProfile(name, VAULT_PROFILE_TYPE);\n\n    const allow = isTruthy(process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT) || isTruthy(process.env.SF_ALLOW_SECRET_EXPORT);\n    if (includeSecrets && allow) {\n      return { success: true, profile };\n    }\n\n    const secretKeys = profile.secrets ? Object.keys(profile.secrets).sort() : [];\n    return {\n      success: true,\n      profile: {\n        name: profile.name,\n        type: profile.type,\n        data: profile.data,\n        secrets: secretKeys,\n        secrets_redacted: true,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 182,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 147,
        "end_line": 150,
        "content": "async profileList() {\n    const profiles = await this.profileService.listProfiles(VAULT_PROFILE_TYPE);\n    return { success: true, profiles };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 152,
        "end_line": 156,
        "content": "async profileDelete(profileName) {\n    const name = this.validation.ensureString(profileName, 'profile_name');\n    await this.profileService.deleteProfile(name);\n    return { success: true, profile: name };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/VaultManager.ts",
        "start_line": 158,
        "end_line": 170,
        "content": "async profileTest(profileName, params = {}) {\n    const name = this.validation.ensureString(profileName, 'profile_name');\n    const health = await this.vaultClient.sysHealth(name, { timeout_ms: params.timeout_ms });\n\n    let token = null;\n    try {\n      token = await this.vaultClient.tokenLookupSelf(name, { timeout_ms: params.timeout_ms });\n    } catch (error) {\n      token = { success: false, error: error.message };\n    }\n\n    return { success: true, profile_name: name, health, token };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultManager",
          "estimated_tokens": 127,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/managers/WorkspaceManager.ts": [
      {
        "file_path": "src/managers/WorkspaceManager.ts",
        "start_line": 9,
        "end_line": 16,
        "content": "constructor(logger, validation, workspaceService, runbookManager, intentManager, sshManager) {\n    this.logger = logger.child('workspace');\n    this.validation = validation;\n    this.workspaceService = workspaceService;\n    this.runbookManager = runbookManager;\n    this.intentManager = intentManager;\n    this.sshManager = sshManager;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceManager",
          "estimated_tokens": 88,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/WorkspaceManager.ts",
        "start_line": 18,
        "end_line": 38,
        "content": "async handleAction(args = {}) {\n    const { action } = args;\n    switch (action) {\n      case 'summary':\n        return this.workspaceService.summarize(this.normalizeArgs(args));\n      case 'suggest':\n        return this.workspaceService.suggest(this.normalizeArgs(args));\n      case 'diagnose':\n        return this.workspaceService.diagnose(this.normalizeArgs(args));\n      case 'store_status':\n        return this.workspaceService.getStoreStatus();\n      case 'run':\n        return this.run(args);\n      case 'cleanup':\n        return this.cleanup(args);\n      case 'stats':\n        return this.workspaceService.getStats();\n      default:\n        throw new Error(`Unknown workspace action: ${action}`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceManager",
          "estimated_tokens": 182,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/WorkspaceManager.ts",
        "start_line": 40,
        "end_line": 54,
        "content": "async cleanup() {\n    const results = {};\n\n    if (this.runbookManager?.cleanup) {\n      await this.runbookManager.cleanup();\n      results.runbook = { success: true };\n    }\n\n    if (this.sshManager?.cleanup) {\n      await this.sshManager.cleanup();\n      results.ssh = { success: true };\n    }\n\n    return { success: true, cleaned: Object.keys(results), results };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceManager",
          "estimated_tokens": 96,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/WorkspaceManager.ts",
        "start_line": 56,
        "end_line": 77,
        "content": "normalizeArgs(args) {\n    const payload = { ...args };\n    if (payload.project) {\n      payload.project = this.validation.ensureString(payload.project, 'project');\n    }\n    if (payload.target) {\n      payload.target = this.validation.ensureString(payload.target, 'target');\n    }\n    if (payload.cwd) {\n      payload.cwd = this.validation.ensureString(payload.cwd, 'cwd', { trim: false });\n    }\n    if (payload.repo_root) {\n      payload.repo_root = this.validation.ensureString(payload.repo_root, 'repo_root', { trim: false });\n    }\n    if (payload.key) {\n      payload.key = this.validation.ensureString(payload.key, 'key', { trim: false });\n    }\n    if (payload.limit !== undefined) {\n      payload.limit = Number(payload.limit);\n    }\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceManager",
          "estimated_tokens": 195,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/managers/WorkspaceManager.ts",
        "start_line": 79,
        "end_line": 103,
        "content": "async run(args) {\n    if (args.intent || args.intent_type || args.type) {\n      if (!this.intentManager) {\n        throw new Error('Intent manager is not available');\n      }\n      const type = args.intent?.type || args.intent_type || args.type;\n      if (!type) {\n        throw new Error('intent type is required');\n      }\n      const inputs = args.intent?.inputs || args.inputs || args.input || {};\n      const intent = { type, inputs };\n\n      const apply = Boolean(args.apply);\n      if (apply) {\n        return this.intentManager.handleAction({ ...args, action: 'execute', intent });\n      }\n\n      const compiled = await this.intentManager.handleAction({ ...args, action: 'compile', intent });\n      const requiresApply = Boolean(compiled?.plan?.effects?.requires_apply);\n\n      const action = requiresApply ? 'dry_run' : 'execute';\n      return this.intentManager.handleAction({ ...args, action, intent });\n    }\n    return this.runbookManager.handleAction({ ...args, action: 'runbook_run' });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceManager",
          "estimated_tokens": 255,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/AliasService.ts": [
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 13,
        "end_line": 24,
        "content": "constructor(logger) {\n    this.logger = logger.child('aliases');\n    this.filePath = resolveAliasesPath();\n    this.aliases = new Map();\n    this.stats = {\n      loaded: 0,\n      saved: 0,\n      created: 0,\n      updated: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 26,
        "end_line": 28,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 30,
        "end_line": 43,
        "content": "async load() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      for (const [name, alias] of Object.entries(parsed || {})) {\n        this.aliases.set(name, alias);\n      }\n      this.stats.loaded = this.aliases.size;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load aliases file', { error: error.message });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 113,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 45,
        "end_line": 49,
        "content": "async persist() {\n    const data = Object.fromEntries(this.aliases);\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 53,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 51,
        "end_line": 53,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 55,
        "end_line": 67,
        "content": "validateAlias(alias) {\n    if (!alias || typeof alias !== 'object' || Array.isArray(alias)) {\n      throw new Error('alias must be an object');\n    }\n    if (!alias.tool || typeof alias.tool !== 'string' || alias.tool.trim().length === 0) {\n      throw new Error('alias.tool must be a non-empty string');\n    }\n    if (alias.args !== undefined) {\n      if (typeof alias.args !== 'object' || alias.args === null || Array.isArray(alias.args)) {\n        throw new Error('alias.args must be an object');\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 132,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 69,
        "end_line": 95,
        "content": "async setAlias(name, alias) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('alias name must be a non-empty string');\n    }\n    this.validateAlias(alias);\n\n    const trimmed = name.trim();\n    const existing = this.aliases.get(trimmed);\n\n    const payload = {\n      ...alias,\n      updated_at: new Date().toISOString(),\n      created_at: existing?.created_at || new Date().toISOString(),\n    };\n\n    this.aliases.set(trimmed, payload);\n    await this.persist();\n\n    if (existing) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    return { success: true, alias: { name: trimmed, ...payload } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 179,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 97,
        "end_line": 108,
        "content": "async getAlias(name) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('alias name must be a non-empty string');\n    }\n    const trimmed = name.trim();\n    const entry = this.aliases.get(trimmed);\n    if (!entry) {\n      throw new Error(`alias '${trimmed}' not found`);\n    }\n    return { success: true, alias: { name: trimmed, ...entry } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 106,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 110,
        "end_line": 123,
        "content": "async listAliases() {\n    await this.ensureReady();\n    const items = [];\n    for (const [name, alias] of this.aliases.entries()) {\n      items.push({\n        name,\n        tool: alias.tool,\n        description: alias.description,\n        created_at: alias.created_at,\n        updated_at: alias.updated_at,\n      });\n    }\n    return { success: true, aliases: items };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 96,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 125,
        "end_line": 136,
        "content": "async deleteAlias(name) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('alias name must be a non-empty string');\n    }\n    const trimmed = name.trim();\n    if (!this.aliases.delete(trimmed)) {\n      throw new Error(`alias '${trimmed}' not found`);\n    }\n    await this.persist();\n    return { success: true, alias: trimmed };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 103,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 138,
        "end_line": 144,
        "content": "async resolveAlias(name) {\n    await this.ensureReady();\n    if (!name || typeof name !== 'string') {\n      return null;\n    }\n    return this.aliases.get(name) || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 146,
        "end_line": 148,
        "content": "getStats() {\n    return { ...this.stats, total: this.aliases.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AliasService.ts",
        "start_line": 150,
        "end_line": 152,
        "content": "async cleanup() {\n    this.aliases.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AliasService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/AuditService.ts": [
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 15,
        "end_line": 25,
        "content": "constructor(logger) {\n    this.logger = logger.child('audit');\n    this.filePath = resolveAuditPath();\n    this.stats = {\n      logged: 0,\n      errors: 0,\n      reads: 0,\n      cleared: 0,\n    };\n    this.queue = Promise.resolve();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 62,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 27,
        "end_line": 46,
        "content": "async append(entry) {\n    const payload = `${JSON.stringify(entry)}\\n`;\n    const write = async () => {\n      await fs.mkdir(path.dirname(this.filePath), { recursive: true, mode: 0o700 });\n      await fs.appendFile(this.filePath, payload, { encoding: 'utf8', mode: 0o600 });\n      try {\n        await fs.chmod(this.filePath, 0o600);\n      } catch (error) {\n        // Best-effort (Windows/FS policies).\n      }\n      this.stats.logged += 1;\n    };\n\n    this.queue = this.queue.then(write).catch((error) => {\n      this.stats.errors += 1;\n      this.logger.warn('Audit write failed', { error: error.message });\n    });\n\n    return this.queue;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 164,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 48,
        "end_line": 58,
        "content": "async clear() {\n    try {\n      await fs.unlink(this.filePath);\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n    this.stats.cleared += 1;\n    return { success: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 58,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 60,
        "end_line": 74,
        "content": "parseEntries(raw) {\n    const entries = [];\n    for (const line of raw.split(/\\r?\\n/)) {\n      if (!line.trim()) {\n        continue;\n      }\n      try {\n        const parsed = JSON.parse(line);\n        entries.push(parsed);\n      } catch (error) {\n        this.logger.warn('Skipping invalid audit entry', { error: error.message });\n      }\n    }\n    return entries;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 95,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 76,
        "end_line": 111,
        "content": "filterEntries(entries, filters = {}) {\n    const normalized = {\n      trace_id: filters.trace_id,\n      tool: filters.tool,\n      action: filters.action,\n      status: filters.status,\n      since: filters.since,\n    };\n\n    let sinceTime = null;\n    if (normalized.since) {\n      const parsed = Date.parse(normalized.since);\n      if (!Number.isNaN(parsed)) {\n        sinceTime = parsed;\n      }\n    }\n\n    return entries.filter((entry) => {\n      if (normalized.trace_id && entry.trace_id !== normalized.trace_id) {\n        return false;\n      }\n      if (normalized.tool && entry.tool !== normalized.tool) {\n        return false;\n      }\n      if (normalized.action && entry.action !== normalized.action) {\n        return false;\n      }\n      if (normalized.status && entry.status !== normalized.status) {\n        return false;\n      }\n      if (sinceTime && Date.parse(entry.timestamp) < sinceTime) {\n        return false;\n      }\n      return true;\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 244,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 113,
        "end_line": 153,
        "content": "buildFilter(filters = {}) {\n    const normalized = {\n      trace_id: filters.trace_id,\n      tool: filters.tool,\n      action: filters.action,\n      status: filters.status,\n      since: filters.since,\n    };\n\n    let sinceTime = null;\n    if (normalized.since) {\n      const parsed = Date.parse(normalized.since);\n      if (!Number.isNaN(parsed)) {\n        sinceTime = parsed;\n      }\n    }\n\n    const matches = (entry) => {\n      if (normalized.trace_id && entry.trace_id !== normalized.trace_id) {\n        return false;\n      }\n      if (normalized.tool && entry.tool !== normalized.tool) {\n        return false;\n      }\n      if (normalized.action && entry.action !== normalized.action) {\n        return false;\n      }\n      if (normalized.status && entry.status !== normalized.status) {\n        return false;\n      }\n      if (sinceTime) {\n        const ts = Date.parse(entry.timestamp);\n        if (!Number.isNaN(ts) && ts < sinceTime) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    return { normalized, sinceTime, matches };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 268,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 155,
        "end_line": 217,
        "content": "async readEntries({ limit = 100, offset = 0, reverse = false, filters = {} } = {}) {\n    const safeLimit = Number.isInteger(limit) ? Math.max(0, limit) : 100;\n    const safeOffset = Number.isInteger(offset) ? Math.max(0, offset) : 0;\n    const bufferSize = reverse ? safeLimit + safeOffset : 0;\n    const { matches } = this.buildFilter(filters);\n\n    let total = 0;\n    const collected = [];\n\n    try {\n      const stream = createReadStream(this.filePath, { encoding: 'utf8' });\n      try {\n        const rl = readline.createInterface({ input: stream, crlfDelay: Infinity });\n        for await (const line of rl) {\n          const trimmed = line.trim();\n          if (!trimmed) {\n            continue;\n          }\n          let entry;\n          try {\n            entry = JSON.parse(trimmed);\n          } catch (error) {\n            this.logger.warn('Skipping invalid audit entry', { error: error.message });\n            continue;\n          }\n          if (!matches(entry)) {\n            continue;\n          }\n\n          total += 1;\n\n          if (reverse) {\n            if (bufferSize > 0) {\n              collected.push(entry);\n              if (collected.length > bufferSize) {\n                collected.shift();\n              }\n            }\n            continue;\n          }\n\n          const index = total - 1;\n          if (index >= safeOffset && collected.length < safeLimit) {\n            collected.push(entry);\n          }\n        }\n      } finally {\n        stream.destroy();\n      }\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n\n    let entries = collected;\n    if (reverse) {\n      entries = collected.slice().reverse().slice(safeOffset, safeOffset + safeLimit);\n    }\n\n    this.stats.reads += 1;\n    return { success: true, total, offset: safeOffset, limit: safeLimit, entries };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 464,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 219,
        "end_line": 221,
        "content": "getStats() {\n    return { ...this.stats };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/AuditService.ts",
        "start_line": 223,
        "end_line": 225,
        "content": "async cleanup() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "AuditService",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/CacheService.ts": [
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 16,
        "end_line": 25,
        "content": "constructor(logger) {\n    this.logger = logger.child('cache');\n    this.cacheDir = resolveCacheDir();\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      writes: 0,\n      errors: 0,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 52,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 27,
        "end_line": 33,
        "content": "ensureKey(key) {\n    const normalized = typeof key === 'string' ? key.trim().toLowerCase() : '';\n    if (!/^[a-f0-9]{64}$/.test(normalized)) {\n      throw new Error('Cache key must be a sha256 hex string');\n    }\n    return normalized;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 62,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 35,
        "end_line": 52,
        "content": "normalizeKey(key) {\n    if (key === undefined || key === null || key === '') {\n      return null;\n    }\n\n    if (typeof key === 'string') {\n      const trimmed = key.trim();\n      if (!trimmed) {\n        return null;\n      }\n      if (/^[a-f0-9]{64}$/i.test(trimmed)) {\n        return trimmed.toLowerCase();\n      }\n      return this.buildKey(trimmed);\n    }\n\n    return this.buildKey(key);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 101,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 54,
        "end_line": 57,
        "content": "buildKey(input) {\n    const payload = this.stableStringify(input);\n    return crypto.createHash('sha256').update(payload).digest('hex');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 38,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 59,
        "end_line": 72,
        "content": "stableStringify(value) {\n    if (value === null || value === undefined) {\n      return String(value);\n    }\n    if (typeof value !== 'object') {\n      return JSON.stringify(value);\n    }\n    if (Array.isArray(value)) {\n      return `[${value.map((item) => this.stableStringify(item)).join(',')}]`;\n    }\n    const keys = Object.keys(value).sort();\n    const items = keys.map((key) => `${JSON.stringify(key)}:${this.stableStringify(value[key])}`);\n    return `{${items.join(',')}}`;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 124,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 74,
        "end_line": 77,
        "content": "entryPath(key) {\n    const normalized = this.ensureKey(key);\n    return path.join(this.cacheDir, `${normalized}.json`);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 33,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 79,
        "end_line": 82,
        "content": "dataPath(key) {\n    const normalized = this.ensureKey(key);\n    return path.join(this.cacheDir, `${normalized}.bin`);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 33,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 84,
        "end_line": 94,
        "content": "isExpired(meta, ttlOverride) {\n    const ttl = ttlOverride ?? meta.ttl_ms;\n    if (!ttl || !meta.created_at) {\n      return false;\n    }\n    const created = Date.parse(meta.created_at);\n    if (Number.isNaN(created)) {\n      return false;\n    }\n    return Date.now() - created > ttl;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 96,
        "end_line": 119,
        "content": "async getJson(key, ttlMs) {\n    try {\n      const raw = await fs.readFile(this.entryPath(key), 'utf8');\n      const payload = JSON.parse(raw);\n      if (payload?.type !== 'json') {\n        this.stats.misses += 1;\n        return null;\n      }\n      if (this.isExpired(payload, ttlMs)) {\n        await this.remove(key);\n        this.stats.misses += 1;\n        return null;\n      }\n      this.stats.hits += 1;\n      return payload;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.stats.errors += 1;\n        this.logger.warn('Cache read failed', { error: error.message });\n      }\n      this.stats.misses += 1;\n      return null;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 167,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 121,
        "end_line": 144,
        "content": "async getFile(key, ttlMs) {\n    try {\n      const raw = await fs.readFile(this.entryPath(key), 'utf8');\n      const payload = JSON.parse(raw);\n      if (payload?.type !== 'file') {\n        this.stats.misses += 1;\n        return null;\n      }\n      if (this.isExpired(payload, ttlMs)) {\n        await this.remove(key);\n        this.stats.misses += 1;\n        return null;\n      }\n      this.stats.hits += 1;\n      return { ...payload, file_path: this.dataPath(key) };\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.stats.errors += 1;\n        this.logger.warn('Cache read failed', { error: error.message });\n      }\n      this.stats.misses += 1;\n      return null;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 177,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 146,
        "end_line": 157,
        "content": "async setJson(key, value, meta = {}) {\n    const payload = {\n      type: 'json',\n      created_at: new Date().toISOString(),\n      ttl_ms: meta.ttl_ms,\n      meta: meta.meta,\n      value,\n    };\n    await atomicWriteTextFile(this.entryPath(key), `${JSON.stringify(payload, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.writes += 1;\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 92,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 159,
        "end_line": 189,
        "content": "async createFileWriter(key, meta = {}) {\n    key = this.ensureKey(key);\n    await fs.mkdir(this.cacheDir, { recursive: true, mode: 0o700 });\n    const tmpPath = tempSiblingPath(this.dataPath(key), '.part');\n    const stream = createWriteStream(tmpPath, { mode: 0o600 });\n\n    const finalize = async () => {\n      await atomicReplaceFile(tmpPath, this.dataPath(key), { overwrite: true, mode: 0o600 });\n      const payload = {\n        type: 'file',\n        created_at: new Date().toISOString(),\n        ttl_ms: meta.ttl_ms,\n        meta: meta.meta,\n      };\n      await atomicWriteTextFile(this.entryPath(key), `${JSON.stringify(payload, null, 2)}\\n`, { mode: 0o600 });\n      this.stats.writes += 1;\n      return payload;\n    };\n\n    const abort = async () => {\n      try {\n        await fs.unlink(tmpPath);\n      } catch (error) {\n        if (error.code !== 'ENOENT') {\n          this.logger.warn('Cache cleanup failed', { error: error.message });\n        }\n      }\n    };\n\n    return { stream, finalize, abort, temp_path: tmpPath };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 262,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 191,
        "end_line": 206,
        "content": "async remove(key) {\n    try {\n      await fs.unlink(this.entryPath(key));\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n    try {\n      await fs.unlink(this.dataPath(key));\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 82,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 208,
        "end_line": 210,
        "content": "getStats() {\n    return { ...this.stats };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CacheService.ts",
        "start_line": 212,
        "end_line": 214,
        "content": "async cleanup() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CacheService",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/CapabilityService.ts": [
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 13,
        "end_line": 31,
        "content": "constructor(logger, security) {\n    this.logger = logger.child('capabilities');\n    this.security = security;\n    this.filePath = resolveCapabilitiesPath();\n    this.defaultPath = resolveDefaultCapabilitiesPath();\n    this.capabilities = new Map();\n    this.sources = new Map();\n    this.stats = {\n      loaded: 0,\n      loaded_default: 0,\n      loaded_local: 0,\n      created: 0,\n      updated: 0,\n      saved: 0,\n      errors: 0,\n    };\n\n    this.initPromise = this.loadCapabilities();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 126,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 33,
        "end_line": 35,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 37,
        "end_line": 39,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 41,
        "end_line": 45,
        "content": "async loadCapabilities() {\n    await this.loadFromPath(this.defaultPath, 'default');\n    await this.loadFromPath(this.filePath, 'local');\n    this.stats.loaded = this.capabilities.size;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 51,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 47,
        "end_line": 83,
        "content": "async loadFromPath(filePath, source) {\n    if (!filePath) {\n      return;\n    }\n    try {\n      const raw = await fs.readFile(filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      const rawCapabilities = parsed.capabilities ?? parsed;\n      let count = 0;\n      if (Array.isArray(rawCapabilities)) {\n        for (const entry of rawCapabilities) {\n          if (entry && entry.name) {\n            this.capabilities.set(entry.name, entry);\n            this.sources.set(entry.name, source);\n            count += 1;\n          }\n        }\n      } else {\n        for (const [name, entry] of Object.entries(rawCapabilities || {})) {\n          this.capabilities.set(name, { ...entry, name });\n          this.sources.set(name, source);\n          count += 1;\n        }\n      }\n      if (count > 0) {\n        this.stats[`loaded_${source}`] += count;\n        this.logger.info('Capabilities loaded', { count, source });\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return;\n      }\n      this.stats.errors += 1;\n      this.logger.error('Failed to load capabilities', { error: error.message, source });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 292,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 85,
        "end_line": 93,
        "content": "async persist() {\n    const data = {\n      version: 1,\n      capabilities: Object.fromEntries(this.capabilities),\n    };\n    this.security.ensureSizeFits(JSON.stringify(data));\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 81,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 95,
        "end_line": 109,
        "content": "async listCapabilities() {\n    await this.ensureReady();\n    return Array.from(this.capabilities.values()).map((capability) => ({\n      name: capability.name,\n      intent: capability.intent,\n      description: capability.description,\n      runbook: capability.runbook,\n      effects: capability.effects,\n      inputs: capability.inputs,\n      depends_on: capability.depends_on || [],\n      tags: capability.tags || [],\n      when: capability.when,\n      source: this.sources.get(capability.name) || 'local',\n    }));\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 111,
        "end_line": 122,
        "content": "async getCapability(name) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('Capability name must be a non-empty string');\n    }\n    const key = name.trim();\n    const entry = this.capabilities.get(key);\n    if (!entry) {\n      throw new Error(`Capability '${name}' not found`);\n    }\n    return entry;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 97,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 124,
        "end_line": 127,
        "content": "async findByIntent(intentType) {\n    const matches = await this.findAllByIntent(intentType);\n    return matches.length > 0 ? matches[0] : null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 40,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 129,
        "end_line": 149,
        "content": "async findAllByIntent(intentType) {\n    await this.ensureReady();\n    if (typeof intentType !== 'string' || intentType.trim().length === 0) {\n      throw new Error('Intent type must be a non-empty string');\n    }\n    const key = intentType.trim();\n\n    const matches = [];\n    const direct = this.capabilities.get(key);\n    if (direct) {\n      matches.push(direct);\n    }\n\n    for (const capability of this.capabilities.values()) {\n      if (capability.intent === key && capability.name !== key) {\n        matches.push(capability);\n      }\n    }\n\n    return matches;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 146,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 151,
        "end_line": 182,
        "content": "async setCapability(name, config) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('Capability name must be a non-empty string');\n    }\n    if (typeof config !== 'object' || config === null || Array.isArray(config)) {\n      throw new Error('Capability config must be an object');\n    }\n\n    const trimmedName = name.trim();\n    const existing = this.capabilities.get(trimmedName) || {};\n    const now = new Date().toISOString();\n    const next = {\n      ...existing,\n      ...config,\n      name: trimmedName,\n      created_at: existing.created_at || now,\n      updated_at: now,\n    };\n\n    this.capabilities.set(trimmedName, next);\n    this.sources.set(trimmedName, 'local');\n    await this.persist();\n    if (existing.created_at) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    this.logger.info('Capability saved', { name: trimmedName });\n    return next;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 246,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 184,
        "end_line": 191,
        "content": "async deleteCapability(name) {\n    await this.ensureReady();\n    if (!this.capabilities.delete(name)) {\n      throw new Error(`Capability '${name}' not found`);\n    }\n    await this.persist();\n    return { success: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 60,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 193,
        "end_line": 195,
        "content": "getStats() {\n    return { ...this.stats, total: this.capabilities.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 23,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/CapabilityService.ts",
        "start_line": 197,
        "end_line": 199,
        "content": "async cleanup() {\n    this.capabilities.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "CapabilityService",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ContextService.ts": [
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 42,
        "end_line": 51,
        "content": "function normalizePath(value) {\n  if (!value || typeof value !== 'string') {\n    return undefined;\n  }\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return undefined;\n  }\n  return path.resolve(trimmed);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizePath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 53,
          "qualified_name": "normalizePath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 53,
        "end_line": 74,
        "content": "async function findGitRoot(startDir) {\n  if (!startDir) {\n    return undefined;\n  }\n  let current = startDir;\n  for (let depth = 0; depth < 25; depth += 1) {\n    const candidate = path.join(current, '.git');\n    try {\n      if (await pathExists(candidate)) {\n        return current;\n      }\n    } catch (error) {\n      return undefined;\n    }\n    const parent = path.dirname(current);\n    if (parent === current) {\n      break;\n    }\n    current = parent;\n  }\n  return undefined;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "findGitRoot",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 120,
          "qualified_name": "findGitRoot",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 76,
        "end_line": 98,
        "content": "async function detectMarkers(rootDir) {\n  const files = {};\n  const signals = {};\n\n  if (!rootDir) {\n    return { files, signals };\n  }\n\n  for (const marker of MARKERS) {\n    let hit = false;\n    for (const rel of marker.files) {\n      const full = path.isAbsolute(rel) ? rel : path.join(rootDir, rel);\n      const exists = await pathExists(full).catch(() => false);\n      files[rel] = exists;\n      if (exists) {\n        hit = true;\n      }\n    }\n    signals[marker.tag] = hit;\n  }\n\n  return { files, signals };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "detectMarkers",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 128,
          "qualified_name": "detectMarkers",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 100,
        "end_line": 111,
        "content": "function deriveTags(signals, gitRoot) {\n  const tags = Object.entries(signals)\n    .filter(([, value]) => value)\n    .map(([key]) => key);\n  if (signals.argocd || signals.flux) {\n    tags.push('gitops');\n  }\n  if (gitRoot) {\n    tags.push('git');\n  }\n  return tags.sort();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "deriveTags",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 68,
          "qualified_name": "deriveTags",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 114,
        "end_line": 125,
        "content": "constructor(logger, projectResolver) {\n    this.logger = logger.child('context');\n    this.projectResolver = projectResolver;\n    this.filePath = resolveContextPath();\n    this.contexts = new Map();\n    this.stats = {\n      loaded: 0,\n      saved: 0,\n      refreshed: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 82,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 127,
        "end_line": 129,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 131,
        "end_line": 149,
        "content": "async load() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      const entries = parsed.contexts || parsed;\n      if (entries && typeof entries === 'object' && !Array.isArray(entries)) {\n        for (const [key, value] of Object.entries(entries)) {\n          if (value && typeof value === 'object') {\n            this.contexts.set(key, value);\n          }\n        }\n      }\n      this.stats.loaded = this.contexts.size;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load context file', { error: error.message });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 163,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 151,
        "end_line": 158,
        "content": "async persist() {\n    const data = {\n      version: 1,\n      contexts: Object.fromEntries(this.contexts),\n    };\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 160,
        "end_line": 162,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 164,
        "end_line": 194,
        "content": "async resolveInputs(args = {}) {\n    let projectName = args.project ? String(args.project) : undefined;\n    let targetName = args.target ? String(args.target) : undefined;\n    let cwd = normalizePath(args.cwd);\n    let repoRoot = normalizePath(args.repo_root);\n\n    if (this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args).catch(() => null);\n      if (context?.projectName && !projectName) {\n        projectName = context.projectName;\n      }\n      if (context?.targetName && !targetName) {\n        targetName = context.targetName;\n      }\n      if (!cwd && context?.target?.cwd) {\n        cwd = normalizePath(context.target.cwd);\n      }\n      if (!repoRoot && context?.project?.repo_root) {\n        repoRoot = normalizePath(context.project.repo_root);\n      }\n    }\n\n    if (!cwd && repoRoot) {\n      cwd = repoRoot;\n    }\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n\n    return { projectName, targetName, cwd, repoRoot };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 246,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 196,
        "end_line": 204,
        "content": "buildKey({ key, projectName, targetName, cwd }) {\n    if (key && typeof key === 'string' && key.trim().length > 0) {\n      return key.trim();\n    }\n    if (projectName) {\n      return `project:${projectName}:${targetName || 'default'}`;\n    }\n    return `cwd:${cwd}`;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 206,
        "end_line": 219,
        "content": "async getContext(args = {}) {\n    await this.ensureReady();\n    const { projectName, targetName, cwd, repoRoot } = await this.resolveInputs(args);\n    const key = this.buildKey({ key: args.key, projectName, targetName, cwd });\n    const refresh = args.refresh === true;\n\n    const existing = this.contexts.get(key);\n    if (existing && !refresh) {\n      return { success: true, context: existing };\n    }\n\n    const updated = await this.refreshContext({ projectName, targetName, cwd, repoRoot, key });\n    return { success: true, context: updated };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 141,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 221,
        "end_line": 249,
        "content": "async refreshContext({ projectName, targetName, cwd, repoRoot, key }) {\n    await this.ensureReady();\n    const normalizedCwd = normalizePath(cwd) || process.cwd();\n    const gitRoot = await findGitRoot(normalizedCwd);\n    const root = repoRoot || gitRoot || normalizedCwd;\n\n    const { files, signals } = await detectMarkers(root);\n    const tags = deriveTags(signals, gitRoot);\n\n    const payload = {\n      key,\n      root,\n      cwd: normalizedCwd,\n      project_name: projectName,\n      target_name: targetName,\n      repo_root: repoRoot,\n      git: gitRoot ? { root: gitRoot } : undefined,\n      tags,\n      signals,\n      files,\n      updated_at: new Date().toISOString(),\n      host: os.hostname(),\n    };\n\n    this.contexts.set(key, payload);\n    await this.persist();\n    this.stats.refreshed += 1;\n    return payload;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 210,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 251,
        "end_line": 265,
        "content": "async listContexts() {\n    await this.ensureReady();\n    const items = [];\n    for (const [key, value] of this.contexts.entries()) {\n      items.push({\n        key,\n        updated_at: value.updated_at,\n        root: value.root,\n        tags: value.tags,\n        project_name: value.project_name,\n        target_name: value.target_name,\n      });\n    }\n    return { success: true, contexts: items };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 103,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 267,
        "end_line": 269,
        "content": "getStats() {\n    return { ...this.stats, total: this.contexts.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextService.ts",
        "start_line": 271,
        "end_line": 273,
        "content": "async cleanup() {\n    this.contexts.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextService",
          "estimated_tokens": 15,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ContextSessionService.ts": [
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 21,
        "end_line": 27,
        "content": "function normalizeString(value) {\n  if (value === undefined || value === null) {\n    return undefined;\n  }\n  const trimmed = String(value).trim();\n  return trimmed ? trimmed : undefined;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeString",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 47,
          "qualified_name": "normalizeString",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 29,
        "end_line": 39,
        "content": "function readRefEnv(value) {\n  if (typeof value !== 'string') {\n    return undefined;\n  }\n  const trimmed = value.trim();\n  if (!trimmed.startsWith('ref:env:')) {\n    return undefined;\n  }\n  const key = trimmed.slice('ref:env:'.length).trim();\n  return key || undefined;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readRefEnv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 68,
          "qualified_name": "readRefEnv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 41,
        "end_line": 50,
        "content": "function readRefVault(value) {\n  if (typeof value !== 'string') {\n    return undefined;\n  }\n  const trimmed = value.trim();\n  if (!trimmed.startsWith('ref:vault:')) {\n    return undefined;\n  }\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readRefVault",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 53,
          "qualified_name": "readRefVault",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 53,
        "end_line": 58,
        "content": "constructor(logger, contextService, projectResolver, profileService) {\n    this.logger = logger.child('context_session');\n    this.contextService = contextService;\n    this.projectResolver = projectResolver;\n    this.profileService = profileService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextSessionService",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 60,
        "end_line": 152,
        "content": "async resolve(args = {}) {\n    const diagnostics = {\n      errors: [],\n      warnings: [],\n      hints: [],\n    };\n\n    const contextResult = await this.contextService.getContext(args).catch((error) => {\n      diagnostics.errors.push({\n        code: 'context_failed',\n        message: error.message,\n      });\n      return { context: {} };\n    });\n    const context = contextResult.context || {};\n\n    let projectContext = null;\n    if (this.projectResolver) {\n      projectContext = await this.projectResolver.resolveContext(args).catch((error) => ({\n        error: error.message,\n      }));\n    }\n\n    if (projectContext?.error) {\n      diagnostics.errors.push({\n        code: 'project_resolution_failed',\n        message: projectContext.error,\n      });\n    }\n\n    const target = projectContext?.target || null;\n    const bindings = {\n      profiles: {},\n      paths: {},\n      urls: {},\n    };\n\n    if (target) {\n      for (const key of Object.keys(PROFILE_TYPES)) {\n        if (target[key]) {\n          bindings.profiles[key] = normalizeString(target[key]);\n        }\n      }\n\n      if (target.kubeconfig) {\n        bindings.paths.kubeconfig = normalizeString(target.kubeconfig);\n      }\n      if (target.sops_age_key_file) {\n        bindings.paths.sops_age_key_file = normalizeString(target.sops_age_key_file);\n      }\n      if (target.repo_path || target.repo_root) {\n        bindings.paths.repo_root = normalizeString(target.repo_path || target.repo_root);\n      }\n      if (target.cwd) {\n        bindings.paths.cwd = normalizeString(target.cwd);\n      }\n      if (target.api_base_url) {\n        bindings.urls.api_base_url = normalizeString(target.api_base_url);\n      }\n      if (target.registry_url) {\n        bindings.urls.registry_url = normalizeString(target.registry_url);\n      }\n    }\n\n    const effectiveTags = new Set(context.tags || []);\n    if (bindings.paths.kubeconfig) {\n      effectiveTags.add('k8s');\n    }\n    if (bindings.profiles.ssh_profile) {\n      effectiveTags.add('ssh');\n    }\n    if (bindings.urls.api_base_url) {\n      effectiveTags.add('api');\n    }\n    if (bindings.urls.registry_url) {\n      effectiveTags.add('registry');\n    }\n\n    const effectiveContext = {\n      ...context,\n      tags: Array.from(effectiveTags).sort(),\n    };\n\n    await this.checkBindings(bindings, diagnostics);\n\n    return {\n      context,\n      effective_context: effectiveContext,\n      project_context: projectContext && !projectContext.error ? projectContext : null,\n      diagnostics,\n      bindings,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextSessionService",
          "estimated_tokens": 637,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ContextSessionService.ts",
        "start_line": 154,
        "end_line": 235,
        "content": "async checkBindings(bindings, diagnostics) {\n    const pathChecks = [\n      { key: 'kubeconfig', label: 'kubeconfig' },\n      { key: 'sops_age_key_file', label: 'sops_age_key_file' },\n      { key: 'repo_root', label: 'repo_root' },\n    ];\n\n    for (const entry of pathChecks) {\n      const raw = bindings.paths[entry.key];\n      if (!raw) {\n        continue;\n      }\n      const refEnv = readRefEnv(raw);\n      if (refEnv) {\n        if (process.env[refEnv] === undefined) {\n          diagnostics.warnings.push({\n            code: 'env_ref_missing',\n            message: `–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–µ –∑–∞–¥–∞–Ω–∞: ${refEnv}`,\n            meta: { ref: raw },\n          });\n        }\n        continue;\n      }\n\n      const refVault = readRefVault(raw);\n      if (refVault) {\n        diagnostics.hints.push({\n          code: 'vault_ref_detected',\n          message: '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ vault-—Å—Å—ã–ª–∫–∞ –≤ –ø—É—Ç—è—Ö. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω vault_profile.',\n          meta: { ref: refVault },\n        });\n        continue;\n      }\n\n      const expanded = expandHomePath(raw);\n      const exists = await pathExists(expanded).catch(() => false);\n      if (!exists) {\n        diagnostics.warnings.push({\n          code: 'path_missing',\n          message: `–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${raw}`,\n          meta: { key: entry.key },\n        });\n      }\n    }\n\n    if (this.profileService) {\n      for (const [key, profileName] of Object.entries(bindings.profiles)) {\n        if (!profileName) {\n          continue;\n        }\n        if (!this.profileService.hasProfile(profileName)) {\n          diagnostics.warnings.push({\n            code: 'missing_profile',\n            message: `–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω: ${profileName}`,\n            meta: { key },\n          });\n          continue;\n        }\n\n        const expectedType = PROFILE_TYPES[key];\n        if (expectedType && this.profileService.probeProfileSecrets) {\n          const probe = await this.profileService.probeProfileSecrets(profileName, expectedType);\n          if (!probe.ok) {\n            diagnostics.warnings.push({\n              code: 'profile_secrets_unreadable',\n              message: `–°–µ–∫—Ä–µ—Ç—ã –ø—Ä–æ—Ñ–∏–ª—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã: ${profileName}`,\n              meta: { error: probe.error, key },\n            });\n          }\n        }\n      }\n    }\n\n    const apiRef = readRefEnv(bindings.urls.api_base_url);\n    if (apiRef && process.env[apiRef] === undefined) {\n      diagnostics.warnings.push({\n        code: 'env_ref_missing',\n        message: `–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–µ –∑–∞–¥–∞–Ω–∞: ${apiRef}`,\n        meta: { ref: bindings.urls.api_base_url },\n      });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ContextSessionService",
          "estimated_tokens": 681,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/EvidenceService.ts": [
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 13,
        "end_line": 18,
        "content": "function buildEvidenceId() {\n  if (crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  return crypto.randomBytes(16).toString('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildEvidenceId",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 35,
          "qualified_name": "buildEvidenceId",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 20,
        "end_line": 22,
        "content": "function safeTimestamp() {\n  return new Date().toISOString().replace(/[:.]/g, '-');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "safeTimestamp",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 21,
          "qualified_name": "safeTimestamp",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 25,
        "end_line": 29,
        "content": "constructor(logger, security) {\n    this.logger = logger.child('evidence');\n    this.security = security;\n    this.baseDir = resolveEvidenceDir();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceService",
          "estimated_tokens": 40,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 31,
        "end_line": 33,
        "content": "async ensureDir() {\n    await fs.mkdir(this.baseDir, { recursive: true });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceService",
          "estimated_tokens": 22,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 35,
        "end_line": 43,
        "content": "async saveEvidence(bundle) {\n    await this.ensureDir();\n    const payload = JSON.stringify(bundle, null, 2);\n    this.security.ensureSizeFits(payload);\n    const filename = `evidence-${safeTimestamp()}-${buildEvidenceId()}.json`;\n    const fullPath = path.join(this.baseDir, filename);\n    await fs.writeFile(fullPath, `${payload}\\n`, 'utf8');\n    return { path: fullPath, id: filename };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceService",
          "estimated_tokens": 101,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 45,
        "end_line": 60,
        "content": "async listEvidence(limit = 20) {\n    try {\n      const entries = await fs.readdir(this.baseDir, { withFileTypes: true });\n      const files = entries\n        .filter((entry) => entry.isFile() && entry.name.endsWith('.json'))\n        .map((entry) => entry.name)\n        .sort()\n        .reverse();\n      return files.slice(0, limit);\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceService",
          "estimated_tokens": 114,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/EvidenceService.ts",
        "start_line": 62,
        "end_line": 71,
        "content": "async getEvidence(id) {\n    if (typeof id !== 'string' || id.trim().length === 0) {\n      throw new Error('Evidence id must be a non-empty string');\n    }\n    const filename = path.basename(id.trim());\n    const fullPath = path.join(this.baseDir, filename);\n    const raw = await fs.readFile(fullPath, 'utf8');\n    this.security.ensureSizeFits(raw);\n    return { id: filename, path: fullPath, payload: JSON.parse(raw) };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "EvidenceService",
          "estimated_tokens": 109,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/JobService.ts": [
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 7,
        "end_line": 9,
        "content": "function nowIso() {\n  return new Date().toISOString();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "nowIso",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 14,
          "qualified_name": "nowIso",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 11,
        "end_line": 22,
        "content": "function resolveStoreKind() {\n  const raw = String(process.env.SENTRYFROGG_JOBS_STORE || process.env.SF_JOBS_STORE || 'memory')\n    .trim()\n    .toLowerCase();\n  if (!raw || raw === 'memory' || raw === 'mem' || raw === 'in-memory') {\n    return 'memory';\n  }\n  if (raw === 'file' || raw === 'durable' || raw === 'persistent' || raw === 'sqlite') {\n    return 'file';\n  }\n  return 'memory';\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveStoreKind",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 97,
          "qualified_name": "resolveStoreKind",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 25,
        "end_line": 33,
        "content": "constructor(logger) {\n    this.logger = logger?.child ? logger.child('jobs') : logger;\n    this.abortControllers = new Map();\n\n    const kind = resolveStoreKind();\n    this.store = kind === 'file'\n      ? new FileJobStore(this.logger)\n      : new MemoryJobStore(this.logger);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 71,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 35,
        "end_line": 42,
        "content": "ensureAbortController(jobId) {\n    if (this.abortControllers.has(jobId)) {\n      return this.abortControllers.get(jobId);\n    }\n    const controller = new AbortController();\n    this.abortControllers.set(jobId, controller);\n    return controller;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 44,
        "end_line": 49,
        "content": "purgeExpired(now = Date.now()) {\n    const removed = this.store.purgeExpired(now);\n    for (const jobId of removed) {\n      this.abortControllers.delete(jobId);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 44,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 51,
        "end_line": 57,
        "content": "pruneAbortControllers() {\n    for (const jobId of this.abortControllers.keys()) {\n      if (!this.store.has(jobId)) {\n        this.abortControllers.delete(jobId);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 47,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 59,
        "end_line": 65,
        "content": "create({ kind, trace_id, parent_span_id, provider, progress } = {}) {\n    this.purgeExpired();\n    const record = this.store.create({ kind, trace_id, parent_span_id, provider, progress });\n    this.ensureAbortController(record.job_id);\n    this.pruneAbortControllers();\n    return record;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 75,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 67,
        "end_line": 76,
        "content": "upsert(job) {\n    this.purgeExpired();\n    const next = this.store.upsert(job);\n    if (!next) {\n      return null;\n    }\n    this.ensureAbortController(next.job_id);\n    this.pruneAbortControllers();\n    return next;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 78,
        "end_line": 88,
        "content": "get(jobId) {\n    if (typeof jobId !== 'string' || !jobId.trim().length) {\n      return null;\n    }\n    this.purgeExpired();\n    const job = this.store.get(jobId.trim());\n    if (job) {\n      this.ensureAbortController(job.job_id);\n    }\n    return job || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 68,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 90,
        "end_line": 93,
        "content": "list({ limit, status } = {}) {\n    this.purgeExpired();\n    return this.store.list({ limit, status });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 28,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 95,
        "end_line": 102,
        "content": "forget(jobId) {\n    const existed = this.store.forget(jobId);\n    if (existed && typeof jobId === 'string') {\n      this.abortControllers.delete(jobId.trim());\n    }\n    this.pruneAbortControllers();\n    return existed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 57,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 104,
        "end_line": 107,
        "content": "getAbortSignal(jobId) {\n    const controller = this.ensureAbortController(jobId);\n    return controller.signal;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 30,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 109,
        "end_line": 126,
        "content": "cancel(jobId, reason) {\n    const job = this.get(jobId);\n    if (!job) {\n      return null;\n    }\n    const controller = this.ensureAbortController(job.job_id);\n    if (!controller.signal.aborted) {\n      controller.abort(reason || 'canceled');\n    }\n    const endedAt = nowIso();\n    const next = this.store.upsert({\n      job_id: job.job_id,\n      status: 'canceled',\n      ended_at: job.ended_at || endedAt,\n    });\n    this.pruneAbortControllers();\n    return next;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 120,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 128,
        "end_line": 132,
        "content": "getStats() {\n    this.purgeExpired();\n    this.pruneAbortControllers();\n    return this.store.getStats();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 29,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 134,
        "end_line": 136,
        "content": "async flush() {\n    await this.store.flush();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/JobService.ts",
        "start_line": 138,
        "end_line": 141,
        "content": "async cleanup() {\n    await this.flush();\n    this.abortControllers.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "JobService",
          "estimated_tokens": 22,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/Logger.ts": [
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 13,
        "end_line": 17,
        "content": "constructor(context = 'sentryfrogg', level = DEFAULT_LEVEL) {\n    this.context = context;\n    this.level = LEVELS[level] !== undefined ? level : 'info';\n    this.counters = { error: 0, warn: 0, info: 0, debug: 0 };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 19,
        "end_line": 21,
        "content": "shouldLog(level) {\n    return LEVELS[level] <= LEVELS[this.level];\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 23,
        "end_line": 34,
        "content": "log(level, message, meta) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    this.counters[level] += 1;\n    const timestamp = new Date().toISOString();\n    const metaSuffix = meta && Object.keys(meta).length > 0 ? ` ${JSON.stringify(meta)}` : '';\n    const line = `[${timestamp}] ${level.toUpperCase()} [${this.context}] ${message}${metaSuffix}`;\n\n    process.stderr.write(`${line}\\n`);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 101,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 36,
        "end_line": 38,
        "content": "error(message, meta = {}) {\n    this.log('error', message, meta);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 40,
        "end_line": 42,
        "content": "warn(message, meta = {}) {\n    this.log('warn', message, meta);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 44,
        "end_line": 46,
        "content": "info(message, meta = {}) {\n    this.log('info', message, meta);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 48,
        "end_line": 50,
        "content": "debug(message, meta = {}) {\n    this.log('debug', message, meta);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 18,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 52,
        "end_line": 55,
        "content": "child(suffix) {\n    const childContext = suffix ? `${this.context}:${suffix}` : this.context;\n    return new Logger(childContext, this.level);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 37,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 57,
        "end_line": 61,
        "content": "setLevel(level) {\n    if (LEVELS[level] !== undefined) {\n      this.level = level;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 24,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 63,
        "end_line": 65,
        "content": "setContext(context) {\n    this.context = context;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Logger.ts",
        "start_line": 67,
        "end_line": 69,
        "content": "getStats() {\n    return { level: this.level, context: this.context, ...this.counters };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Logger",
          "estimated_tokens": 23,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/PolicyService.ts": [
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 25,
        "end_line": 30,
        "content": "function ensureObject(value, label) {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error(`${label} must be an object`);\n  }\n  return value;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 44,
          "qualified_name": "ensureObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 32,
        "end_line": 37,
        "content": "function ensureOptionalObject(value, label) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  return ensureObject(value, label);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureOptionalObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 38,
          "qualified_name": "ensureOptionalObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 39,
        "end_line": 50,
        "content": "function normalizeStringArray(value) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error('must be an array of strings');\n  }\n  const items = value\n    .map((entry) => (entry === undefined || entry === null ? '' : String(entry).trim()))\n    .filter(Boolean);\n  return items.length > 0 ? items : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeStringArray",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 92,
          "qualified_name": "normalizeStringArray",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 52,
        "end_line": 58,
        "content": "function readTruthEnv(raw) {\n  if (raw === undefined || raw === null) {\n    return false;\n  }\n  const value = String(raw).trim().toLowerCase();\n  return value === '1' || value === 'true' || value === 'yes' || value === 'on';\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readTruthEnv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 56,
          "qualified_name": "readTruthEnv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 60,
        "end_line": 66,
        "content": "function normalizePolicyProfileName(value) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  const trimmed = String(value).trim();\n  return trimmed ? trimmed : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizePolicyProfileName",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 47,
          "qualified_name": "normalizePolicyProfileName",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 68,
        "end_line": 89,
        "content": "function parseTimeMinutes(raw, label) {\n  if (raw === undefined || raw === null || raw === '') {\n    return null;\n  }\n  const value = String(raw).trim();\n  if (value === '24:00') {\n    return 24 * 60;\n  }\n  const match = value.match(/^(\\d{1,2}):(\\d{2})$/);\n  if (!match) {\n    throw new Error(`${label} must be HH:MM (24h)`);\n  }\n  const hours = Number(match[1]);\n  const minutes = Number(match[2]);\n  if (!Number.isInteger(hours) || hours < 0 || hours > 23) {\n    throw new Error(`${label} hours must be 0-23`);\n  }\n  if (!Number.isInteger(minutes) || minutes < 0 || minutes > 59) {\n    throw new Error(`${label} minutes must be 0-59`);\n  }\n  return hours * 60 + minutes;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseTimeMinutes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 168,
          "qualified_name": "parseTimeMinutes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 91,
        "end_line": 122,
        "content": "function normalizeDays(value) {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error('days must be an array');\n  }\n  const days = new Set();\n  for (const raw of value) {\n    if (raw === '*' || raw === 'all') {\n      return null;\n    }\n    const normalized = typeof raw === 'string' ? raw.trim().toLowerCase() : raw;\n    if (typeof normalized === 'number') {\n      if (!Number.isInteger(normalized) || normalized < 0 || normalized > 6) {\n        throw new Error('days entries must be 0-6');\n      }\n      days.add(normalized);\n      continue;\n    }\n    if (typeof normalized === 'string') {\n      const idx = DAY_INDEX[normalized.slice(0, 3)];\n      if (idx === undefined) {\n        throw new Error(`Unknown day: ${raw}`);\n      }\n      days.add(idx);\n      continue;\n    }\n    throw new Error('days entries must be strings or numbers');\n  }\n  return days.size > 0 ? Array.from(days) : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeDays",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 239,
          "qualified_name": "normalizeDays",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 124,
        "end_line": 151,
        "content": "function normalizeChangeWindows(raw) {\n  if (raw === undefined || raw === null) {\n    return null;\n  }\n  if (!Array.isArray(raw)) {\n    throw new Error('change_windows must be an array');\n  }\n  const windows = [];\n  for (const entry of raw) {\n    const window = ensureObject(entry, 'change_windows entry');\n    const start = parseTimeMinutes(window.start, 'change_windows.start');\n    const end = parseTimeMinutes(window.end, 'change_windows.end');\n    const days = normalizeDays(window.days);\n    const tz = window.tz === undefined || window.tz === null || window.tz === ''\n      ? 'UTC'\n      : String(window.tz).trim();\n    if (tz !== 'UTC') {\n      throw new Error('change_windows.tz currently only supports UTC');\n    }\n    windows.push({\n      days,\n      start: start ?? 0,\n      end: end ?? 24 * 60,\n      tz,\n    });\n  }\n  return windows;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeChangeWindows",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 212,
          "qualified_name": "normalizeChangeWindows",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 153,
        "end_line": 186,
        "content": "function isWithinWindowsUtc(now, windows) {\n  if (!windows) {\n    return true;\n  }\n  if (!Array.isArray(windows) || windows.length === 0) {\n    return false;\n  }\n\n  const day = now.getUTCDay();\n  const minutes = now.getUTCHours() * 60 + now.getUTCMinutes();\n\n  for (const window of windows) {\n    const days = window.days;\n    const start = window.start;\n    const end = window.end;\n\n    const dayAllowed = !days || days.includes(day);\n    const prevDayAllowed = !days || days.includes((day + 6) % 7);\n\n    if (start <= end) {\n      if (dayAllowed && minutes >= start && minutes < end) {\n        return true;\n      }\n      continue;\n    }\n\n    // Cross-midnight window: D start‚Üí24:00 OR (D+1) 00:00‚Üíend.\n    if ((dayAllowed && minutes >= start) || (prevDayAllowed && minutes < end)) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isWithinWindowsUtc",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 209,
          "qualified_name": "isWithinWindowsUtc",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 188,
        "end_line": 191,
        "content": "function computeRepoRootKey(repoRoot) {\n  const hash = crypto.createHash('sha256').update(String(repoRoot || '')).digest('hex').slice(0, 16);\n  return `repo:${hash}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "computeRepoRootKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 42,
          "qualified_name": "computeRepoRootKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 194,
        "end_line": 198,
        "content": "constructor(logger, validation, stateService) {\n    this.logger = logger.child('policy');\n    this.validation = validation;\n    this.stateService = stateService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 44,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 200,
        "end_line": 217,
        "content": "resolvePolicy(inputs, projectContext) {\n    const direct = this.resolvePolicyValue(inputs?.policy ?? inputs?.policy_profile ?? inputs?.policy_profile_name, 'inputs.policy', projectContext);\n    if (direct) {\n      return direct;\n    }\n\n    const fromTarget = this.resolvePolicyValue(inputs?.target?.policy, 'target.policy', projectContext);\n    if (fromTarget) {\n      return fromTarget;\n    }\n\n    const fromProject = this.resolvePolicyValue(projectContext?.target?.policy, 'target.policy', projectContext);\n    if (fromProject) {\n      return fromProject;\n    }\n\n    return this.resolveAutonomyPolicy();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 155,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 219,
        "end_line": 243,
        "content": "resolveAutonomyPolicy() {\n    const raw = process.env.SENTRYFROGG_AUTONOMY_POLICY || process.env.SF_AUTONOMY_POLICY;\n    if (raw !== undefined && raw !== null && String(raw).trim() !== '') {\n      const trimmed = String(raw).trim();\n      if (trimmed === 'operatorless') {\n        return { mode: 'operatorless' };\n      }\n      if (trimmed.startsWith('{')) {\n        try {\n          const parsed = JSON.parse(trimmed);\n          return parsed && typeof parsed === 'object' ? parsed : null;\n        } catch (error) {\n          return null;\n        }\n      }\n      return null;\n    }\n\n    const autonomyFlag = process.env.SENTRYFROGG_AUTONOMY || process.env.SF_AUTONOMY;\n    if (readTruthEnv(autonomyFlag)) {\n      return { mode: 'operatorless' };\n    }\n\n    return null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 196,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 245,
        "end_line": 259,
        "content": "resolvePolicyProfile(name, projectContext) {\n    const trimmed = normalizePolicyProfileName(name);\n    if (!trimmed) {\n      return null;\n    }\n    const profiles = projectContext?.project?.policy_profiles;\n    if (!profiles || typeof profiles !== 'object' || Array.isArray(profiles)) {\n      return null;\n    }\n    const entry = profiles[trimmed];\n    if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {\n      return null;\n    }\n    return entry;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 119,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 261,
        "end_line": 276,
        "content": "resolvePolicyValue(value, label, projectContext) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n    if (typeof value === 'string') {\n      const profile = this.resolvePolicyProfile(value, projectContext);\n      if (!profile) {\n        throw new Error(`${label} profile '${value}' not found`);\n      }\n      return profile;\n    }\n    if (typeof value !== 'object' || Array.isArray(value)) {\n      throw new Error(`${label} must be an object or profile name`);\n    }\n    return value;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 131,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 278,
        "end_line": 329,
        "content": "normalizePolicy(policy) {\n    const payload = ensureObject(policy, 'policy');\n\n    const mode = payload.mode === undefined || payload.mode === null || payload.mode === ''\n      ? null\n      : String(payload.mode).trim();\n\n    const allowIntents = normalizeStringArray(payload.allow?.intents);\n    const allowMerge = payload.allow?.merge;\n    if (allowMerge !== undefined && typeof allowMerge !== 'boolean') {\n      throw new Error('policy.allow.merge must be a boolean');\n    }\n\n    const allowedRemotes = normalizeStringArray(payload.repo?.allowed_remotes);\n    const allowedNamespaces = normalizeStringArray(payload.kubernetes?.allowed_namespaces);\n\n    const changeWindows = normalizeChangeWindows(payload.change_windows);\n\n    const lockRaw = payload.lock === undefined || payload.lock === null ? null : ensureOptionalObject(payload.lock, 'policy.lock');\n    const lockEnabled = lockRaw?.enabled === undefined ? true : lockRaw.enabled;\n    if (lockEnabled !== undefined && typeof lockEnabled !== 'boolean') {\n      throw new Error('policy.lock.enabled must be a boolean');\n    }\n\n    const ttlMsRaw = lockRaw?.ttl_ms;\n    const ttlMs = ttlMsRaw === undefined || ttlMsRaw === null || ttlMsRaw === ''\n      ? DEFAULT_LOCK_TTL_MS\n      : Number(ttlMsRaw);\n\n    if (!Number.isFinite(ttlMs) || ttlMs <= 0) {\n      throw new Error('policy.lock.ttl_ms must be a positive number');\n    }\n\n    return {\n      mode,\n      allow: {\n        intents: allowIntents,\n        merge: allowMerge,\n      },\n      repo: {\n        allowed_remotes: allowedRemotes,\n      },\n      kubernetes: {\n        allowed_namespaces: allowedNamespaces,\n      },\n      change_windows: changeWindows,\n      lock: {\n        enabled: Boolean(lockEnabled),\n        ttl_ms: Math.min(Math.floor(ttlMs), MAX_LOCK_TTL_MS),\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 453,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 331,
        "end_line": 398,
        "content": "assertGitOpsWriteAllowed({ intentType, inputs, policy, now }) {\n    if (!policy) {\n      throw ToolError.denied({\n        code: 'POLICY_REQUIRED',\n        message: 'GitOps write intents require policy',\n        hint: 'Provide inputs.policy (mode=operatorless), configure target.policy, or set SENTRYFROGG_AUTONOMY_POLICY=operatorless.',\n      });\n    }\n\n    if (policy.mode !== 'operatorless') {\n      throw ToolError.denied({\n        code: 'POLICY_MODE_REQUIRED',\n        message: 'policy.mode=operatorless is required for GitOps write intents',\n        hint: 'Set inputs.policy.mode=\"operatorless\" (or target.policy.mode) and retry.',\n      });\n    }\n\n    if (policy.allow.intents && !policy.allow.intents.includes(intentType)) {\n      throw ToolError.denied({\n        code: 'POLICY_DENIED_INTENT',\n        message: `policy denies intent: ${intentType}`,\n        hint: 'Ask an operator to allow this intent in policy.allow.intents or choose an allowed intent.',\n        details: { intent_type: intentType },\n      });\n    }\n\n    if ((intentType === 'gitops.propose' || intentType === 'gitops.release') && inputs?.merge === true) {\n      if (policy.allow.merge === false) {\n        throw ToolError.denied({\n          code: 'POLICY_DENIED_MERGE',\n          message: 'policy denies merge',\n          hint: 'Set inputs.merge=false or ask an operator to allow merges (policy.allow.merge).',\n        });\n      }\n    }\n\n    if (policy.repo.allowed_remotes) {\n      const remote = inputs?.remote ? String(inputs.remote).trim() : 'origin';\n      if (!policy.repo.allowed_remotes.includes(remote)) {\n        throw ToolError.denied({\n          code: 'POLICY_DENIED_REMOTE',\n          message: `policy denies git remote: ${remote}`,\n          hint: 'Use an allowed remote or ask an operator to add it to policy.repo.allowed_remotes.',\n          details: { remote },\n        });\n      }\n    }\n\n    if (policy.kubernetes.allowed_namespaces && inputs?.namespace) {\n      const namespace = String(inputs.namespace).trim();\n      if (!policy.kubernetes.allowed_namespaces.includes(namespace)) {\n        throw ToolError.denied({\n          code: 'POLICY_DENIED_NAMESPACE',\n          message: `policy denies namespace: ${namespace}`,\n          hint: 'Choose an allowed namespace or ask an operator to add it to policy.kubernetes.allowed_namespaces.',\n          details: { namespace },\n        });\n      }\n    }\n\n    if (!isWithinWindowsUtc(now, policy.change_windows)) {\n      throw ToolError.denied({\n        code: 'POLICY_CHANGE_WINDOW',\n        message: 'policy denies write outside change window',\n        hint: 'Wait for the next change window or ask an operator to adjust policy.change_windows.',\n      });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 679,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 400,
        "end_line": 434,
        "content": "assertRepoWriteAllowed({ action, inputs, policy, now }) {\n    if (!policy) {\n      return;\n    }\n\n    if (policy.mode !== 'operatorless') {\n      throw ToolError.denied({\n        code: 'POLICY_MODE_REQUIRED',\n        message: 'policy.mode=operatorless is required for repo write operations',\n        hint: 'Set policy.mode=\"operatorless\" (in inputs.policy or target.policy) and retry.',\n        details: { action },\n      });\n    }\n\n    if (policy.repo.allowed_remotes && inputs?.remote !== undefined) {\n      const remote = inputs?.remote ? String(inputs.remote).trim() : 'origin';\n      if (!policy.repo.allowed_remotes.includes(remote)) {\n        throw ToolError.denied({\n          code: 'POLICY_DENIED_REMOTE',\n          message: `policy denies git remote: ${remote}`,\n          hint: 'Use an allowed remote or ask an operator to add it to policy.repo.allowed_remotes.',\n          details: { remote, action },\n        });\n      }\n    }\n\n    if (!isWithinWindowsUtc(now, policy.change_windows)) {\n      throw ToolError.denied({\n        code: 'POLICY_CHANGE_WINDOW',\n        message: 'policy denies write outside change window',\n        hint: 'Wait for the next change window or ask an operator to adjust policy.change_windows.',\n        details: { action },\n      });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 323,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 436,
        "end_line": 476,
        "content": "assertKubectlWriteAllowed({ inputs, policy, now }) {\n    if (!policy) {\n      return;\n    }\n\n    if (policy.mode !== 'operatorless') {\n      throw ToolError.denied({\n        code: 'POLICY_MODE_REQUIRED',\n        message: 'policy.mode=operatorless is required for kubectl write operations',\n        hint: 'Set policy.mode=\"operatorless\" (in inputs.policy or target.policy) and retry.',\n      });\n    }\n\n    if (policy.kubernetes.allowed_namespaces) {\n      const namespace = inputs?.namespace ? String(inputs.namespace).trim() : '';\n      if (!namespace) {\n        throw ToolError.denied({\n          code: 'POLICY_NAMESPACE_REQUIRED',\n          message: 'policy requires explicit namespace for kubectl write operations',\n          hint: 'Pass -n/--namespace (or use a tool that accepts namespace explicitly) and retry.',\n          details: { allowed_namespaces: policy.kubernetes.allowed_namespaces },\n        });\n      }\n      if (!policy.kubernetes.allowed_namespaces.includes(namespace)) {\n        throw ToolError.denied({\n          code: 'POLICY_DENIED_NAMESPACE',\n          message: `policy denies namespace: ${namespace}`,\n          hint: 'Choose an allowed namespace or ask an operator to add it to policy.kubernetes.allowed_namespaces.',\n          details: { namespace },\n        });\n      }\n    }\n\n    if (!isWithinWindowsUtc(now, policy.change_windows)) {\n      throw ToolError.denied({\n        code: 'POLICY_CHANGE_WINDOW',\n        message: 'policy denies write outside change window',\n        hint: 'Wait for the next change window or ask an operator to adjust policy.change_windows.',\n      });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 407,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 478,
        "end_line": 486,
        "content": "buildLockKey({ projectName, targetName, repoRoot }) {\n    if (projectName && targetName) {\n      return `gitops.lock.project:${projectName}:${targetName}`;\n    }\n    if (repoRoot) {\n      return `gitops.lock.${computeRepoRootKey(repoRoot)}`;\n    }\n    return null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 488,
        "end_line": 553,
        "content": "async acquireLock({ key, traceId, ttlMs, meta }) {\n    if (!this.stateService) {\n      throw new Error('state service is not available for lock enforcement');\n    }\n\n    const now = Date.now();\n    const nowIso = new Date(now).toISOString();\n    const expiresIso = new Date(now + ttlMs).toISOString();\n\n    const existing = await this.stateService.get(key, 'persistent');\n    const lock = existing?.value;\n\n    const parseExpires = (value) => {\n      if (!value || typeof value !== 'string') {\n        return null;\n      }\n      const ts = Date.parse(value);\n      return Number.isFinite(ts) ? ts : null;\n    };\n\n    const expired = (current) => {\n      if (!current || typeof current !== 'object') {\n        return true;\n      }\n      const expiresAt = parseExpires(current.expires_at);\n      if (expiresAt === null) {\n        return true;\n      }\n      return expiresAt <= now;\n    };\n\n    if (lock && typeof lock === 'object' && !expired(lock)) {\n      if (lock.trace_id && String(lock.trace_id) === String(traceId)) {\n        const nextCount = Math.max(1, Number(lock.count) || 1) + 1;\n        const next = {\n          ...lock,\n          count: nextCount,\n          updated_at: nowIso,\n          expires_at: expiresIso,\n        };\n        await this.stateService.set(key, next, 'persistent');\n        return next;\n      }\n\n      throw ToolError.conflict({\n        code: 'LOCK_HELD',\n        message: `environment lock is held (key=${key}) until ${lock.expires_at}`,\n        hint: 'Wait for the lock to expire, or cancel the conflicting operation before retrying.',\n        details: { key, expires_at: lock.expires_at, holder_trace_id: lock.trace_id },\n        retryable: true,\n      });\n    }\n\n    const next = {\n      ...(meta || {}),\n      trace_id: traceId,\n      acquired_at: nowIso,\n      updated_at: nowIso,\n      expires_at: expiresIso,\n      ttl_ms: ttlMs,\n      count: 1,\n    };\n\n    await this.stateService.set(key, next, 'persistent');\n    return next;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 495,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 555,
        "end_line": 578,
        "content": "async releaseLock({ key, traceId }) {\n    if (!this.stateService) {\n      return;\n    }\n\n    const nowIso = new Date().toISOString();\n    const existing = await this.stateService.get(key, 'persistent');\n    const lock = existing?.value;\n    if (!lock || typeof lock !== 'object') {\n      return;\n    }\n\n    if (!lock.trace_id || String(lock.trace_id) !== String(traceId)) {\n      return;\n    }\n\n    const count = Math.max(1, Number(lock.count) || 1);\n    if (count > 1) {\n      await this.stateService.set(key, { ...lock, count: count - 1, updated_at: nowIso }, 'persistent');\n      return;\n    }\n\n    await this.stateService.unset(key, 'persistent');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 166,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 580,
        "end_line": 627,
        "content": "async guardGitOpsWrite({ intentType, inputs, traceId, projectName, targetName, repoRoot, projectContext }) {\n    const rawPolicy = this.resolvePolicy(inputs, projectContext || null);\n    if (!rawPolicy) {\n      throw ToolError.denied({\n        code: 'POLICY_REQUIRED',\n        message: 'GitOps write intents require policy',\n        hint: 'Provide inputs.policy (mode=operatorless), configure target.policy, set project.policy_profiles, or set SENTRYFROGG_AUTONOMY_POLICY=operatorless.',\n      });\n    }\n    const normalized = this.normalizePolicy(rawPolicy);\n    this.assertGitOpsWriteAllowed({ intentType, inputs, policy: normalized, now: new Date() });\n\n    const lockKey = normalized.lock.enabled\n      ? this.buildLockKey({ projectName, targetName, repoRoot })\n      : null;\n\n    if (!lockKey && normalized.lock.enabled) {\n      throw ToolError.invalidParams({\n        message: 'policy.lock.enabled requires project/target or repo_root for lock scope',\n        hint: 'Provide project+target (via workspace/project) or pass repo_root so the lock scope can be derived.',\n      });\n    }\n\n    if (lockKey) {\n      await this.acquireLock({\n        key: lockKey,\n        traceId,\n        ttlMs: normalized.lock.ttl_ms,\n        meta: {\n          intent: intentType,\n          project: projectName || undefined,\n          target: targetName || undefined,\n          repo_root: repoRoot || undefined,\n        },\n      });\n    }\n\n    return {\n      policy: normalized,\n      lock_key: lockKey,\n      release: async () => {\n        if (!lockKey) {\n          return;\n        }\n        await this.releaseLock({ key: lockKey, traceId });\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 415,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 629,
        "end_line": 677,
        "content": "async guardRepoWrite({ action, inputs, traceId, projectContext, repoRoot }) {\n    const rawPolicy = this.resolvePolicy(inputs, projectContext);\n    if (!rawPolicy) {\n      return null;\n    }\n\n    const normalized = this.normalizePolicy(rawPolicy);\n    this.assertRepoWriteAllowed({ action, inputs, policy: normalized, now: new Date() });\n\n    const lockKey = normalized.lock.enabled\n      ? this.buildLockKey({\n        projectName: projectContext?.projectName,\n        targetName: projectContext?.targetName,\n        repoRoot,\n      })\n      : null;\n\n    if (!lockKey && normalized.lock.enabled) {\n      throw ToolError.invalidParams({\n        message: 'policy.lock.enabled requires project/target or repo_root for lock scope',\n        hint: 'Provide project+target (via workspace/project) or pass repo_root so the lock scope can be derived.',\n      });\n    }\n\n    if (lockKey) {\n      await this.acquireLock({\n        key: lockKey,\n        traceId,\n        ttlMs: normalized.lock.ttl_ms,\n        meta: {\n          action,\n          project: projectContext?.projectName || undefined,\n          target: projectContext?.targetName || undefined,\n          repo_root: repoRoot || undefined,\n        },\n      });\n    }\n\n    return {\n      policy: normalized,\n      lock_key: lockKey,\n      release: async () => {\n        if (!lockKey) {\n          return;\n        }\n        await this.releaseLock({ key: lockKey, traceId });\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 362,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PolicyService.ts",
        "start_line": 679,
        "end_line": 728,
        "content": "async guardKubectlWrite({ inputs, traceId, projectContext, repoRoot }) {\n    const rawPolicy = this.resolvePolicy(inputs, projectContext);\n    if (!rawPolicy) {\n      return null;\n    }\n\n    const normalized = this.normalizePolicy(rawPolicy);\n    this.assertKubectlWriteAllowed({ inputs, policy: normalized, now: new Date() });\n\n    const lockKey = normalized.lock.enabled\n      ? this.buildLockKey({\n        projectName: projectContext?.projectName,\n        targetName: projectContext?.targetName,\n        repoRoot,\n      })\n      : null;\n\n    if (!lockKey && normalized.lock.enabled) {\n      throw ToolError.invalidParams({\n        message: 'policy.lock.enabled requires project/target or repo_root for lock scope',\n        hint: 'Provide project+target (via workspace/project) or pass repo_root so the lock scope can be derived.',\n      });\n    }\n\n    if (lockKey) {\n      await this.acquireLock({\n        key: lockKey,\n        traceId,\n        ttlMs: normalized.lock.ttl_ms,\n        meta: {\n          action: 'kubectl',\n          namespace: inputs?.namespace || undefined,\n          project: projectContext?.projectName || undefined,\n          target: projectContext?.targetName || undefined,\n          repo_root: repoRoot || undefined,\n        },\n      });\n    }\n\n    return {\n      policy: normalized,\n      lock_key: lockKey,\n      release: async () => {\n        if (!lockKey) {\n          return;\n        }\n        await this.releaseLock({ key: lockKey, traceId });\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PolicyService",
          "estimated_tokens": 376,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/PresetService.ts": [
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 13,
        "end_line": 24,
        "content": "constructor(logger) {\n    this.logger = logger.child('presets');\n    this.filePath = resolvePresetsPath();\n    this.presets = new Map();\n    this.stats = {\n      loaded: 0,\n      saved: 0,\n      created: 0,\n      updated: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 26,
        "end_line": 28,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 30,
        "end_line": 53,
        "content": "async load() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      for (const [tool, entries] of Object.entries(parsed || {})) {\n        const bucket = new Map();\n        if (entries && typeof entries === 'object') {\n          for (const [name, preset] of Object.entries(entries)) {\n            bucket.set(name, preset);\n          }\n        }\n        this.presets.set(tool, bucket);\n      }\n      let count = 0;\n      for (const bucket of this.presets.values()) {\n        count += bucket.size;\n      }\n      this.stats.loaded = count;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load presets file', { error: error.message });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 192,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 55,
        "end_line": 62,
        "content": "async persist() {\n    const output = {};\n    for (const [tool, bucket] of this.presets.entries()) {\n      output[tool] = Object.fromEntries(bucket.entries());\n    }\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(output, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 64,
        "end_line": 66,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 68,
        "end_line": 77,
        "content": "normalizeTool(tool) {\n    if (!tool || typeof tool !== 'string') {\n      throw new Error('tool must be a non-empty string');\n    }\n    const trimmed = tool.trim();\n    if (!trimmed) {\n      throw new Error('tool must be a non-empty string');\n    }\n    return trimmed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 70,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 79,
        "end_line": 83,
        "content": "validatePreset(preset) {\n    if (!preset || typeof preset !== 'object' || Array.isArray(preset)) {\n      throw new Error('preset must be an object');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 42,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 85,
        "end_line": 93,
        "content": "getBucket(tool) {\n    const bucket = this.presets.get(tool);\n    if (bucket) {\n      return bucket;\n    }\n    const created = new Map();\n    this.presets.set(tool, created);\n    return created;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 52,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 95,
        "end_line": 123,
        "content": "async setPreset(tool, name, preset) {\n    await this.ensureReady();\n    const normalizedTool = this.normalizeTool(tool);\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('preset name must be a non-empty string');\n    }\n    this.validatePreset(preset);\n\n    const trimmedName = name.trim();\n    const bucket = this.getBucket(normalizedTool);\n    const existing = bucket.get(trimmedName);\n\n    const payload = {\n      ...preset,\n      updated_at: new Date().toISOString(),\n      created_at: existing?.created_at || new Date().toISOString(),\n    };\n\n    bucket.set(trimmedName, payload);\n    await this.persist();\n\n    if (existing) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    return { success: true, preset: { tool: normalizedTool, name: trimmedName, ...payload } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 215,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 125,
        "end_line": 139,
        "content": "async getPreset(tool, name) {\n    await this.ensureReady();\n    const normalizedTool = this.normalizeTool(tool);\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('preset name must be a non-empty string');\n    }\n\n    const bucket = this.presets.get(normalizedTool);\n    const trimmedName = name.trim();\n    if (!bucket || !bucket.has(trimmedName)) {\n      throw new Error(`preset '${trimmedName}' not found for tool '${normalizedTool}'`);\n    }\n\n    return { success: true, preset: { tool: normalizedTool, name: trimmedName, ...bucket.get(trimmedName) } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 152,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 141,
        "end_line": 171,
        "content": "async listPresets(tool) {\n    await this.ensureReady();\n\n    const output = [];\n    const appendBucket = (toolName, bucket) => {\n      for (const [name, preset] of bucket.entries()) {\n        output.push({\n          tool: toolName,\n          name,\n          description: preset.description,\n          created_at: preset.created_at,\n          updated_at: preset.updated_at,\n        });\n      }\n    };\n\n    if (tool) {\n      const normalizedTool = this.normalizeTool(tool);\n      const bucket = this.presets.get(normalizedTool);\n      if (bucket) {\n        appendBucket(normalizedTool, bucket);\n      }\n      return { success: true, presets: output };\n    }\n\n    for (const [toolName, bucket] of this.presets.entries()) {\n      appendBucket(toolName, bucket);\n    }\n\n    return { success: true, presets: output };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 206,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 173,
        "end_line": 188,
        "content": "async deletePreset(tool, name) {\n    await this.ensureReady();\n    const normalizedTool = this.normalizeTool(tool);\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('preset name must be a non-empty string');\n    }\n\n    const bucket = this.presets.get(normalizedTool);\n    const trimmedName = name.trim();\n    if (!bucket || !bucket.delete(trimmedName)) {\n      throw new Error(`preset '${trimmedName}' not found for tool '${normalizedTool}'`);\n    }\n\n    await this.persist();\n    return { success: true, preset: { tool: normalizedTool, name: trimmedName } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 153,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 190,
        "end_line": 205,
        "content": "async resolvePreset(tool, name) {\n    await this.ensureReady();\n    if (!tool || !name) {\n      return null;\n    }\n    const normalizedTool = String(tool).trim();\n    const trimmedName = String(name).trim();\n    if (!normalizedTool || !trimmedName) {\n      return null;\n    }\n    const bucket = this.presets.get(normalizedTool);\n    if (!bucket) {\n      return null;\n    }\n    return bucket.get(trimmedName) || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 108,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 207,
        "end_line": 213,
        "content": "getStats() {\n    let total = 0;\n    for (const bucket of this.presets.values()) {\n      total += bucket.size;\n    }\n    return { ...this.stats, total };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 42,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/PresetService.ts",
        "start_line": 215,
        "end_line": 217,
        "content": "async cleanup() {\n    this.presets.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "PresetService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ProfileService.ts": [
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 13,
        "end_line": 28,
        "content": "constructor(logger, security) {\n    this.logger = logger.child('profiles');\n    this.security = security;\n    this.baseDir = resolveProfileBaseDir();\n    this.filePath = resolveProfilesPath();\n    this.profiles = new Map();\n    this.stats = {\n      created: 0,\n      updated: 0,\n      loaded: 0,\n      saved: 0,\n      errors: 0,\n    };\n\n    this.initPromise = this.loadProfiles();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 99,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 30,
        "end_line": 32,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 34,
        "end_line": 39,
        "content": "ensurePlainObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 51,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 41,
        "end_line": 54,
        "content": "validateStoredProfile(name, profile) {\n    if (!profile || typeof profile !== 'object') {\n      throw new Error(`Profile '${name}' has invalid format`);\n    }\n    if (typeof profile.type !== 'string' || profile.type.trim().length === 0) {\n      throw new Error(`Profile '${name}' is missing type`);\n    }\n    if (profile.data && (typeof profile.data !== 'object' || Array.isArray(profile.data))) {\n      throw new Error(`Profile '${name}' has invalid data section`);\n    }\n    if (profile.secrets && (typeof profile.secrets !== 'object' || Array.isArray(profile.secrets))) {\n      throw new Error(`Profile '${name}' has invalid secrets section`);\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 167,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 56,
        "end_line": 75,
        "content": "async loadProfiles() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      for (const [name, profile] of Object.entries(parsed)) {\n        this.validateStoredProfile(name, profile);\n        this.profiles.set(name, profile);\n      }\n      this.stats.loaded = this.profiles.size;\n      this.logger.info('Profiles loaded', { count: this.profiles.size });\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        this.logger.info('profiles.json not found, starting clean');\n        return;\n      }\n      this.stats.errors += 1;\n      this.logger.error('Failed to load profiles', { error: error.message });\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 178,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 77,
        "end_line": 81,
        "content": "async persist() {\n    const data = Object.fromEntries(this.profiles);\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 53,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 83,
        "end_line": 85,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 87,
        "end_line": 98,
        "content": "async encryptSecret(value, label) {\n    if (value === undefined) {\n      return undefined;\n    }\n    if (value === null || value === '') {\n      return null;\n    }\n    if (typeof value !== 'string') {\n      throw new Error(`${label} must be a string`);\n    }\n    return this.security.encrypt(value);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 78,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 100,
        "end_line": 176,
        "content": "async setProfile(name, config) {\n    await this.ensureReady();\n\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('Profile name must be a non-empty string');\n    }\n\n    this.ensurePlainObject(config, 'Profile config');\n\n    const trimmedName = name.trim();\n    const existing = this.profiles.get(trimmedName) || {};\n    const incomingData = config.data ? this.ensurePlainObject(config.data, 'Profile data') : undefined;\n\n    const profile = {\n      type: config.type || existing.type,\n      data: { ...(existing.data || {}) },\n      created_at: existing.created_at || new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n\n    if (!profile.type) {\n      throw new Error('Profile type must be specified');\n    }\n\n    if (incomingData) {\n      for (const [key, value] of Object.entries(incomingData)) {\n        if (value === undefined) {\n          continue;\n        }\n        if (value === null) {\n          delete profile.data[key];\n          continue;\n        }\n        profile.data[key] = value;\n      }\n    }\n\n    let secrets = existing.secrets ? { ...existing.secrets } : {};\n    if (config.secrets === null) {\n      secrets = {};\n    } else if (config.secrets !== undefined) {\n      const incomingSecrets = this.ensurePlainObject(config.secrets, 'Profile secrets');\n      for (const [key, rawValue] of Object.entries(incomingSecrets)) {\n        const encrypted = await this.encryptSecret(rawValue, `Secret '${key}'`);\n        if (encrypted === null) {\n          delete secrets[key];\n        } else if (encrypted !== undefined) {\n          secrets[key] = encrypted;\n        }\n      }\n    }\n\n    if (Object.keys(secrets).length > 0) {\n      profile.secrets = secrets;\n    } else {\n      delete profile.secrets;\n    }\n\n    this.profiles.set(trimmedName, profile);\n    await this.persist();\n\n    if (existing.created_at) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    this.logger.info('Profile saved', { name: trimmedName, type: profile.type });\n\n    return {\n      name: trimmedName,\n      type: profile.type,\n      data: profile.data,\n      created_at: profile.created_at,\n      updated_at: profile.updated_at,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 558,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 178,
        "end_line": 210,
        "content": "async getProfile(name, expectedType) {\n    await this.ensureReady();\n\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('Profile name must be a non-empty string');\n    }\n\n    const key = name.trim();\n    const entry = this.profiles.get(key);\n    if (!entry) {\n      throw new Error(`Profile '${name}' not found`);\n    }\n\n    if (expectedType && entry.type !== expectedType) {\n      throw new Error(`Profile '${name}' is of type '${entry.type}', expected '${expectedType}'`);\n    }\n\n    const result = {\n      name: key,\n      type: entry.type,\n      data: { ...(entry.data || {}) },\n    };\n\n    if (entry.secrets) {\n      const decrypted = {};\n      for (const [field, value] of Object.entries(entry.secrets)) {\n        decrypted[field] = await this.security.decrypt(value);\n      }\n      result.secrets = decrypted;\n    }\n\n    return result;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 223,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 212,
        "end_line": 230,
        "content": "async listProfiles(type) {\n    await this.ensureReady();\n\n    const items = [];\n    for (const [name, profile] of this.profiles.entries()) {\n      if (type && profile.type !== type) {\n        continue;\n      }\n      items.push({\n        name,\n        type: profile.type,\n        data: profile.data || {},\n        created_at: profile.created_at,\n        updated_at: profile.updated_at,\n      });\n    }\n\n    return items;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 108,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 232,
        "end_line": 240,
        "content": "async deleteProfile(name) {\n    await this.ensureReady();\n    if (!this.profiles.delete(name)) {\n      throw new Error(`Profile '${name}' not found`);\n    }\n    await this.persist();\n    this.logger.info('Profile deleted', { name });\n    return { success: true };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 69,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 242,
        "end_line": 244,
        "content": "hasProfile(name) {\n    return this.profiles.has(name);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 17,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 246,
        "end_line": 274,
        "content": "async probeProfileSecrets(name, expectedType) {\n    await this.ensureReady();\n\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      return { ok: false, error: 'Profile name must be a non-empty string' };\n    }\n\n    const key = name.trim();\n    const entry = this.profiles.get(key);\n    if (!entry) {\n      return { ok: false, error: `Profile '${name}' not found` };\n    }\n    if (expectedType && entry.type !== expectedType) {\n      return { ok: false, error: `Profile '${name}' is of type '${entry.type}', expected '${expectedType}'` };\n    }\n\n    if (!entry.secrets || Object.keys(entry.secrets).length === 0) {\n      return { ok: true, encrypted: false };\n    }\n\n    try {\n      for (const value of Object.values(entry.secrets)) {\n        await this.security.decrypt(value);\n      }\n      return { ok: true, encrypted: true };\n    } catch (error) {\n      return { ok: false, encrypted: true, error: error.message };\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 239,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 276,
        "end_line": 278,
        "content": "getStats() {\n    return { ...this.stats, total: this.profiles.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProfileService.ts",
        "start_line": 280,
        "end_line": 282,
        "content": "async cleanup() {\n    this.profiles.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProfileService",
          "estimated_tokens": 15,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ProjectResolver.ts": [
      {
        "file_path": "src/services/ProjectResolver.ts",
        "start_line": 17,
        "end_line": 21,
        "content": "constructor(validation, projectService, stateService) {\n    this.validation = validation;\n    this.projectService = projectService;\n    this.stateService = stateService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectResolver",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectResolver.ts",
        "start_line": 23,
        "end_line": 39,
        "content": "async resolveProjectName(args = {}) {\n    const direct = args.project || args.project_name;\n    if (direct) {\n      return this.validation.ensureString(String(direct), 'project');\n    }\n\n    if (!this.stateService) {\n      return undefined;\n    }\n\n    const active = await this.stateService.get(ACTIVE_PROJECT_KEY, 'any').catch(() => null);\n    if (active && active.value) {\n      return this.validation.ensureString(String(active.value), 'project');\n    }\n\n    return undefined;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectResolver",
          "estimated_tokens": 123,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectResolver.ts",
        "start_line": 41,
        "end_line": 72,
        "content": "resolveTarget(project, args = {}) {\n    const targets = project.targets && typeof project.targets === 'object' ? project.targets : {};\n    const requested = args.target || args.project_target || args.environment;\n\n    if (requested) {\n      const name = this.validation.ensureString(String(requested), 'target');\n      const entry = targets[name];\n      if (!entry) {\n        throw new Error(`Unknown project target: ${name}`);\n      }\n      return { name, entry };\n    }\n\n    if (project.default_target) {\n      const name = String(project.default_target);\n      const entry = targets[name];\n      if (entry) {\n        return { name, entry };\n      }\n    }\n\n    const names = Object.keys(targets);\n    if (names.length === 1) {\n      return { name: names[0], entry: targets[names[0]] };\n    }\n\n    if (names.length === 0) {\n      throw new Error('Project has no targets configured');\n    }\n\n    throw new Error('target is required when project has multiple targets');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectResolver",
          "estimated_tokens": 246,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectResolver.ts",
        "start_line": 74,
        "end_line": 93,
        "content": "async resolveContext(args = {}) {\n    const projectName = await this.resolveProjectName(args);\n    if (!projectName) {\n      return null;\n    }\n\n    if (!this.projectService) {\n      throw new Error('Project resolution is unavailable (projectService not configured)');\n    }\n\n    const project = await this.projectService.getProject(projectName);\n    const target = this.resolveTarget(project.project, args);\n\n    return {\n      projectName,\n      project: project.project,\n      targetName: target.name,\n      target: target.entry,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectResolver",
          "estimated_tokens": 138,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ProjectService.ts": [
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 13,
        "end_line": 25,
        "content": "constructor(logger) {\n    this.logger = logger.child('projects');\n    this.filePath = resolveProjectsPath();\n    this.projects = new Map();\n    this.stats = {\n      loaded: 0,\n      saved: 0,\n      created: 0,\n      updated: 0,\n      errors: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 75,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 27,
        "end_line": 29,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 31,
        "end_line": 33,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 35,
        "end_line": 50,
        "content": "async load() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      for (const [name, project] of Object.entries(parsed || {})) {\n        this.validateProject(project);\n        this.projects.set(name, project);\n      }\n      this.stats.loaded = this.projects.size;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.stats.errors += 1;\n        this.logger.warn('Failed to load projects file', { error: error.message });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 132,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 52,
        "end_line": 56,
        "content": "async persist() {\n    const data = Object.fromEntries(this.projects);\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 53,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 58,
        "end_line": 120,
        "content": "validatePolicyObject(policy, labelPrefix) {\n    if (!policy || typeof policy !== 'object' || Array.isArray(policy)) {\n      throw new Error(`${labelPrefix} must be an object`);\n    }\n\n    const allowString = (value, label) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (typeof value !== 'string' || value.trim().length === 0) {\n        throw new Error(`${label} must be a non-empty string`);\n      }\n    };\n\n    allowString(policy.mode, `${labelPrefix}.mode`);\n\n    const allowOptionalObject = (value, label) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (typeof value !== 'object' || Array.isArray(value)) {\n        throw new Error(`${label} must be an object`);\n      }\n    };\n\n    allowOptionalObject(policy.allow, `${labelPrefix}.allow`);\n    if (policy.allow?.intents !== undefined && policy.allow?.intents !== null) {\n      if (!Array.isArray(policy.allow.intents)) {\n        throw new Error(`${labelPrefix}.allow.intents must be an array`);\n      }\n    }\n\n    allowOptionalObject(policy.repo, `${labelPrefix}.repo`);\n    if (policy.repo?.allowed_remotes !== undefined && policy.repo?.allowed_remotes !== null) {\n      if (!Array.isArray(policy.repo.allowed_remotes)) {\n        throw new Error(`${labelPrefix}.repo.allowed_remotes must be an array`);\n      }\n    }\n\n    allowOptionalObject(policy.kubernetes, `${labelPrefix}.kubernetes`);\n    if (policy.kubernetes?.allowed_namespaces !== undefined && policy.kubernetes?.allowed_namespaces !== null) {\n      if (!Array.isArray(policy.kubernetes.allowed_namespaces)) {\n        throw new Error(`${labelPrefix}.kubernetes.allowed_namespaces must be an array`);\n      }\n    }\n\n    if (policy.change_windows !== undefined && policy.change_windows !== null) {\n      if (!Array.isArray(policy.change_windows)) {\n        throw new Error(`${labelPrefix}.change_windows must be an array`);\n      }\n    }\n\n    allowOptionalObject(policy.lock, `${labelPrefix}.lock`);\n    if (policy.lock?.enabled !== undefined && typeof policy.lock.enabled !== 'boolean') {\n      throw new Error(`${labelPrefix}.lock.enabled must be a boolean`);\n    }\n    if (policy.lock?.ttl_ms !== undefined && policy.lock.ttl_ms !== null) {\n      const numeric = Number(policy.lock.ttl_ms);\n      if (!Number.isFinite(numeric) || numeric <= 0) {\n        throw new Error(`${labelPrefix}.lock.ttl_ms must be a positive number`);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 614,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 122,
        "end_line": 154,
        "content": "validateTarget(target) {\n    if (!target || typeof target !== 'object' || Array.isArray(target)) {\n      throw new Error('project.targets entries must be objects');\n    }\n\n    const allowString = (value, label) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (typeof value !== 'string' || value.trim().length === 0) {\n        throw new Error(`${label} must be a non-empty string`);\n      }\n    };\n\n    const policy = target.policy;\n    if (policy !== undefined && policy !== null) {\n      if (typeof policy === 'string') {\n        allowString(policy, 'target.policy');\n      } else {\n        this.validatePolicyObject(policy, 'target.policy');\n      }\n    }\n\n    allowString(target.ssh_profile, 'target.ssh_profile');\n    allowString(target.env_profile, 'target.env_profile');\n    allowString(target.postgres_profile, 'target.postgres_profile');\n    allowString(target.api_profile, 'target.api_profile');\n    allowString(target.vault_profile, 'target.vault_profile');\n    allowString(target.cwd, 'target.cwd');\n    allowString(target.env_path, 'target.env_path');\n    allowString(target.description, 'target.description');\n\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 295,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 156,
        "end_line": 200,
        "content": "validateProject(project) {\n    if (!project || typeof project !== 'object' || Array.isArray(project)) {\n      throw new Error('project must be an object');\n    }\n\n    if (project.description !== undefined && (typeof project.description !== 'string')) {\n      throw new Error('project.description must be a string');\n    }\n\n    if (project.default_target !== undefined) {\n      if (typeof project.default_target !== 'string' || project.default_target.trim().length === 0) {\n        throw new Error('project.default_target must be a non-empty string');\n      }\n    }\n\n    if (project.repo_root !== undefined && project.repo_root !== null) {\n      if (typeof project.repo_root !== 'string' || project.repo_root.trim().length === 0) {\n        throw new Error('project.repo_root must be a non-empty string');\n      }\n    }\n\n    if (project.policy_profiles !== undefined && project.policy_profiles !== null) {\n      if (typeof project.policy_profiles !== 'object' || Array.isArray(project.policy_profiles)) {\n        throw new Error('project.policy_profiles must be an object');\n      }\n      for (const [name, policy] of Object.entries(project.policy_profiles)) {\n        if (typeof name !== 'string' || name.trim().length === 0) {\n          throw new Error('project.policy_profiles keys must be non-empty strings');\n        }\n        this.validatePolicyObject(policy, `project.policy_profiles.${name}`);\n      }\n    }\n\n    if (project.targets !== undefined) {\n      if (!project.targets || typeof project.targets !== 'object' || Array.isArray(project.targets)) {\n        throw new Error('project.targets must be an object');\n      }\n      for (const [name, target] of Object.entries(project.targets)) {\n        if (typeof name !== 'string' || name.trim().length === 0) {\n          throw new Error('project.targets keys must be non-empty strings');\n        }\n        this.validateTarget(target);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 480,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 202,
        "end_line": 207,
        "content": "normalizeName(name) {\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('project name must be a non-empty string');\n    }\n    return name.trim();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 49,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 209,
        "end_line": 231,
        "content": "async setProject(name, project) {\n    await this.ensureReady();\n    const trimmed = this.normalizeName(name);\n    this.validateProject(project);\n\n    const existing = this.projects.get(trimmed);\n    const payload = {\n      ...project,\n      updated_at: new Date().toISOString(),\n      created_at: existing?.created_at || new Date().toISOString(),\n    };\n\n    this.projects.set(trimmed, payload);\n    await this.persist();\n\n    if (existing) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    return { success: true, project: { name: trimmed, ...payload } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 152,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 233,
        "end_line": 241,
        "content": "async getProject(name) {\n    await this.ensureReady();\n    const trimmed = this.normalizeName(name);\n    const entry = this.projects.get(trimmed);\n    if (!entry) {\n      throw new Error(`project '${trimmed}' not found`);\n    }\n    return { success: true, project: { name: trimmed, ...entry } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 243,
        "end_line": 257,
        "content": "async listProjects() {\n    await this.ensureReady();\n    const items = [];\n    for (const [name, project] of this.projects.entries()) {\n      items.push({\n        name,\n        description: project.description,\n        default_target: project.default_target,\n        targets: project.targets ? Object.keys(project.targets).length : 0,\n        created_at: project.created_at,\n        updated_at: project.updated_at,\n      });\n    }\n    return { success: true, projects: items };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 123,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 259,
        "end_line": 267,
        "content": "async deleteProject(name) {\n    await this.ensureReady();\n    const trimmed = this.normalizeName(name);\n    if (!this.projects.delete(trimmed)) {\n      throw new Error(`project '${trimmed}' not found`);\n    }\n    await this.persist();\n    return { success: true, project: trimmed };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 269,
        "end_line": 275,
        "content": "async resolveProject(name) {\n    await this.ensureReady();\n    if (!name || typeof name !== 'string') {\n      return null;\n    }\n    return this.projects.get(name.trim()) || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 48,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 277,
        "end_line": 279,
        "content": "getStats() {\n    return { ...this.stats, total: this.projects.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ProjectService.ts",
        "start_line": 281,
        "end_line": 283,
        "content": "async cleanup() {\n    this.projects.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ProjectService",
          "estimated_tokens": 15,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/RunbookService.ts": [
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 13,
        "end_line": 28,
        "content": "constructor(logger) {\n    this.logger = logger.child('runbooks');\n    this.filePath = resolveRunbooksPath();\n    this.defaultPath = resolveDefaultRunbooksPath();\n    this.runbooks = new Map();\n    this.sources = new Map();\n    this.stats = {\n      loaded: 0,\n      loaded_default: 0,\n      loaded_local: 0,\n      saved: 0,\n      created: 0,\n      updated: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 104,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 30,
        "end_line": 32,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 34,
        "end_line": 38,
        "content": "async load() {\n    await this.loadFromPath(this.defaultPath, 'default');\n    await this.loadFromPath(this.filePath, 'local');\n    this.stats.loaded = this.runbooks.size;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 40,
        "end_line": 61,
        "content": "async loadFromPath(filePath, source) {\n    if (!filePath) {\n      return;\n    }\n    try {\n      const raw = await fs.readFile(filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      let count = 0;\n      for (const [name, runbook] of Object.entries(parsed || {})) {\n        this.runbooks.set(name, runbook);\n        this.sources.set(name, source);\n        count += 1;\n      }\n      if (count > 0) {\n        this.stats[`loaded_${source}`] += count;\n      }\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load runbooks file', { error: error.message, source });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 160,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 63,
        "end_line": 67,
        "content": "async persist() {\n    const data = Object.fromEntries(this.runbooks);\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(data, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 53,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 69,
        "end_line": 71,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 73,
        "end_line": 80,
        "content": "validateRunbook(runbook) {\n    if (!runbook || typeof runbook !== 'object' || Array.isArray(runbook)) {\n      throw new Error('runbook must be an object');\n    }\n    if (!Array.isArray(runbook.steps) || runbook.steps.length === 0) {\n      throw new Error('runbook.steps must be a non-empty array');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 80,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 82,
        "end_line": 108,
        "content": "async setRunbook(name, runbook) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('runbook name must be a non-empty string');\n    }\n    this.validateRunbook(runbook);\n\n    const trimmed = name.trim();\n    const existing = this.runbooks.get(trimmed);\n    const payload = {\n      ...runbook,\n      updated_at: new Date().toISOString(),\n      created_at: existing?.created_at || new Date().toISOString(),\n    };\n\n    this.runbooks.set(trimmed, payload);\n    this.sources.set(trimmed, 'local');\n    await this.persist();\n\n    if (existing) {\n      this.stats.updated += 1;\n    } else {\n      this.stats.created += 1;\n    }\n\n    return { success: true, runbook: { name: trimmed, ...payload } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 193,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 110,
        "end_line": 121,
        "content": "async getRunbook(name) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('runbook name must be a non-empty string');\n    }\n    const trimmed = name.trim();\n    const entry = this.runbooks.get(trimmed);\n    if (!entry) {\n      throw new Error(`runbook '${trimmed}' not found`);\n    }\n    return { success: true, runbook: { name: trimmed, ...entry, source: this.sources.get(trimmed) || 'local' } };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 120,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 123,
        "end_line": 140,
        "content": "async listRunbooks() {\n    await this.ensureReady();\n    const items = [];\n    for (const [name, runbook] of this.runbooks.entries()) {\n      items.push({\n        name,\n        description: runbook.description,\n        tags: runbook.tags || [],\n        when: runbook.when,\n        inputs: runbook.inputs,\n        steps: Array.isArray(runbook.steps) ? runbook.steps.length : 0,\n        created_at: runbook.created_at,\n        updated_at: runbook.updated_at,\n        source: this.sources.get(name) || 'local',\n      });\n    }\n    return { success: true, runbooks: items };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 146,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 142,
        "end_line": 153,
        "content": "async deleteRunbook(name) {\n    await this.ensureReady();\n    if (typeof name !== 'string' || name.trim().length === 0) {\n      throw new Error('runbook name must be a non-empty string');\n    }\n    const trimmed = name.trim();\n    if (!this.runbooks.delete(trimmed)) {\n      throw new Error(`runbook '${trimmed}' not found`);\n    }\n    await this.persist();\n    return { success: true, runbook: trimmed };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 105,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 155,
        "end_line": 157,
        "content": "getStats() {\n    return { ...this.stats, total: this.runbooks.size };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 21,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/RunbookService.ts",
        "start_line": 159,
        "end_line": 161,
        "content": "async cleanup() {\n    this.runbooks.clear();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "RunbookService",
          "estimated_tokens": 15,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/SecretRefResolver.ts": [
      {
        "file_path": "src/services/SecretRefResolver.ts",
        "start_line": 11,
        "end_line": 17,
        "content": "constructor(logger, validation, profileService, vaultClient, projectResolver) {\n    this.logger = logger.child('secrets');\n    this.validation = validation;\n    this.profileService = profileService;\n    this.vaultClient = vaultClient;\n    this.projectResolver = projectResolver;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SecretRefResolver",
          "estimated_tokens": 74,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/SecretRefResolver.ts",
        "start_line": 19,
        "end_line": 47,
        "content": "async resolveVaultProfileName(args = {}) {\n    if (args.vault_profile_name) {\n      return this.validation.ensureString(String(args.vault_profile_name), 'vault_profile_name');\n    }\n    if (args.vault_profile) {\n      return this.validation.ensureString(String(args.vault_profile), 'vault_profile');\n    }\n\n    if (this.projectResolver) {\n      const context = await this.projectResolver.resolveContext(args).catch(() => null);\n      const vaultProfile = context?.target?.vault_profile;\n      if (vaultProfile) {\n        return this.validation.ensureString(String(vaultProfile), 'vault_profile');\n      }\n    }\n\n    if (!this.profileService) {\n      throw new Error('vault profile is required (profileService missing)');\n    }\n\n    const profiles = await this.profileService.listProfiles('vault');\n    if (profiles.length === 1) {\n      return profiles[0].name;\n    }\n    if (profiles.length === 0) {\n      throw new Error('vault profile is required (no vault profiles exist)');\n    }\n    throw new Error('vault profile is required when multiple vault profiles exist');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SecretRefResolver",
          "estimated_tokens": 272,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/SecretRefResolver.ts",
        "start_line": 49,
        "end_line": 82,
        "content": "async resolveRefString(value, args = {}, cache) {\n    if (cache?.has(value)) {\n      return cache.get(value);\n    }\n\n    const spec = value.slice(4);\n    if (spec.startsWith('vault:kv2:')) {\n      if (!this.vaultClient) {\n        throw new Error('vault refs require VaultClient (server misconfiguration)');\n      }\n      const ref = spec.slice('vault:kv2:'.length);\n      const profileName = await this.resolveVaultProfileName(args);\n      const resolved = await this.vaultClient.kv2Get(profileName, ref, { timeout_ms: args.timeout_ms });\n      cache?.set(value, resolved);\n      return resolved;\n    }\n\n    if (spec.startsWith('env:')) {\n      const envKey = spec.slice('env:'.length).trim();\n      if (!envKey) {\n        throw new Error('ref:env requires a non-empty env var name');\n      }\n      const fromEnv = process.env[envKey];\n      if (fromEnv === undefined) {\n        throw new Error(`ref:env var is not set: ${envKey}`);\n      }\n      const resolved = String(fromEnv);\n      cache?.set(value, resolved);\n      return resolved;\n    }\n\n    const scheme = spec.split(':')[0] || 'unknown';\n    throw new Error(`Unknown secret ref scheme: ${scheme}`);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SecretRefResolver",
          "estimated_tokens": 294,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/SecretRefResolver.ts",
        "start_line": 84,
        "end_line": 123,
        "content": "async resolveDeep(input, args = {}) {\n    const cache = new Map();\n\n    const walk = async (value) => {\n      if (value === null || value === undefined) {\n        return value;\n      }\n\n      if (typeof value === 'string') {\n        if (!value.startsWith('ref:')) {\n          return value;\n        }\n        return this.resolveRefString(value, args, cache);\n      }\n\n      if (typeof value !== 'object') {\n        return value;\n      }\n\n      if (Buffer.isBuffer(value)) {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        const out = [];\n        for (const item of value) {\n          out.push(await walk(item));\n        }\n        return out;\n      }\n\n      const out = {};\n      for (const [key, child] of Object.entries(value)) {\n        out[key] = await walk(child);\n      }\n      return out;\n    };\n\n    return walk(input);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "SecretRefResolver",
          "estimated_tokens": 217,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/Security.ts": [
      {
        "file_path": "src/services/Security.ts",
        "start_line": 17,
        "end_line": 41,
        "content": "function decodeKey(raw) {\n  if (!raw) {\n    return null;\n  }\n\n  const trimmed = raw.trim();\n\n  if (trimmed.length === KEY_BYTES * 2) {\n    return Buffer.from(trimmed, 'hex');\n  }\n\n  if (trimmed.length === KEY_BYTES) {\n    return Buffer.from(trimmed, 'utf8');\n  }\n\n  if (trimmed.length > KEY_BYTES * 2) {\n    try {\n      return Buffer.from(trimmed, 'base64');\n    } catch (error) {\n      return null;\n    }\n  }\n\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "decodeKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 106,
          "qualified_name": "decodeKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 44,
        "end_line": 49,
        "content": "constructor(logger) {\n    this.logger = logger.child('security');\n    this.algorithm = Constants.CRYPTO.ALGORITHM;\n    this.keyPath = resolveProfileKeyPath();\n    this.secretKey = this.loadOrCreateSecret();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 51,
        "end_line": 69,
        "content": "ensureSizeFits(payload, options = {}) {\n    const maxBytesEnv = process.env.SENTRYFROGG_MAX_PAYLOAD_BYTES || process.env.SF_MAX_PAYLOAD_BYTES;\n    const maxBytes = Number.isFinite(options.maxBytes)\n      ? options.maxBytes\n      : (maxBytesEnv ? Number(maxBytesEnv) : Constants.BUFFERS.MAX_LOG_SIZE);\n\n    const text = typeof payload === 'string' ? payload : String(payload ?? '');\n    const bytes = Buffer.byteLength(text, 'utf8');\n\n    if (!Number.isFinite(maxBytes) || maxBytes <= 0) {\n      return { ok: true, bytes };\n    }\n\n    if (bytes > maxBytes) {\n      throw new Error(`Payload exceeds size limit (${bytes} bytes > ${maxBytes} bytes)`);\n    }\n\n    return { ok: true, bytes, maxBytes };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 177,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 71,
        "end_line": 99,
        "content": "loadOrCreateSecret() {\n    const fromEnv = decodeKey(process.env.ENCRYPTION_KEY);\n    if (fromEnv) {\n      this.logger.info('Using encryption key from ENCRYPTION_KEY environment variable');\n      return fromEnv;\n    }\n\n    try {\n      if (fs.existsSync(this.keyPath)) {\n        const stored = fs.readFileSync(this.keyPath, 'utf8');\n        const decoded = decodeKey(stored);\n        if (decoded) {\n          return decoded;\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Failed to read persisted encryption key, generating new one', { error: error.message });\n    }\n\n    const generated = crypto.randomBytes(KEY_BYTES);\n    try {\n      fs.writeFileSync(this.keyPath, generated.toString('hex'), { encoding: 'utf8', mode: 0o600 });\n      this.logger.info('Generated persistent encryption key', { key_path: this.keyPath });\n    } catch (error) {\n      this.logger.warn('Unable to persist encryption key, profiles will need ENCRYPTION_KEY to be set', { error: error.message });\n    }\n\n    return generated;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 257,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 101,
        "end_line": 111,
        "content": "async encrypt(text) {\n    if (typeof text !== 'string') {\n      text = String(text ?? '');\n    }\n\n    const iv = crypto.randomBytes(IV_BYTES);\n    const cipher = crypto.createCipheriv(this.algorithm, this.secretKey, iv);\n    const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);\n    const tag = cipher.getAuthTag();\n    return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted.toString('hex')}`;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 110,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 113,
        "end_line": 137,
        "content": "async decrypt(payload) {\n    if (!payload || typeof payload !== 'string') {\n      throw new Error('Encrypted payload must be a string');\n    }\n\n    const [ivHex, tagHex, dataHex] = payload.split(':');\n    if (!ivHex || !tagHex || !dataHex) {\n      throw new Error('Invalid encrypted payload format');\n    }\n\n    try {\n      const iv = Buffer.from(ivHex, 'hex');\n      const tag = Buffer.from(tagHex, 'hex');\n      const encrypted = Buffer.from(dataHex, 'hex');\n      if (tag.length !== TAG_BYTES) {\n        throw new Error('Invalid auth tag length');\n      }\n      const decipher = crypto.createDecipheriv(this.algorithm, this.secretKey, iv);\n      decipher.setAuthTag(tag);\n      const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);\n      return decrypted.toString('utf8');\n    } catch (error) {\n      throw new Error('Failed to decrypt secret payload');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 225,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 139,
        "end_line": 154,
        "content": "cleanCommand(command) {\n    if (typeof command !== 'string') {\n      throw new Error('Command must be a string');\n    }\n\n    const trimmed = command.trim();\n    if (!trimmed) {\n      throw new Error('Command must not be empty');\n    }\n\n    if (trimmed.includes('\\0')) {\n      throw new Error('Command contains null bytes');\n    }\n\n    return trimmed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 90,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Security.ts",
        "start_line": 156,
        "end_line": 166,
        "content": "ensureUrl(url) {\n    if (typeof url !== 'string') {\n      throw new Error('URL must be a string');\n    }\n\n    try {\n      return new URL(url);\n    } catch (error) {\n      throw new Error('Invalid URL');\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Security",
          "estimated_tokens": 55,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/StateService.ts": [
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 13,
        "end_line": 26,
        "content": "constructor(logger) {\n    this.logger = logger.child('state');\n    this.filePath = resolveStatePath();\n    this.persistent = {};\n    this.session = {};\n    this.stats = {\n      loaded: 0,\n      saved: 0,\n      set: 0,\n      unset: 0,\n      cleared: 0,\n    };\n    this.initPromise = this.load();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 77,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 28,
        "end_line": 30,
        "content": "async initialize() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 32,
        "end_line": 45,
        "content": "async load() {\n    try {\n      const raw = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        this.persistent = parsed;\n      }\n      this.stats.loaded = Object.keys(this.persistent).length;\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load state file', { error: error.message });\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 118,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 47,
        "end_line": 50,
        "content": "async persist() {\n    await atomicWriteTextFile(this.filePath, `${JSON.stringify(this.persistent, null, 2)}\\n`, { mode: 0o600 });\n    this.stats.saved += 1;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 43,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 52,
        "end_line": 54,
        "content": "async ensureReady() {\n    await this.initPromise;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 16,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 56,
        "end_line": 62,
        "content": "normalizeScope(scope) {\n    const normalized = String(scope || 'persistent').toLowerCase();\n    if (normalized === 'session' || normalized === 'persistent' || normalized === 'any') {\n      return normalized;\n    }\n    throw new Error('scope must be one of: session, persistent, any');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 75,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 64,
        "end_line": 78,
        "content": "async set(key, value, scope) {\n    await this.ensureReady();\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      throw new Error('State key must be a non-empty string');\n    }\n    const normalized = this.normalizeScope(scope);\n    if (normalized === 'session') {\n      this.session[key.trim()] = value;\n    } else {\n      this.persistent[key.trim()] = value;\n      await this.persist();\n    }\n    this.stats.set += 1;\n    return { success: true, key: key.trim(), scope: normalized === 'any' ? 'persistent' : normalized };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 138,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 80,
        "end_line": 107,
        "content": "async get(key, scope) {\n    await this.ensureReady();\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      throw new Error('State key must be a non-empty string');\n    }\n    const normalized = this.normalizeScope(scope || 'any');\n    const trimmed = key.trim();\n\n    let value;\n    let resolvedScope;\n    if (normalized === 'session') {\n      value = this.session[trimmed];\n      resolvedScope = 'session';\n    } else if (normalized === 'persistent') {\n      value = this.persistent[trimmed];\n      resolvedScope = 'persistent';\n    } else {\n      if (Object.prototype.hasOwnProperty.call(this.session, trimmed)) {\n        value = this.session[trimmed];\n        resolvedScope = 'session';\n      } else {\n        value = this.persistent[trimmed];\n        resolvedScope = 'persistent';\n      }\n    }\n\n    return { success: true, key: trimmed, value, scope: resolvedScope };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 225,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 109,
        "end_line": 134,
        "content": "async list({ prefix, scope, includeValues } = {}) {\n    await this.ensureReady();\n    const normalized = this.normalizeScope(scope || 'any');\n    const matchesPrefix = (key) => (prefix ? key.startsWith(prefix) : true);\n\n    const gather = (source) => Object.entries(source)\n      .filter(([key]) => matchesPrefix(key))\n      .map(([key, value]) => (includeValues ? { key, value } : { key }));\n\n    if (normalized === 'session') {\n      return { success: true, scope: 'session', items: gather(this.session) };\n    }\n\n    if (normalized === 'persistent') {\n      return { success: true, scope: 'persistent', items: gather(this.persistent) };\n    }\n\n    return {\n      success: true,\n      scope: 'any',\n      items: [\n        ...gather(this.persistent),\n        ...gather(this.session).filter((item) => !Object.prototype.hasOwnProperty.call(this.persistent, item.key)),\n      ],\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 224,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 136,
        "end_line": 155,
        "content": "async unset(key, scope) {\n    await this.ensureReady();\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      throw new Error('State key must be a non-empty string');\n    }\n    const normalized = this.normalizeScope(scope || 'any');\n    const trimmed = key.trim();\n\n    if (normalized === 'session' || normalized === 'any') {\n      delete this.session[trimmed];\n    }\n\n    if (normalized === 'persistent' || normalized === 'any') {\n      delete this.persistent[trimmed];\n      await this.persist();\n    }\n\n    this.stats.unset += 1;\n    return { success: true, key: trimmed, scope: normalized };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 156,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 157,
        "end_line": 172,
        "content": "async clear(scope) {\n    await this.ensureReady();\n    const normalized = this.normalizeScope(scope || 'any');\n\n    if (normalized === 'session' || normalized === 'any') {\n      this.session = {};\n    }\n\n    if (normalized === 'persistent' || normalized === 'any') {\n      this.persistent = {};\n      await this.persist();\n    }\n\n    this.stats.cleared += 1;\n    return { success: true, scope: normalized };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 105,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 174,
        "end_line": 192,
        "content": "async dump(scope) {\n    await this.ensureReady();\n    const normalized = this.normalizeScope(scope || 'any');\n\n    if (normalized === 'session') {\n      return { success: true, scope: 'session', state: { ...this.session } };\n    }\n    if (normalized === 'persistent') {\n      return { success: true, scope: 'persistent', state: { ...this.persistent } };\n    }\n\n    return {\n      success: true,\n      scope: 'any',\n      state: { ...this.persistent, ...this.session },\n      persistent: { ...this.persistent },\n      session: { ...this.session },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 142,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 194,
        "end_line": 200,
        "content": "getStats() {\n    return {\n      ...this.stats,\n      session_keys: Object.keys(this.session).length,\n      persistent_keys: Object.keys(this.persistent).length,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 45,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/StateService.ts",
        "start_line": 202,
        "end_line": 204,
        "content": "async cleanup() {\n    this.session = {};\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "StateService",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/ToolExecutor.ts": [
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 24,
        "end_line": 33,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numberValue = Number(value);\n  if (!Number.isFinite(numberValue) || numberValue <= 0) {\n    return null;\n  }\n  return Math.floor(numberValue);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 67,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 35,
        "end_line": 38,
        "content": "function resolveMaxInlineBytes() {\n  const raw = process.env.SENTRYFROGG_MAX_INLINE_BYTES || process.env.SF_MAX_INLINE_BYTES;\n  return readPositiveInt(raw) ?? DEFAULT_MAX_INLINE_BYTES;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveMaxInlineBytes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 46,
          "qualified_name": "resolveMaxInlineBytes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 40,
        "end_line": 43,
        "content": "function resolveMaxCaptureBytes() {\n  const raw = process.env.SENTRYFROGG_MAX_CAPTURE_BYTES || process.env.SF_MAX_CAPTURE_BYTES;\n  return readPositiveInt(raw) ?? DEFAULT_MAX_CAPTURE_BYTES;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveMaxCaptureBytes",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 47,
          "qualified_name": "resolveMaxCaptureBytes",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 45,
        "end_line": 52,
        "content": "function safeFilenameSegment(value) {\n  const base = String(value || '').trim() || 'value';\n  return base\n    .replace(/[^a-zA-Z0-9._-]+/g, '_')\n    .replace(/^_+/, '')\n    .replace(/_+$/, '')\n    .slice(0, 64) || 'value';\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "safeFilenameSegment",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 56,
          "qualified_name": "safeFilenameSegment",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 54,
        "end_line": 70,
        "content": "function resolveSpillFilename(segments, { ext, used }) {\n  const normalized = segments\n    .filter((item) => item !== undefined && item !== null && String(item).trim().length)\n    .slice(-6)\n    .map((item) => safeFilenameSegment(item));\n\n  const base = normalized.length ? normalized.join('__') : 'value';\n  const safeBase = base.slice(0, 120);\n  const candidateBase = `${safeBase}.${ext}`;\n  const current = used.get(candidateBase) || 0;\n  used.set(candidateBase, current + 1);\n  if (current === 0) {\n    return candidateBase;\n  }\n  const parsed = path.parse(candidateBase);\n  return `${parsed.name}--${current + 1}${parsed.ext}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveSpillFilename",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 158,
          "qualified_name": "resolveSpillFilename",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 72,
        "end_line": 96,
        "content": "function truncateUtf8Prefix(value, maxBytes) {\n  if (typeof value !== 'string') {\n    return '';\n  }\n  if (!Number.isFinite(maxBytes) || maxBytes <= 0) {\n    return '';\n  }\n  if (Buffer.byteLength(value, 'utf8') <= maxBytes) {\n    return value;\n  }\n\n  let low = 0;\n  let high = value.length;\n  while (low < high) {\n    const mid = Math.ceil((low + high) / 2);\n    const slice = value.slice(0, mid);\n    const bytes = Buffer.byteLength(slice, 'utf8');\n    if (bytes <= maxBytes) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return value.slice(0, low);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "truncateUtf8Prefix",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 143,
          "qualified_name": "truncateUtf8Prefix",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 98,
        "end_line": 100,
        "content": "function computeSha256Text(value) {\n  return crypto.createHash('sha256').update(value, 'utf8').digest('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "computeSha256Text",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 27,
          "qualified_name": "computeSha256Text",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 102,
        "end_line": 104,
        "content": "function computeSha256Buffer(buffer) {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "computeSha256Buffer",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 26,
          "qualified_name": "computeSha256Buffer",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 106,
        "end_line": 121,
        "content": "function buildPreviewTailText(value, maxChars) {\n  if (typeof value !== 'string') {\n    return { preview: '', tail: '' };\n  }\n  const limit = Number.isFinite(maxChars) ? Math.max(0, Math.floor(maxChars)) : 0;\n  if (limit <= 0) {\n    return { preview: '', tail: '' };\n  }\n  if (value.length <= limit * 2) {\n    return { preview: value, tail: '' };\n  }\n  return {\n    preview: value.slice(0, limit),\n    tail: value.slice(-limit),\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildPreviewTailText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 108,
          "qualified_name": "buildPreviewTailText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 123,
        "end_line": 253,
        "content": "async function spillLargeValues(value, options, pathSegments = [], state = null) {\n  const ctx = options || {};\n  const runState = state || {\n    usedNames: new Map(),\n    spilled: 0,\n  };\n\n  const maxInlineBytes = ctx.maxInlineBytes;\n  const maxCaptureBytes = ctx.maxCaptureBytes;\n  const maxSpills = ctx.maxSpills;\n  const contextRoot = ctx.contextRoot;\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = Buffer.byteLength(value, 'utf8');\n    if (bytes <= maxInlineBytes) {\n      return value;\n    }\n\n    const hasSensitiveKey = pathSegments.some((segment) => isSensitiveKey(segment));\n    const previewLimit = Math.min(2048, Math.max(128, Math.floor(maxInlineBytes / 4)));\n    const { preview, tail } = buildPreviewTailText(value, previewLimit);\n\n    const capped = truncateUtf8Prefix(value, maxCaptureBytes);\n    const capturedBytes = Buffer.byteLength(capped, 'utf8');\n    const sha256 = computeSha256Text(capped);\n    const captureTruncated = capturedBytes < bytes;\n\n    let artifact = null;\n    if (!hasSensitiveKey && contextRoot && runState.spilled < maxSpills) {\n      const filename = resolveSpillFilename(pathSegments, { ext: 'txt', used: runState.usedNames });\n      const ref = buildToolCallFileRef({ traceId: ctx.traceId, spanId: ctx.spanId, filename });\n      const written = await writeTextArtifact(contextRoot, ref, capped);\n      runState.spilled += 1;\n      artifact = { uri: written.uri, rel: written.rel, bytes: written.bytes, truncated: captureTruncated };\n    }\n\n    return {\n      truncated: true,\n      bytes,\n      sha256,\n      artifact,\n      preview,\n      tail,\n    };\n  }\n\n  if (Buffer.isBuffer(value)) {\n    const bytes = value.length;\n    if (bytes <= maxInlineBytes) {\n      return value;\n    }\n\n    const hasSensitiveKey = pathSegments.some((segment) => isSensitiveKey(segment));\n    const captured = bytes > maxCaptureBytes ? value.subarray(0, maxCaptureBytes) : value;\n    const sha256 = computeSha256Buffer(captured);\n    const captureTruncated = captured.length < bytes;\n    const previewLimit = Math.min(256, captured.length);\n    const preview = captured.subarray(0, previewLimit).toString('base64');\n    const tail = previewLimit < captured.length\n      ? captured.subarray(captured.length - previewLimit).toString('base64')\n      : '';\n\n    let artifact = null;\n    if (!hasSensitiveKey && contextRoot && runState.spilled < maxSpills) {\n      const filename = resolveSpillFilename(pathSegments, { ext: 'bin', used: runState.usedNames });\n      const ref = buildToolCallFileRef({ traceId: ctx.traceId, spanId: ctx.spanId, filename });\n      const written = await writeBinaryArtifact(contextRoot, ref, captured);\n      runState.spilled += 1;\n      artifact = { uri: written.uri, rel: written.rel, bytes: written.bytes, truncated: captureTruncated };\n    }\n\n    return {\n      truncated: true,\n      bytes,\n      sha256,\n      artifact,\n      preview,\n      tail,\n    };\n  }\n\n  if (typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    const next = await Promise.all(\n      value.map((item, idx) => spillLargeValues(item, ctx, pathSegments.concat(String(idx)), runState))\n    );\n    return next;\n  }\n\n  const out = {};\n  const entries = Object.entries(value);\n\n  for (const [key, raw] of entries) {\n    if (key.endsWith('_buffer') && Buffer.isBuffer(raw)) {\n      const refKey = key.replace(/_buffer$/, '_ref');\n      const existingRef = value[refKey];\n      if (existingRef && typeof existingRef === 'object' && typeof existingRef.uri === 'string') {\n        const bytes = raw.length;\n        const captured = bytes > maxCaptureBytes ? raw.subarray(0, maxCaptureBytes) : raw;\n        const sha256 = computeSha256Buffer(captured);\n        const captureTruncated = captured.length < bytes;\n        const previewLimit = Math.min(256, captured.length);\n        const preview = captured.subarray(0, previewLimit).toString('base64');\n        const tail = previewLimit < captured.length\n          ? captured.subarray(captured.length - previewLimit).toString('base64')\n          : '';\n\n        out[key] = {\n          truncated: true,\n          bytes,\n          sha256,\n          artifact: { uri: existingRef.uri, rel: existingRef.rel, bytes: existingRef.bytes, truncated: existingRef.truncated ?? captureTruncated },\n          preview,\n          tail,\n        };\n        continue;\n      }\n    }\n\n    out[key] = await spillLargeValues(raw, ctx, pathSegments.concat(key), runState);\n  }\n\n  return out;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "spillLargeValues",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1135,
          "qualified_name": "spillLargeValues",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 256,
        "end_line": 264,
        "content": "constructor(logger, stateService, aliasService, presetService, auditService, handlers = {}, options = {}) {\n    this.logger = logger.child('executor');\n    this.stateService = stateService;\n    this.aliasService = aliasService;\n    this.presetService = presetService;\n    this.auditService = auditService;\n    this.handlers = handlers;\n    this.aliasMap = options.aliasMap || {};\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 98,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 266,
        "end_line": 268,
        "content": "register(tool, handler) {\n    this.handlers[tool] = handler;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 19,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 270,
        "end_line": 281,
        "content": "normalizeStoreTarget(storeAs, storeScope) {\n    if (!storeAs) {\n      return null;\n    }\n    if (typeof storeAs === 'string') {\n      return { key: storeAs, scope: storeScope || 'session' };\n    }\n    if (typeof storeAs === 'object' && storeAs.key) {\n      return { key: storeAs.key, scope: storeAs.scope ?? storeScope ?? 'session' };\n    }\n    return null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 93,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 283,
        "end_line": 303,
        "content": "async resolveAlias(tool) {\n    if (this.handlers[tool]) {\n      return { tool, alias: null };\n    }\n\n    if (this.aliasMap[tool]) {\n      return { tool: this.aliasMap[tool], alias: { name: tool, tool: this.aliasMap[tool] } };\n    }\n\n    if (this.aliasService) {\n      const entry = await this.aliasService.resolveAlias(tool);\n      if (entry) {\n        const mappedTool = this.handlers[entry.tool]\n          ? entry.tool\n          : (this.aliasMap[entry.tool] || entry.tool);\n        return { tool: mappedTool, alias: { name: tool, ...entry, tool: mappedTool } };\n      }\n    }\n\n    return { tool, alias: null };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 157,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 305,
        "end_line": 316,
        "content": "normalizePresetData(preset) {\n    if (!preset || typeof preset !== 'object') {\n      return null;\n    }\n\n    if (preset.data && typeof preset.data === 'object' && !Array.isArray(preset.data)) {\n      return preset.data;\n    }\n\n    const { created_at, updated_at, description, ...rest } = preset;\n    return rest;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 82,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 318,
        "end_line": 328,
        "content": "normalizeAliasArgs(alias) {\n    if (!alias || typeof alias !== 'object') {\n      return null;\n    }\n\n    if (alias.args && typeof alias.args === 'object' && !Array.isArray(alias.args)) {\n      return alias.args;\n    }\n\n    return null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 62,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 330,
        "end_line": 339,
        "content": "mergeArgs(preset, aliasArgs, args) {\n    let merged = preset ? mergeDeep({}, preset) : {};\n    if (aliasArgs) {\n      merged = mergeDeep(merged, aliasArgs);\n    }\n    if (args && typeof args === 'object') {\n      merged = mergeDeep(merged, args);\n    }\n    return merged;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 71,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 341,
        "end_line": 349,
        "content": "stripArgsForHandler(args) {\n    const cleaned = { ...args };\n    delete cleaned.output;\n    delete cleaned.store_as;\n    delete cleaned.store_scope;\n    delete cleaned.preset;\n    delete cleaned.preset_name;\n    return cleaned;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 60,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 351,
        "end_line": 379,
        "content": "buildAuditArgs(args) {\n    const cleaned = this.stripArgsForHandler(args);\n    if (cleaned.body_base64) {\n      cleaned.body_base64 = `[base64:${String(cleaned.body_base64).length}]`;\n    }\n    if (cleaned.content_base64) {\n      cleaned.content_base64 = `[base64:${String(cleaned.content_base64).length}]`;\n    }\n    if (Object.prototype.hasOwnProperty.call(cleaned, 'stdin')) {\n      cleaned.stdin = cleaned.stdin === undefined || cleaned.stdin === null\n        ? cleaned.stdin\n        : `[stdin:${String(cleaned.stdin).length}]`;\n    }\n    if (Object.prototype.hasOwnProperty.call(cleaned, 'patch')) {\n      cleaned.patch = cleaned.patch === undefined || cleaned.patch === null\n        ? cleaned.patch\n        : `[patch:${String(cleaned.patch).length}]`;\n    }\n    if (Object.prototype.hasOwnProperty.call(cleaned, 'content')) {\n      if (typeof cleaned.content === 'string') {\n        cleaned.content = `[content:${cleaned.content.length}]`;\n      } else if (Buffer.isBuffer(cleaned.content)) {\n        cleaned.content = `[buffer:${cleaned.content.length}]`;\n      } else if (cleaned.content !== null && cleaned.content !== undefined) {\n        cleaned.content = `[content:${typeof cleaned.content}]`;\n      }\n    }\n    return redactObject(cleaned);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 317,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 381,
        "end_line": 399,
        "content": "summarizeResult(result) {\n    if (result === null || result === undefined) {\n      return { type: String(result) };\n    }\n    if (typeof result === 'string') {\n      return { type: 'string', length: result.length, preview: result.slice(0, 200) };\n    }\n    if (Buffer.isBuffer(result)) {\n      return { type: 'buffer', length: result.length };\n    }\n    if (Array.isArray(result)) {\n      return { type: 'array', length: result.length };\n    }\n    if (typeof result === 'object') {\n      const keys = Object.keys(result);\n      return { type: 'object', keys: keys.slice(0, 10), key_count: keys.length };\n    }\n    return { type: typeof result, value: result };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 169,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 401,
        "end_line": 403,
        "content": "compactMeta(meta) {\n    return Object.fromEntries(Object.entries(meta).filter(([, value]) => value !== undefined));\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 405,
        "end_line": 442,
        "content": "async wrapResult({ tool, args, result, startedAt, traceId, spanId, parentSpanId, invokedAs, presetName }) {\n    const output = args.output;\n    const store = this.normalizeStoreTarget(args.store_as, args.store_scope);\n\n    const shaped = applyOutputTransform(result, output);\n    const contextRoot = resolveContextRepoRoot();\n    const maxInlineBytes = resolveMaxInlineBytes();\n    const maxCaptureBytes = resolveMaxCaptureBytes();\n    const maxSpills = readPositiveInt(process.env.SENTRYFROGG_MAX_SPILLS || process.env.SF_MAX_SPILLS) ?? DEFAULT_MAX_SPILLS;\n    const spilled = await spillLargeValues(shaped, {\n      contextRoot,\n      traceId,\n      spanId,\n      maxInlineBytes,\n      maxCaptureBytes,\n      maxSpills,\n    });\n\n    if (store?.key) {\n      await this.stateService.set(store.key, spilled, store.scope);\n    }\n\n    return {\n      ok: true,\n      result: spilled,\n      meta: this.compactMeta({\n        tool,\n        action: args.action,\n        trace_id: traceId,\n        span_id: spanId,\n        parent_span_id: parentSpanId,\n        duration_ms: Date.now() - startedAt,\n        stored_as: store?.key,\n        invoked_as: invokedAs,\n        preset: presetName,\n      }),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 302,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/ToolExecutor.ts",
        "start_line": 444,
        "end_line": 528,
        "content": "async execute(tool, args = {}) {\n    const startedAt = Date.now();\n    const resolved = await this.resolveAlias(tool);\n    const handler = this.handlers[resolved.tool];\n    if (!handler) {\n      throw new Error(`Unknown tool: ${tool}`);\n    }\n\n    const traceId = args.trace_id || crypto.randomUUID();\n    const parentSpanId = args.parent_span_id;\n    const spanId = args.span_id || crypto.randomUUID();\n\n    let presetName = args.preset || args.preset_name;\n    if (!presetName && resolved.alias?.preset) {\n      presetName = resolved.alias.preset;\n    }\n\n    let presetData = null;\n    if (presetName && this.presetService) {\n      presetData = this.normalizePresetData(\n        await this.presetService.resolvePreset(resolved.tool, presetName)\n      );\n    }\n\n    const mergedArgs = this.mergeArgs(presetData, this.normalizeAliasArgs(resolved.alias), args);\n    mergedArgs.trace_id = traceId;\n    mergedArgs.span_id = spanId;\n    if (parentSpanId) {\n      mergedArgs.parent_span_id = parentSpanId;\n    }\n\n    const cleanedArgs = this.stripArgsForHandler(mergedArgs);\n    const invokedAs = resolved.alias ? tool : undefined;\n\n    try {\n      const result = await handler(cleanedArgs);\n      const payload = await this.wrapResult({\n        tool: resolved.tool,\n        args: mergedArgs,\n        result,\n        startedAt,\n        traceId,\n        spanId,\n        parentSpanId,\n        invokedAs,\n        presetName,\n      });\n\n      if (this.auditService) {\n        await this.auditService.append({\n          timestamp: new Date().toISOString(),\n          status: 'ok',\n          tool: resolved.tool,\n          action: mergedArgs.action,\n          trace_id: traceId,\n          span_id: spanId,\n          parent_span_id: parentSpanId,\n          invoked_as: invokedAs,\n          input: this.buildAuditArgs(mergedArgs),\n          result_summary: this.summarizeResult(payload.result),\n          duration_ms: Date.now() - startedAt,\n        });\n      }\n\n      return payload;\n    } catch (error) {\n      if (this.auditService) {\n        await this.auditService.append({\n          timestamp: new Date().toISOString(),\n          status: 'error',\n          tool: resolved.tool,\n          action: mergedArgs.action,\n          trace_id: traceId,\n          span_id: spanId,\n          parent_span_id: parentSpanId,\n          invoked_as: invokedAs,\n          input: this.buildAuditArgs(mergedArgs),\n          error: error.message,\n          duration_ms: Date.now() - startedAt,\n        });\n      }\n\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "ToolExecutor",
          "estimated_tokens": 631,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/Validation.ts": [
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 11,
        "end_line": 13,
        "content": "constructor(logger) {\n    this.logger = logger.child('validation');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 19,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 15,
        "end_line": 26,
        "content": "ensureString(value, label, { trim = true } = {}) {\n    if (typeof value !== 'string') {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n\n    const normalized = value.trim();\n    if (normalized.length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n\n    return trim ? normalized : value;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 86,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 28,
        "end_line": 33,
        "content": "ensureOptionalString(value, label, options) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureString(value, label, options);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 47,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 35,
        "end_line": 45,
        "content": "ensurePort(port, fallback) {\n    if (port === undefined || port === null || port === '') {\n      return fallback;\n    }\n\n    const numeric = Number(port);\n    if (!Number.isInteger(numeric) || numeric < Constants.LIMITS.MIN_PORT || numeric > Constants.LIMITS.MAX_PORT) {\n      throw new Error(`Port must be an integer between ${Constants.LIMITS.MIN_PORT} and ${Constants.LIMITS.MAX_PORT}`);\n    }\n    return numeric;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 107,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 47,
        "end_line": 53,
        "content": "ensureIdentifier(name, label) {\n    const trimmed = this.ensureString(name, label);\n    if (trimmed.includes('\\0')) {\n      throw new Error(`${label} must not contain null bytes`);\n    }\n    return trimmed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 54,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 55,
        "end_line": 57,
        "content": "ensureTableName(name) {\n    return this.ensureIdentifier(name, 'Table name');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 22,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 59,
        "end_line": 61,
        "content": "ensureSchemaName(name) {\n    return this.ensureIdentifier(name, 'Schema name');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 22,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 63,
        "end_line": 71,
        "content": "ensureDataObject(data) {\n    if (typeof data !== 'object' || data === null || Array.isArray(data)) {\n      throw new Error('Data must be an object');\n    }\n    if (Object.keys(data).length === 0) {\n      throw new Error('Data object must not be empty');\n    }\n    return data;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 72,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 73,
        "end_line": 75,
        "content": "ensureSql(sql) {\n    return this.ensureString(sql, 'SQL query');\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 19,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 77,
        "end_line": 96,
        "content": "ensureHeaders(headers) {\n    if (headers === undefined || headers === null) {\n      return {};\n    }\n\n    if (typeof headers !== 'object' || Array.isArray(headers)) {\n      throw new Error('Headers must be an object');\n    }\n\n    return Object.fromEntries(\n      Object.entries(headers)\n        .filter(([key]) => typeof key === 'string' && key.trim().length > 0)\n        .flatMap(([key, value]) => {\n          if (value === undefined || value === null) {\n            return [];\n          }\n          return [[key.trim(), String(value).trim()]];\n        })\n    );\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 143,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 98,
        "end_line": 103,
        "content": "ensureObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 49,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/Validation.ts",
        "start_line": 105,
        "end_line": 110,
        "content": "ensureOptionalObject(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureObject(value, label);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "Validation",
          "estimated_tokens": 42,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/VaultClient.ts": [
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 16,
        "end_line": 25,
        "content": "async function defaultFetch(...args) {\n  if (globalThis.fetch) {\n    return globalThis.fetch(...args);\n  }\n  if (!fetchPromise) {\n    fetchPromise = import('node-fetch').then((mod) => mod.default);\n  }\n  const fetch = await fetchPromise;\n  return fetch(...args);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "defaultFetch",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 66,
          "qualified_name": "defaultFetch",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 27,
        "end_line": 38,
        "content": "function normalizeBaseUrl(raw) {\n  const value = String(raw || '').trim();\n  if (!value) {\n    throw new Error('vault addr is required');\n  }\n  const url = new URL(value);\n  url.hash = '';\n  url.search = '';\n  // Keep path in case Vault is proxied under a prefix, but normalize trailing slash.\n  const normalized = `${url.origin}${url.pathname}`.replace(/\\/+$/, '');\n  return normalized;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeBaseUrl",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 97,
          "qualified_name": "normalizeBaseUrl",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 40,
        "end_line": 49,
        "content": "function buildHeaders({ token, namespace } = {}) {\n  const headers = { Accept: 'application/json' };\n  if (namespace) {\n    headers['X-Vault-Namespace'] = String(namespace);\n  }\n  if (token) {\n    headers['X-Vault-Token'] = String(token);\n  }\n  return headers;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildHeaders",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 65,
          "qualified_name": "buildHeaders",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 51,
        "end_line": 60,
        "content": "function parseVaultError(body) {\n  if (!body || typeof body !== 'object') {\n    return null;\n  }\n  const errors = body.errors;\n  if (Array.isArray(errors) && errors.length > 0) {\n    return errors.map((e) => String(e)).join('; ');\n  }\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseVaultError",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "parseVaultError",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 63,
        "end_line": 71,
        "content": "constructor(logger, validation, profileService, options = {}) {\n    this.logger = logger.child('vault');\n    this.validation = validation;\n    this.profileService = profileService;\n    this.fetch = options.fetch || defaultFetch;\n    this.defaultTimeoutMs = Number.isInteger(options.timeout_ms) ? options.timeout_ms : 15000;\n    this.defaultRetries = Number.isInteger(options.retries) ? options.retries : 1;\n    this.loginInFlight = new Map();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 113,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 73,
        "end_line": 87,
        "content": "async loadProfile(profileName) {\n    const name = this.validation.ensureString(profileName, 'profile_name');\n    const profile = await this.profileService.getProfile(name, 'vault');\n    const data = profile.data || {};\n    const secrets = profile.secrets || {};\n\n    const addr = normalizeBaseUrl(data.addr);\n    const namespace = data.namespace ? String(data.namespace).trim() : undefined;\n    const token = secrets.token ? String(secrets.token) : undefined;\n    const auth_type = data.auth_type ? String(data.auth_type).trim().toLowerCase() : undefined;\n    const role_id = secrets.role_id ? String(secrets.role_id) : undefined;\n    const secret_id = secrets.secret_id ? String(secrets.secret_id) : undefined;\n\n    return { profile_name: name, addr, namespace, token, auth_type, role_id, secret_id };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 203,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 89,
        "end_line": 135,
        "content": "async requestJson(url, { method = 'GET', headers, body, timeout_ms, retries } = {}) {\n    const timeoutMs = Number.isInteger(timeout_ms) ? timeout_ms : this.defaultTimeoutMs;\n    const maxRetries = Number.isInteger(retries) ? retries : this.defaultRetries;\n\n    let attempt = 0;\n    // Small retry loop for transient network hiccups; keeps enterprise UX smooth without hiding errors.\n    // Retries do not include 4xx statuses.\n    while (true) {\n      attempt += 1;\n      const controller = new AbortController();\n      const timer = setTimeout(() => controller.abort(), timeoutMs);\n\n      try {\n        const response = await this.fetch(url, {\n          method,\n          headers,\n          body,\n          signal: controller.signal,\n        });\n\n        const text = await response.text();\n        const parsed = text ? JSON.parse(text) : null;\n\n        if (!response.ok) {\n          const details = parseVaultError(parsed);\n          const message = details\n            ? `Vault request failed (${response.status}): ${details}`\n            : `Vault request failed (${response.status})`;\n          const error = new Error(message);\n          error.status = response.status;\n          throw error;\n        }\n\n        return parsed;\n      } catch (error) {\n        const isAbort = error && (error.name === 'AbortError' || error.code === 'ABORT_ERR');\n        const status = error?.status;\n        const retryable = isAbort || (status === undefined && attempt <= maxRetries);\n        if (!retryable) {\n          throw error;\n        }\n        await sleepTimeout(150);\n      } finally {\n        clearTimeout(timer);\n      }\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 410,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 137,
        "end_line": 146,
        "content": "async sysHealth(profileName, options = {}) {\n    const profile = await this.loadProfile(profileName);\n    const url = `${profile.addr}/v1/sys/health`;\n    return this.requestJson(url, {\n      method: 'GET',\n      headers: buildHeaders({ token: profile.token, namespace: profile.namespace }),\n      timeout_ms: options.timeout_ms,\n      retries: options.retries,\n    });\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 95,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 148,
        "end_line": 171,
        "content": "async tokenLookupSelf(profileName, options = {}) {\n    const profile = await this.loadProfile(profileName);\n    const token = await this.ensureToken(profile, { timeout_ms: options.timeout_ms, retries: options.retries });\n    const url = `${profile.addr}/v1/auth/token/lookup-self`;\n    try {\n      return await this.requestJson(url, {\n        method: 'GET',\n        headers: buildHeaders({ token, namespace: profile.namespace }),\n        timeout_ms: options.timeout_ms,\n        retries: options.retries,\n      });\n    } catch (error) {\n      if (error?.status === 403 && this.canApprole(profile)) {\n        const fresh = await this.loginApprole(profile, { timeout_ms: options.timeout_ms, retries: options.retries });\n        return this.requestJson(url, {\n          method: 'GET',\n          headers: buildHeaders({ token: fresh, namespace: profile.namespace }),\n          timeout_ms: options.timeout_ms,\n          retries: options.retries,\n        });\n      }\n      throw error;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 249,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 173,
        "end_line": 181,
        "content": "canApprole(profile) {\n    if (!profile || typeof profile !== 'object') {\n      return false;\n    }\n    const roleId = profile.role_id;\n    const secretId = profile.secret_id;\n    return typeof roleId === 'string' && roleId.trim().length > 0\n      && typeof secretId === 'string' && secretId.trim().length > 0;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 80,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 183,
        "end_line": 191,
        "content": "async ensureToken(profile, options = {}) {\n    if (profile.token && String(profile.token).trim()) {\n      return String(profile.token);\n    }\n    if (!this.canApprole(profile)) {\n      throw new Error('Vault token is required for this operation');\n    }\n    return this.loginApprole(profile, options);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 78,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 193,
        "end_line": 237,
        "content": "async loginApprole(profile, options = {}) {\n    const profileName = profile.profile_name;\n    if (!profileName) {\n      throw new Error('Vault profile_name is required for AppRole login');\n    }\n    const cached = this.loginInFlight.get(profileName);\n    if (cached) {\n      return cached;\n    }\n\n    const run = (async () => {\n      const url = `${profile.addr}/v1/auth/approle/login`;\n      const payload = await this.requestJson(url, {\n        method: 'POST',\n        headers: {\n          ...buildHeaders({ namespace: profile.namespace }),\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ role_id: String(profile.role_id), secret_id: String(profile.secret_id) }),\n        timeout_ms: options.timeout_ms,\n        retries: options.retries,\n      });\n\n      const token = payload?.auth?.client_token;\n      if (!token || typeof token !== 'string' || token.trim().length === 0) {\n        throw new Error('Vault AppRole login returned empty client_token');\n      }\n\n      await this.profileService.setProfile(profileName, {\n        type: 'vault',\n        secrets: { token },\n      }).catch((error) => {\n        this.logger.warn('Failed to persist Vault token after AppRole login', { profile: profileName, error: error.message });\n      });\n\n      profile.token = token;\n      return token;\n    })();\n\n    this.loginInFlight.set(profileName, run);\n    run.finally(() => {\n      this.loginInFlight.delete(profileName);\n    });\n    return run;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 372,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 239,
        "end_line": 257,
        "content": "parseKv2Ref(ref) {\n    const trimmed = String(ref || '').trim();\n    // ref format: <mount>/<path>#<key>\n    const [pathPart, keyPart] = trimmed.split('#');\n    if (!pathPart || !keyPart) {\n      throw new Error('vault kv2 ref must be in \"<mount>/<path>#<key>\" form');\n    }\n    const parts = pathPart.split('/').filter(Boolean);\n    if (parts.length < 2) {\n      throw new Error('vault kv2 ref must include mount and path');\n    }\n    const mount = parts[0];\n    const secretPath = parts.slice(1).join('/');\n    const key = keyPart.trim();\n    if (!key) {\n      throw new Error('vault kv2 ref key must be non-empty');\n    }\n    return { mount, secretPath, key };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 168,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/VaultClient.ts",
        "start_line": 259,
        "end_line": 304,
        "content": "async kv2Get(profileName, ref, options = {}) {\n    const profile = await this.loadProfile(profileName);\n    const token = await this.ensureToken(profile, { timeout_ms: options.timeout_ms, retries: options.retries });\n\n    const { mount, secretPath, key } = this.parseKv2Ref(ref);\n\n    const url = new URL(`${profile.addr}/v1/${encodeURIComponent(mount)}/data/${secretPath}`);\n    if (options.version !== undefined && options.version !== null && options.version !== '') {\n      url.searchParams.set('version', String(options.version));\n    }\n\n    const fetchOnce = (clientToken) => this.requestJson(url.toString(), {\n      method: 'GET',\n      headers: buildHeaders({ token: clientToken, namespace: profile.namespace }),\n      timeout_ms: options.timeout_ms,\n      retries: options.retries,\n    });\n\n    let payload;\n    try {\n      payload = await fetchOnce(token);\n    } catch (error) {\n      if (error?.status === 403 && this.canApprole(profile)) {\n        const fresh = await this.loginApprole(profile, { timeout_ms: options.timeout_ms, retries: options.retries });\n        payload = await fetchOnce(fresh);\n      } else {\n        throw error;\n      }\n    }\n\n    const data = payload?.data?.data;\n    if (!data || typeof data !== 'object' || Array.isArray(data)) {\n      throw new Error('Vault kv2 response has invalid shape (missing data.data)');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(data, key)) {\n      throw new Error(`Vault secret key not found: ${key}`);\n    }\n\n    const value = data[key];\n    if (value === undefined || value === null) {\n      throw new Error(`Vault secret key is null: ${key}`);\n    }\n\n    return String(value);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "VaultClient",
          "estimated_tokens": 416,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/services/WorkspaceService.ts": [
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 15,
        "end_line": 36,
        "content": "async function findGitRoot(startDir) {\n  if (!startDir) {\n    return undefined;\n  }\n  let current = startDir;\n  for (let depth = 0; depth < 25; depth += 1) {\n    const candidate = path.join(current, '.git');\n    try {\n      if (await pathExists(candidate)) {\n        return current;\n      }\n    } catch (error) {\n      return undefined;\n    }\n    const parent = path.dirname(current);\n    if (parent === current) {\n      break;\n    }\n    current = parent;\n  }\n  return undefined;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "findGitRoot",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 120,
          "qualified_name": "findGitRoot",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 38,
        "end_line": 54,
        "content": "function buildInputTemplate(required = [], defaults = {}) {\n  const template = {};\n  const safeDefaults = defaults && typeof defaults === 'object' ? defaults : {};\n  for (const key of required) {\n    if (Object.prototype.hasOwnProperty.call(safeDefaults, key)) {\n      template[key] = safeDefaults[key];\n    } else {\n      template[key] = `<${key}>`;\n    }\n  }\n  for (const [key, value] of Object.entries(safeDefaults)) {\n    if (template[key] === undefined) {\n      template[key] = value;\n    }\n  }\n  return template;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildInputTemplate",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 130,
          "qualified_name": "buildInputTemplate",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 56,
        "end_line": 61,
        "content": "function normalizeStringArray(value) {\n  if (!Array.isArray(value)) {\n    return [];\n  }\n  return value.filter((entry) => typeof entry === 'string' && entry.trim().length > 0);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeStringArray",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 44,
          "qualified_name": "normalizeStringArray",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 64,
        "end_line": 88,
        "content": "constructor(\n    logger,\n    contextService,\n    contextSessionService,\n    projectResolver,\n    profileService,\n    runbookService,\n    capabilityService,\n    projectService,\n    aliasService,\n    presetService,\n    stateService\n  ) {\n    this.logger = logger.child('workspace');\n    this.contextService = contextService;\n    this.contextSessionService = contextSessionService;\n    this.projectResolver = projectResolver;\n    this.profileService = profileService;\n    this.runbookService = runbookService;\n    this.capabilityService = capabilityService;\n    this.projectService = projectService;\n    this.aliasService = aliasService;\n    this.presetService = presetService;\n    this.stateService = stateService;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 183,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 90,
        "end_line": 100,
        "content": "async resolveSession(args = {}) {\n    if (!this.contextSessionService) {\n      return null;\n    }\n    try {\n      return await this.contextSessionService.resolve(args);\n    } catch (error) {\n      this.logger.warn('ContextSession resolve failed', { error: error.message });\n      return null;\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 79,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 102,
        "end_line": 124,
        "content": "async getStoreStatus() {\n    const info = resolveStoreInfo();\n    const baseItems = buildStorePaths(info.base_dir);\n\n    const collect = async (items) => {\n      const results = {};\n      for (const item of items) {\n        const exists = await pathExists(item.path).catch(() => false);\n        results[item.key] = {\n          exists,\n          path: item.path,\n          kind: item.kind,\n          sensitive: item.sensitive,\n        };\n      }\n      return results;\n    };\n\n    return {\n      ...info,\n      files: await collect(baseItems),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 142,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 126,
        "end_line": 135,
        "content": "async resolveProjectContext(args = {}) {\n    if (!this.projectResolver) {\n      return null;\n    }\n    try {\n      return await this.projectResolver.resolveContext(args);\n    } catch (error) {\n      return { error: error.message };\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 137,
        "end_line": 188,
        "content": "async getInventory() {\n    const profiles = await this.profileService.listProfiles();\n    const profileCounts = {};\n    for (const profile of profiles) {\n      profileCounts[profile.type] = (profileCounts[profile.type] || 0) + 1;\n    }\n\n    const runbookList = await this.runbookService.listRunbooks();\n    const runbookCounts = { total: runbookList.runbooks.length };\n    const runbookTags = {};\n    const runbookSources = {};\n    for (const runbook of runbookList.runbooks) {\n      runbookSources[runbook.source || 'local'] = (runbookSources[runbook.source || 'local'] || 0) + 1;\n      for (const tag of runbook.tags || []) {\n        runbookTags[tag] = (runbookTags[tag] || 0) + 1;\n      }\n    }\n\n    const capabilities = await this.capabilityService.listCapabilities();\n    const capabilitySources = {};\n    for (const capability of capabilities) {\n      capabilitySources[capability.source || 'local'] = (capabilitySources[capability.source || 'local'] || 0) + 1;\n    }\n\n    const projects = await this.projectService.listProjects();\n    const aliasStats = this.aliasService.getStats();\n    const presetStats = this.presetService.getStats();\n    const stateStats = this.stateService.getStats();\n\n    return {\n      profiles: {\n        total: profiles.length,\n        by_type: profileCounts,\n      },\n      runbooks: {\n        total: runbookList.runbooks.length,\n        by_source: runbookSources,\n        by_tag: runbookTags,\n      },\n      capabilities: {\n        total: capabilities.length,\n        by_source: capabilitySources,\n      },\n      projects: { total: projects.projects.length },\n      aliases: { total: aliasStats.total },\n      presets: { total: presetStats.total },\n      state: {\n        session_keys: stateStats.session_keys,\n        persistent_keys: stateStats.persistent_keys,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 459,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 190,
        "end_line": 211,
        "content": "async suggestCapabilities(context, limit) {\n    const capabilities = await this.capabilityService.listCapabilities();\n    const suggestions = [];\n    for (const capability of capabilities) {\n      if (await matchesWhen(capability.when, context)) {\n        suggestions.push({\n          name: capability.name,\n          intent: capability.intent,\n          description: capability.description,\n          tags: capability.tags || [],\n          effects: capability.effects,\n          inputs: capability.inputs,\n          source: capability.source || 'local',\n        });\n      }\n    }\n    suggestions.sort((a, b) => a.name.localeCompare(b.name));\n    if (typeof limit === 'number') {\n      return suggestions.slice(0, limit);\n    }\n    return suggestions;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 192,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 213,
        "end_line": 246,
        "content": "async suggestRunbooks(context, limit, includeUntagged = false) {\n    const runbookList = await this.runbookService.listRunbooks();\n    const suggestions = [];\n    for (const runbook of runbookList.runbooks) {\n      let matched = false;\n      let matchedTags = [];\n\n      if (runbook.when && await matchesWhen(runbook.when, context)) {\n        matched = true;\n      } else if (runbook.tags && runbook.tags.length > 0) {\n        matchedTags = matchTags(runbook.tags, context.tags || []);\n        matched = matchedTags.length > 0;\n      } else if (includeUntagged) {\n        matched = true;\n      }\n\n      if (matched) {\n        suggestions.push({\n          name: runbook.name,\n          description: runbook.description,\n          tags: runbook.tags || [],\n          inputs: runbook.inputs,\n          source: runbook.source || 'local',\n          reason: matchedTags.length ? { tags: matchedTags } : undefined,\n        });\n      }\n    }\n\n    suggestions.sort((a, b) => a.name.localeCompare(b.name));\n    if (typeof limit === 'number') {\n      return suggestions.slice(0, limit);\n    }\n    return suggestions;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 281,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 248,
        "end_line": 322,
        "content": "async summarize(args = {}) {\n    const session = await this.resolveSession(args);\n    const contextResult = session ? { context: session.effective_context } : await this.contextService.getContext(args);\n    const context = contextResult.context || {};\n    const projectContext = session?.project_context || await this.resolveProjectContext(args);\n    const store = await this.getStoreStatus();\n    const inventory = await this.getInventory();\n\n    const suggestions = {\n      capabilities: await this.suggestCapabilities(context, args.limit),\n      runbooks: await this.suggestRunbooks(context, args.limit, args.include_untagged === true),\n    };\n    const actions = this.buildActionHints(suggestions, {\n      includeCall: args.include_call !== false,\n      context,\n      projectContext,\n    });\n    const view = {\n      format: args.format || 'full',\n      limit: args.limit,\n      include_call: args.include_call !== false,\n    };\n\n    const baseWorkspace = {\n      context: {\n        key: context.key,\n        root: context.root,\n        tags: context.tags,\n        project_name: context.project_name,\n        target_name: context.target_name,\n        updated_at: context.updated_at,\n      },\n      project: projectContext && !projectContext.error ? {\n        name: projectContext.projectName,\n        target: projectContext.targetName,\n        description: projectContext.project?.description,\n        repo_root: projectContext.project?.repo_root,\n        target_info: projectContext.target || {},\n      } : undefined,\n      project_error: projectContext?.error,\n      diagnostics: session?.diagnostics,\n      bindings: session?.bindings,\n      suggestions,\n      actions,\n      view,\n    };\n\n    if (view.format === 'actions') {\n      return {\n        success: true,\n        context: baseWorkspace.context,\n        project: baseWorkspace.project,\n        diagnostics: baseWorkspace.diagnostics,\n        bindings: baseWorkspace.bindings,\n        actions,\n        view,\n      };\n    }\n\n    if (view.format === 'compact') {\n      return {\n        success: true,\n        workspace: baseWorkspace,\n      };\n    }\n\n    return {\n      success: true,\n      workspace: {\n        ...baseWorkspace,\n        store,\n        inventory,\n      },\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 565,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 324,
        "end_line": 370,
        "content": "async suggest(args = {}) {\n    const session = await this.resolveSession(args);\n    const contextResult = session ? { context: session.effective_context } : await this.contextService.getContext(args);\n    const context = contextResult.context || {};\n    const suggestions = {\n      capabilities: await this.suggestCapabilities(context, args.limit),\n      runbooks: await this.suggestRunbooks(context, args.limit, args.include_untagged === true),\n    };\n    const actions = this.buildActionHints(suggestions, {\n      includeCall: args.include_call !== false,\n      context,\n      projectContext: session?.project_context,\n    });\n    const view = {\n      format: args.format || 'suggest',\n      limit: args.limit,\n      include_call: args.include_call !== false,\n    };\n\n    if (view.format === 'actions') {\n      return {\n        success: true,\n        context: {\n          key: context.key,\n          root: context.root,\n          tags: context.tags,\n        },\n        diagnostics: session?.diagnostics,\n        bindings: session?.bindings,\n        actions,\n        view,\n      };\n    }\n    return {\n      success: true,\n      context: {\n        key: context.key,\n        root: context.root,\n        tags: context.tags,\n      },\n      diagnostics: session?.diagnostics,\n      bindings: session?.bindings,\n      suggestions,\n      actions,\n      view,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 344,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 372,
        "end_line": 440,
        "content": "async diagnose(args = {}) {\n    const store = await this.getStoreStatus();\n    const contextResult = await this.contextService.getContext(args);\n    const context = contextResult.context || {};\n    const projectContext = await this.resolveProjectContext(args);\n    const inventory = await this.getInventory();\n\n    const warnings = [];\n    const hints = [];\n\n    const gitRoot = await findGitRoot(store.base_dir);\n    if (gitRoot && store.mode !== 'custom') {\n      warnings.push({\n        code: 'store_inside_repo',\n        message: `–•—Ä–∞–Ω–∏–ª–∏—â–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–æ –≤–Ω—É—Ç—Ä–∏ git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è: ${store.base_dir}`,\n        action: { tool: 'mcp_workspace', args: { action: 'store_status' } },\n      });\n    }\n\n    if (projectContext?.target && !projectContext.error) {\n      const target = projectContext.target || {};\n      const missing = [];\n      for (const [label, value] of Object.entries({\n        ssh_profile: target.ssh_profile,\n        env_profile: target.env_profile,\n        postgres_profile: target.postgres_profile,\n        api_profile: target.api_profile,\n        vault_profile: target.vault_profile,\n      })) {\n        if (value && !this.profileService.hasProfile(String(value))) {\n          missing.push(label);\n        }\n      }\n      if (missing.length > 0) {\n        warnings.push({\n          code: 'missing_profiles',\n          message: `–ù–µ –Ω–∞–π–¥–µ–Ω—ã –ø—Ä–æ—Ñ–∏–ª–∏ –¥–ª—è target: ${missing.join(', ')}`,\n        });\n      }\n    }\n\n    if (inventory.runbooks.total === 0) {\n      hints.push({ code: 'no_runbooks', message: '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö runbook-–æ–≤. –î–æ–±–∞–≤—å—Ç–µ —á–µ—Ä–µ–∑ mcp_runbook.' });\n    }\n\n    if (inventory.capabilities.total === 0) {\n      hints.push({ code: 'no_capabilities', message: '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö capability. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ capabilities.json.' });\n    }\n\n    return {\n      success: true,\n      diagnostics: {\n        warnings,\n        hints,\n      },\n      context: {\n        key: context.key,\n        root: context.root,\n        tags: context.tags,\n      },\n      store,\n      inventory,\n      project: projectContext && !projectContext.error ? {\n        name: projectContext.projectName,\n        target: projectContext.targetName,\n      } : undefined,\n      project_error: projectContext?.error,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 581,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 442,
        "end_line": 446,
        "content": "async getStats() {\n    const store = await this.getStoreStatus();\n    const inventory = await this.getInventory();\n    return { success: true, store, inventory };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 45,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/services/WorkspaceService.ts",
        "start_line": 448,
        "end_line": 528,
        "content": "buildActionHints(suggestions, { includeCall = true, context, projectContext } = {}) {\n    const mappingContext = {\n      context: context || {},\n      project: projectContext?.project || {},\n      target: projectContext?.target || {},\n    };\n\n    const resolveInputs = (inputsMeta) => {\n      const required = normalizeStringArray(inputsMeta?.required);\n      const defaults = inputsMeta?.defaults && typeof inputsMeta.defaults === 'object' ? inputsMeta.defaults : {};\n      const map = inputsMeta?.map && typeof inputsMeta.map === 'object' ? inputsMeta.map : {};\n      const resolved = { ...defaults };\n\n      for (const [targetKey, sourcePath] of Object.entries(map)) {\n        const value = getPathValue(mappingContext, sourcePath, { defaultValue: undefined });\n        if (value !== undefined) {\n          resolved[targetKey] = value;\n        }\n      }\n\n      const missing = required.filter((key) => resolved[key] === undefined || resolved[key] === null || resolved[key] === '');\n      return { required, defaults, map, resolved, missing };\n    };\n\n    const intentActions = suggestions.capabilities.map((capability) => {\n      const inputsMeta = capability.inputs || {};\n      const { required, defaults, map, resolved, missing } = resolveInputs(inputsMeta);\n      const template = buildInputTemplate(required, { ...defaults, ...resolved });\n      return {\n        kind: 'intent',\n        name: capability.name,\n        intent: capability.intent,\n        description: capability.description,\n        tags: capability.tags || [],\n        effects: capability.effects,\n        inputs: {\n          required,\n          defaults,\n          map,\n          resolved,\n          missing,\n        },\n        call: includeCall ? {\n          tool: 'mcp_workspace',\n          args: {\n            action: 'run',\n            intent_type: capability.intent,\n            inputs: template,\n            apply: capability.effects?.requires_apply ? true : undefined,\n          },\n        } : undefined,\n      };\n    });\n\n    const runbookActions = suggestions.runbooks.map((runbook) => {\n      const inputsMeta = { required: runbook.inputs || [] };\n      const { required, resolved, missing } = resolveInputs(inputsMeta);\n      const template = buildInputTemplate(required, resolved);\n      return {\n        kind: 'runbook',\n        name: runbook.name,\n        description: runbook.description,\n        tags: runbook.tags || [],\n        inputs: { required, resolved, missing },\n        reason: runbook.reason,\n        call: includeCall ? {\n          tool: 'mcp_workspace',\n          args: {\n            action: 'run',\n            name: runbook.name,\n            input: template,\n          },\n        } : undefined,\n      };\n    });\n\n    return {\n      intents: intentActions,\n      runbooks: runbookActions,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "WorkspaceService",
          "estimated_tokens": 704,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/stores/FileJobStore.ts": [
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 11,
        "end_line": 20,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numberValue = Number(value);\n  if (!Number.isFinite(numberValue) || numberValue <= 0) {\n    return null;\n  }\n  return Math.floor(numberValue);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 67,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 23,
        "end_line": 36,
        "content": "constructor(logger, { filePath, debounceMs, maxJobs, ttlMs } = {}) {\n    super(logger, { maxJobs, ttlMs, source: 'file' });\n    this.filePath = filePath || resolveJobsPath();\n    this.debounceMs = readPositiveInt(\n      debounceMs\n      ?? process.env.SENTRYFROGG_JOBS_PERSIST_DEBOUNCE_MS\n      ?? process.env.SF_JOBS_PERSIST_DEBOUNCE_MS\n    ) ?? 50;\n    this.queue = Promise.resolve();\n    this.dirty = false;\n    this.persistTimer = null;\n\n    this.loadFromDisk();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "FileJobStore",
          "estimated_tokens": 120,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 38,
        "end_line": 62,
        "content": "loadFromDisk() {\n    try {\n      if (!fsSync.existsSync(this.filePath)) {\n        return;\n      }\n      const raw = fsSync.readFileSync(this.filePath, 'utf8');\n      const parsed = JSON.parse(raw);\n      if (Array.isArray(parsed)) {\n        this.load(parsed);\n        return;\n      }\n      if (parsed && typeof parsed === 'object') {\n        if (Array.isArray(parsed.jobs)) {\n          this.load(parsed.jobs);\n          return;\n        }\n        const values = Object.values(parsed);\n        if (values.length && values.every((item) => item && typeof item === 'object')) {\n          this.load(values);\n        }\n      }\n    } catch (error) {\n      this.logger?.warn?.('Failed to load jobs store', { error: error.message });\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "FileJobStore",
          "estimated_tokens": 186,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 64,
        "end_line": 66,
        "content": "onMutate() {\n    this.schedulePersist();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "FileJobStore",
          "estimated_tokens": 14,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 68,
        "end_line": 77,
        "content": "schedulePersist() {\n    this.dirty = true;\n    if (this.persistTimer) {\n      return;\n    }\n    this.persistTimer = setTimeout(() => {\n      this.persistTimer = null;\n      void this.flush();\n    }, this.debounceMs);\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "FileJobStore",
          "estimated_tokens": 58,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/FileJobStore.ts",
        "start_line": 79,
        "end_line": 97,
        "content": "async flush() {\n    if (this.persistTimer) {\n      clearTimeout(this.persistTimer);\n      this.persistTimer = null;\n    }\n\n    if (!this.dirty) {\n      return this.queue;\n    }\n    this.dirty = false;\n\n    const payload = `${JSON.stringify(this.toJSON(), null, 2)}\\n`;\n    this.queue = this.queue\n      .then(() => atomicWriteTextFile(this.filePath, payload, { mode: 0o600 }))\n      .catch((error) => {\n        this.logger?.warn?.('Failed to persist jobs store', { error: error.message });\n      });\n    return this.queue;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "FileJobStore",
          "estimated_tokens": 134,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/stores/MemoryJobStore.ts": [
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 11,
        "end_line": 20,
        "content": "function readPositiveInt(value) {\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  const numberValue = Number(value);\n  if (!Number.isFinite(numberValue) || numberValue <= 0) {\n    return null;\n  }\n  return Math.floor(numberValue);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readPositiveInt",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 67,
          "qualified_name": "readPositiveInt",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 22,
        "end_line": 24,
        "content": "function nowIso() {\n  return new Date().toISOString();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "nowIso",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 14,
          "qualified_name": "nowIso",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 27,
        "end_line": 37,
        "content": "constructor(logger, { maxJobs, ttlMs, source } = {}) {\n    this.logger = logger?.child ? logger.child('jobs_store') : logger;\n    this.jobs = new Map();\n\n    const maxJobsEnv = process.env.SENTRYFROGG_JOBS_MAX || process.env.SF_JOBS_MAX;\n    const ttlEnv = process.env.SENTRYFROGG_JOBS_TTL_MS || process.env.SF_JOBS_TTL_MS;\n\n    this.maxJobs = Number.isFinite(maxJobs) ? Math.floor(maxJobs) : (readPositiveInt(maxJobsEnv) ?? DEFAULT_MAX_JOBS);\n    this.ttlMs = Number.isFinite(ttlMs) ? Math.floor(ttlMs) : (readPositiveInt(ttlEnv) ?? DEFAULT_TTL_MS);\n    this.source = source || 'memory';\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 151,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 39,
        "end_line": 41,
        "content": "onMutate() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 10,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 43,
        "end_line": 54,
        "content": "purgeExpired(now = Date.now()) {\n    const removed = [];\n    for (const [jobId, job] of this.jobs.entries()) {\n      const expiresAt = job?.expires_at_ms;\n      if (expiresAt && expiresAt <= now) {\n        this.jobs.delete(jobId);\n        this.onMutate();\n        removed.push(jobId);\n      }\n    }\n    return removed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 83,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 56,
        "end_line": 64,
        "content": "touch(jobId) {\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      return null;\n    }\n    this.jobs.delete(jobId);\n    this.jobs.set(jobId, job);\n    return job;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 46,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 66,
        "end_line": 75,
        "content": "enforceCapacity() {\n    while (this.jobs.size > this.maxJobs) {\n      const oldest = this.jobs.keys().next().value;\n      if (!oldest) {\n        break;\n      }\n      this.jobs.delete(oldest);\n      this.onMutate();\n    }\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 77,
        "end_line": 83,
        "content": "normalizeStatus(status) {\n    const value = status === undefined || status === null ? null : String(status).trim();\n    if (!value) {\n      return null;\n    }\n    return VALID_STATUSES.has(value) ? value : null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 56,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 85,
        "end_line": 108,
        "content": "create({ kind, trace_id, parent_span_id, provider, progress } = {}) {\n    const jobId = crypto.randomUUID();\n    const createdAt = nowIso();\n    const record = {\n      job_id: jobId,\n      kind: kind ? String(kind) : 'inprocess_task',\n      status: 'queued',\n      trace_id: trace_id || undefined,\n      parent_span_id: parent_span_id || undefined,\n      created_at: createdAt,\n      started_at: null,\n      updated_at: createdAt,\n      ended_at: null,\n      progress: typeof progress === 'number' ? progress : null,\n      artifacts: null,\n      provider: provider && typeof provider === 'object' && !Array.isArray(provider) ? provider : null,\n      error: null,\n      expires_at_ms: Date.now() + this.ttlMs,\n    };\n    this.jobs.set(jobId, record);\n    this.onMutate();\n    this.enforceCapacity();\n    return record;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 208,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 110,
        "end_line": 139,
        "content": "upsert(job) {\n    if (!job || typeof job !== 'object') {\n      return null;\n    }\n    const jobId = typeof job.job_id === 'string' && job.job_id.trim().length ? job.job_id.trim() : null;\n    if (!jobId) {\n      return null;\n    }\n\n    const existing = this.jobs.get(jobId);\n    const createdAt = existing?.created_at || job.created_at || nowIso();\n    const updatedAt = nowIso();\n    const status = this.normalizeStatus(job.status) || existing?.status || 'queued';\n\n    const next = {\n      ...(existing || {}),\n      ...job,\n      job_id: jobId,\n      created_at: createdAt,\n      updated_at: updatedAt,\n      status,\n      expires_at_ms: Date.now() + this.ttlMs,\n    };\n\n    this.jobs.delete(jobId);\n    this.jobs.set(jobId, next);\n    this.onMutate();\n    this.enforceCapacity();\n    return next;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 203,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 141,
        "end_line": 147,
        "content": "get(jobId) {\n    if (typeof jobId !== 'string' || !jobId.trim().length) {\n      return null;\n    }\n    const job = this.touch(jobId.trim());\n    return job || null;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 45,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 149,
        "end_line": 154,
        "content": "has(jobId) {\n    if (typeof jobId !== 'string' || !jobId.trim().length) {\n      return false;\n    }\n    return this.jobs.has(jobId.trim());\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 38,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 156,
        "end_line": 173,
        "content": "list({ limit, status } = {}) {\n    const max = Math.min(readPositiveInt(limit) ?? 50, 200);\n    const filterStatus = this.normalizeStatus(status);\n\n    const out = [];\n    const values = Array.from(this.jobs.values()).reverse();\n    for (const job of values) {\n      if (filterStatus && job.status !== filterStatus) {\n        continue;\n      }\n      out.push(job);\n      if (out.length >= max) {\n        break;\n      }\n    }\n\n    return out;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 114,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 175,
        "end_line": 185,
        "content": "forget(jobId) {\n    if (typeof jobId !== 'string' || !jobId.trim().length) {\n      return false;\n    }\n    const key = jobId.trim();\n    const existed = this.jobs.delete(key);\n    if (existed) {\n      this.onMutate();\n    }\n    return existed;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 64,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 187,
        "end_line": 205,
        "content": "load(records) {\n    if (!Array.isArray(records)) {\n      return;\n    }\n    for (const record of records) {\n      if (!record || typeof record !== 'object') {\n        continue;\n      }\n      const jobId = typeof record.job_id === 'string' && record.job_id.trim().length ? record.job_id.trim() : null;\n      if (!jobId) {\n        continue;\n      }\n      this.jobs.set(jobId, {\n        ...record,\n        job_id: jobId,\n      });\n    }\n    this.enforceCapacity();\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 119,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 207,
        "end_line": 213,
        "content": "toJSON() {\n    return {\n      version: 1,\n      updated_at: nowIso(),\n      jobs: Array.from(this.jobs.values()),\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 34,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 215,
        "end_line": 222,
        "content": "getStats() {\n    return {\n      jobs: this.jobs.size,\n      max_jobs: this.maxJobs,\n      ttl_ms: this.ttlMs,\n      store: this.source,\n    };\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 39,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/stores/MemoryJobStore.ts",
        "start_line": 224,
        "end_line": 226,
        "content": "async flush() {\n    return;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MemoryJobStore",
          "estimated_tokens": 10,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/artifacts.ts": [
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 20,
        "end_line": 29,
        "content": "function isDirectory(candidate) {\n  if (!candidate) {\n    return false;\n  }\n  try {\n    return fs.existsSync(candidate) && fs.statSync(candidate).isDirectory();\n  } catch (error) {\n    return false;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isDirectory",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 51,
          "qualified_name": "isDirectory",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 31,
        "end_line": 37,
        "content": "function resolveContextRepoRoot() {\n  const explicit = process.env.SENTRYFROGG_CONTEXT_REPO_ROOT || process.env.SF_CONTEXT_REPO_ROOT;\n  if (explicit) {\n    return isDirectory(explicit) ? explicit : null;\n  }\n  return isDirectory(DEFAULT_CONTEXT_REPO_ROOT) ? DEFAULT_CONTEXT_REPO_ROOT : null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveContextRepoRoot",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 73,
          "qualified_name": "resolveContextRepoRoot",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 39,
        "end_line": 52,
        "content": "function normalizeSegment(value, label) {\n  if (typeof value !== 'string' || value.trim().length === 0) {\n    throw new Error(`${label} must be a non-empty string`);\n  }\n\n  const trimmed = value.trim();\n  if (trimmed === '.' || trimmed === '..') {\n    throw new Error(`${label} must not be '.' or '..'`);\n  }\n  if (trimmed.includes('/') || trimmed.includes('\\\\')) {\n    throw new Error(`${label} must not contain path separators`);\n  }\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeSegment",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 113,
          "qualified_name": "normalizeSegment",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 54,
        "end_line": 60,
        "content": "function normalizeFilename(value) {\n  const trimmed = normalizeSegment(value, 'filename');\n  if (path.basename(trimmed) !== trimmed) {\n    throw new Error('filename must be a basename only');\n  }\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeFilename",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 53,
          "qualified_name": "normalizeFilename",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 62,
        "end_line": 70,
        "content": "function buildToolCallContextRef({ traceId, spanId }) {\n  const runId = normalizeSegment(traceId || 'run', 'trace_id');\n  const callId = normalizeSegment(spanId || crypto.randomUUID(), 'span_id');\n  const rel = `runs/${runId}/tool_calls/${callId}.context`;\n  return {\n    uri: `artifact://${rel}`,\n    rel,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildToolCallContextRef",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 78,
          "qualified_name": "buildToolCallContextRef",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 72,
        "end_line": 81,
        "content": "function buildToolCallFileRef({ traceId, spanId, filename }) {\n  const runId = normalizeSegment(traceId || 'run', 'trace_id');\n  const callId = normalizeSegment(spanId || crypto.randomUUID(), 'span_id');\n  const safeName = normalizeFilename(filename);\n  const rel = `runs/${runId}/tool_calls/${callId}/${safeName}`;\n  return {\n    uri: `artifact://${rel}`,\n    rel,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildToolCallFileRef",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 93,
          "qualified_name": "buildToolCallFileRef",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 83,
        "end_line": 96,
        "content": "function resolveArtifactPath(contextRoot, rel) {\n  if (!contextRoot) {\n    throw new Error('contextRoot is required');\n  }\n  if (typeof rel !== 'string' || rel.trim().length === 0) {\n    throw new Error('artifact rel must be a non-empty string');\n  }\n  const base = path.resolve(contextRoot, 'artifacts');\n  const resolved = path.resolve(base, rel);\n  if (resolved !== base && !resolved.startsWith(`${base}${path.sep}`)) {\n    throw new Error('Artifact path escapes context root');\n  }\n  return resolved;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveArtifactPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 126,
          "qualified_name": "resolveArtifactPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 98,
        "end_line": 113,
        "content": "async function writeTextArtifact(contextRoot, ref, content, options = {}) {\n  if (!ref || typeof ref !== 'object') {\n    throw new Error('artifact ref is required');\n  }\n\n  const mode = options.mode ?? DEFAULT_FILE_MODE;\n  const filePath = resolveArtifactPath(contextRoot, ref.rel);\n  const payload = typeof content === 'string' ? content : String(content ?? '');\n  await atomicWriteTextFile(filePath, payload, { mode });\n  return {\n    uri: ref.uri,\n    rel: ref.rel,\n    path: filePath,\n    bytes: Buffer.byteLength(payload, 'utf8'),\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeTextArtifact",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 135,
          "qualified_name": "writeTextArtifact",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 115,
        "end_line": 140,
        "content": "async function writeBinaryArtifact(contextRoot, ref, buffer, options = {}) {\n  if (!ref || typeof ref !== 'object') {\n    throw new Error('artifact ref is required');\n  }\n\n  const mode = options.mode ?? DEFAULT_FILE_MODE;\n  const filePath = resolveArtifactPath(contextRoot, ref.rel);\n  const payload = Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer ?? '');\n  const tmpPath = tempSiblingPath(filePath);\n  await ensureDirForFile(filePath);\n\n  try {\n    await fsp.writeFile(tmpPath, payload, { mode });\n    await atomicReplaceFile(tmpPath, filePath, { overwrite: true, mode });\n  } catch (error) {\n    await fsp.unlink(tmpPath).catch(() => null);\n    throw error;\n  }\n\n  return {\n    uri: ref.uri,\n    rel: ref.rel,\n    path: filePath,\n    bytes: payload.length,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeBinaryArtifact",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 193,
          "qualified_name": "writeBinaryArtifact",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 142,
        "end_line": 212,
        "content": "async function createArtifactWriteStream(contextRoot, ref, options = {}) {\n  if (!ref || typeof ref !== 'object') {\n    throw new Error('artifact ref is required');\n  }\n\n  const mode = options.mode ?? DEFAULT_FILE_MODE;\n  const filePath = resolveArtifactPath(contextRoot, ref.rel);\n  const tmpPath = tempSiblingPath(filePath);\n  await ensureDirForFile(filePath);\n\n  const stream = fs.createWriteStream(tmpPath, { mode });\n  const closePromise = once(stream, 'close').catch(() => null);\n  let streamError = null;\n  stream.on('error', (error) => {\n    streamError = error;\n  });\n\n  let finished = false;\n  let aborted = false;\n\n  const finalize = async () => {\n    if (aborted) {\n      throw new Error('artifact stream was aborted');\n    }\n    if (!finished) {\n      finished = true;\n      if (!stream.destroyed && !stream.writableEnded) {\n        stream.end();\n      }\n    }\n    await closePromise;\n    if (streamError) {\n      await fsp.unlink(tmpPath).catch(() => null);\n      throw streamError;\n    }\n\n    try {\n      await atomicReplaceFile(tmpPath, filePath, { overwrite: true, mode });\n      const stat = await fsp.stat(filePath);\n      return {\n        uri: ref.uri,\n        rel: ref.rel,\n        path: filePath,\n        bytes: stat.size,\n      };\n    } catch (error) {\n      await fsp.unlink(tmpPath).catch(() => null);\n      throw error;\n    }\n  };\n\n  const abort = async () => {\n    if (aborted) {\n      return;\n    }\n    aborted = true;\n    stream.destroy();\n    await closePromise;\n    await fsp.unlink(tmpPath).catch(() => null);\n  };\n\n  return {\n    uri: ref.uri,\n    rel: ref.rel,\n    path: filePath,\n    tmp_path: tmpPath,\n    stream,\n    finalize,\n    abort,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createArtifactWriteStream",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 420,
          "qualified_name": "createArtifactWriteStream",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/artifacts.ts",
        "start_line": 214,
        "end_line": 301,
        "content": "async function copyFileArtifact(contextRoot, ref, sourcePath, options = {}) {\n  if (!ref || typeof ref !== 'object') {\n    throw new Error('artifact ref is required');\n  }\n  if (typeof sourcePath !== 'string' || sourcePath.trim().length === 0) {\n    throw new Error('sourcePath must be a non-empty string');\n  }\n\n  const mode = options.mode ?? DEFAULT_FILE_MODE;\n  const maxBytes = Number.isFinite(options.maxBytes) ? options.maxBytes : null;\n\n  const filePath = resolveArtifactPath(contextRoot, ref.rel);\n  const tmpPath = tempSiblingPath(filePath);\n  await ensureDirForFile(filePath);\n\n  try {\n    if (!maxBytes) {\n      await fsp.copyFile(sourcePath, tmpPath);\n      await atomicReplaceFile(tmpPath, filePath, { overwrite: true, mode });\n      const stat = await fsp.stat(filePath);\n      return {\n        uri: ref.uri,\n        rel: ref.rel,\n        path: filePath,\n        bytes: stat.size,\n        truncated: false,\n      };\n    }\n\n    await new Promise((resolve, reject) => {\n      const readStream = fs.createReadStream(sourcePath, { highWaterMark: 64 * 1024 });\n      const writeStream = fs.createWriteStream(tmpPath, { mode });\n      let written = 0;\n      let done = false;\n\n      const cleanup = () => {\n        readStream.destroy();\n        writeStream.end();\n      };\n\n      readStream.on('data', (chunk) => {\n        if (done) {\n          return;\n        }\n        const remaining = maxBytes - written;\n        if (remaining <= 0) {\n          done = true;\n          cleanup();\n          return;\n        }\n        if (chunk.length <= remaining) {\n          written += chunk.length;\n          writeStream.write(chunk);\n          return;\n        }\n        written += remaining;\n        writeStream.write(chunk.subarray(0, remaining));\n        done = true;\n        cleanup();\n      });\n\n      readStream.on('error', (error) => {\n        reject(error);\n      });\n\n      writeStream.on('error', (error) => {\n        reject(error);\n      });\n\n      Promise.all([once(writeStream, 'close'), once(readStream, 'close')])\n        .then(() => resolve())\n        .catch(reject);\n    });\n\n    await atomicReplaceFile(tmpPath, filePath, { overwrite: true, mode });\n    const stat = await fsp.stat(filePath);\n    return {\n      uri: ref.uri,\n      rel: ref.rel,\n      path: filePath,\n      bytes: stat.size,\n      truncated: true,\n    };\n  } catch (error) {\n    await fsp.unlink(tmpPath).catch(() => null);\n    throw error;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "copyFileArtifact",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 606,
          "qualified_name": "copyFileArtifact",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/dataPath.ts": [
      {
        "file_path": "src/utils/dataPath.ts",
        "start_line": 4,
        "end_line": 32,
        "content": "function parsePath(path) {\n  if (typeof path !== 'string' || path.trim().length === 0) {\n    throw new Error('Path must be a non-empty string');\n  }\n\n  const segments = [];\n  const pattern = /([^[.\\]]+)|\\[(.*?)\\]/g;\n  let match;\n\n  while ((match = pattern.exec(path)) !== null) {\n    const raw = match[1] !== undefined ? match[1] : match[2];\n    if (raw === undefined || raw === '') {\n      continue;\n    }\n    const trimmed = raw.trim();\n    if (!trimmed) {\n      continue;\n    }\n\n    const unquoted = trimmed.replace(/^['\"]|['\"]$/g, '');\n    if (/^\\d+$/.test(unquoted)) {\n      segments.push(Number.parseInt(unquoted, 10));\n    } else {\n      segments.push(unquoted);\n    }\n  }\n\n  return segments;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parsePath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 178,
          "qualified_name": "parsePath",
          "documentation": "// @ts-nocheck",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/dataPath.ts",
        "start_line": 34,
        "end_line": 57,
        "content": "function getPathValue(target, path, { defaultValue, required } = {}) {\n  if (path === undefined || path === null || path === '') {\n    return target;\n  }\n\n  const segments = Array.isArray(path) ? path : parsePath(path);\n  let current = target;\n\n  for (const segment of segments) {\n    if (current === undefined || current === null) {\n      if (required) {\n        throw new Error(`Path '${Array.isArray(path) ? path.join('.') : path}' not found`);\n      }\n      return defaultValue;\n    }\n    current = current[segment];\n  }\n\n  if (current === undefined && required) {\n    throw new Error(`Path '${Array.isArray(path) ? path.join('.') : path}' not found`);\n  }\n\n  return current === undefined ? defaultValue : current;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "getPathValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 180,
          "qualified_name": "getPathValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/featureFlags.ts": [
      {
        "file_path": "src/utils/featureFlags.ts",
        "start_line": 4,
        "end_line": 10,
        "content": "function isTruthy(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  const normalized = String(value).trim().toLowerCase();\n  return normalized === '1' || normalized === 'true' || normalized === 'yes' || normalized === 'on';\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isTruthy",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 66,
          "qualified_name": "isTruthy",
          "documentation": "// @ts-nocheck",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/featureFlags.ts",
        "start_line": 12,
        "end_line": 14,
        "content": "function isUnsafeLocalEnabled() {\n  return isTruthy(process.env.SENTRYFROGG_UNSAFE_LOCAL) || isTruthy(process.env.SF_UNSAFE_LOCAL);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isUnsafeLocalEnabled",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 33,
          "qualified_name": "isUnsafeLocalEnabled",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/fsAtomic.ts": [
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 8,
        "end_line": 18,
        "content": "async function pathExists(filePath) {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "pathExists",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 49,
          "qualified_name": "pathExists",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 20,
        "end_line": 22,
        "content": "function randomToken() {\n  return crypto.randomBytes(6).toString('hex');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "randomToken",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 18,
          "qualified_name": "randomToken",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 24,
        "end_line": 28,
        "content": "function tempSiblingPath(targetPath, suffix = '.tmp') {\n  const dir = path.dirname(targetPath);\n  const base = path.basename(targetPath);\n  return path.join(dir, `${base}${suffix}-${process.pid}-${Date.now()}-${randomToken()}`);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "tempSiblingPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 57,
          "qualified_name": "tempSiblingPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 30,
        "end_line": 32,
        "content": "async function ensureDirForFile(filePath, mode = 0o700) {\n  await fs.mkdir(path.dirname(filePath), { recursive: true, mode });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureDirForFile",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 32,
          "qualified_name": "ensureDirForFile",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 34,
        "end_line": 43,
        "content": "async function chmodQuiet(filePath, mode) {\n  if (!mode) {\n    return;\n  }\n  try {\n    await fs.chmod(filePath, mode);\n  } catch (error) {\n    // Best-effort: permissions may not be supported (e.g., Windows) or may fail due to FS policies.\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "chmodQuiet",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 61,
          "qualified_name": "chmodQuiet",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 45,
        "end_line": 92,
        "content": "async function atomicReplaceFile(tmpPath, targetPath, { overwrite = true, mode } = {}) {\n  if (!overwrite && await pathExists(targetPath)) {\n    throw new Error(`Path already exists: ${targetPath}`);\n  }\n\n  await ensureDirForFile(targetPath);\n\n  const windows = process.platform === 'win32';\n  if (!windows) {\n    await fs.rename(tmpPath, targetPath);\n    await chmodQuiet(targetPath, mode);\n    return;\n  }\n\n  const backupPath = tempSiblingPath(targetPath, '.bak');\n  let backedUp = false;\n\n  if (overwrite && await pathExists(targetPath)) {\n    await fs.rename(targetPath, backupPath);\n    backedUp = true;\n  }\n\n  try {\n    await fs.rename(tmpPath, targetPath);\n  } catch (error) {\n    if ((error.code === 'EEXIST' || error.code === 'EPERM') && overwrite) {\n      try {\n        await fs.unlink(targetPath);\n      } catch (unlinkError) {\n        if (unlinkError.code !== 'ENOENT') {\n          throw unlinkError;\n        }\n      }\n      await fs.rename(tmpPath, targetPath);\n    } else {\n      if (backedUp) {\n        await fs.rename(backupPath, targetPath).catch(() => null);\n      }\n      throw error;\n    }\n  }\n\n  if (backedUp) {\n    await fs.unlink(backupPath).catch(() => null);\n  }\n\n  await chmodQuiet(targetPath, mode);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "atomicReplaceFile",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 307,
          "qualified_name": "atomicReplaceFile",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/fsAtomic.ts",
        "start_line": 94,
        "end_line": 106,
        "content": "async function atomicWriteTextFile(filePath, contents, { mode = 0o600 } = {}) {\n  const tmpPath = tempSiblingPath(filePath);\n  await ensureDirForFile(filePath);\n\n  try {\n    await fs.writeFile(tmpPath, contents, { encoding: 'utf8', mode });\n    await chmodQuiet(tmpPath, mode);\n    await atomicReplaceFile(tmpPath, filePath, { overwrite: true, mode });\n  } catch (error) {\n    await fs.unlink(tmpPath).catch(() => null);\n    throw error;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "atomicWriteTextFile",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 110,
          "qualified_name": "atomicWriteTextFile",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/merge.ts": [
      {
        "file_path": "src/utils/merge.ts",
        "start_line": 4,
        "end_line": 6,
        "content": "function isPlainObject(value) {\n  return value && typeof value === 'object' && !Array.isArray(value);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isPlainObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 28,
          "qualified_name": "isPlainObject",
          "documentation": "// @ts-nocheck",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/merge.ts",
        "start_line": 8,
        "end_line": 25,
        "content": "function mergeDeep(base, override) {\n  if (!isPlainObject(base) || !isPlainObject(override)) {\n    return override !== undefined ? override : base;\n  }\n\n  const result = { ...base };\n  for (const [key, value] of Object.entries(override)) {\n    if (value === undefined) {\n      continue;\n    }\n    if (isPlainObject(value) && isPlainObject(result[key])) {\n      result[key] = mergeDeep(result[key], value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "mergeDeep",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 118,
          "qualified_name": "mergeDeep",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/output.ts": [
      {
        "file_path": "src/utils/output.ts",
        "start_line": 6,
        "end_line": 16,
        "content": "function resolveEmptyDefault(output) {\n  if (output && typeof output === 'object') {\n    if (output.map) {\n      return [];\n    }\n    if (output.pick || output.omit) {\n      return {};\n    }\n  }\n  return {};\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveEmptyDefault",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 52,
          "qualified_name": "resolveEmptyDefault",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/output.ts",
        "start_line": 18,
        "end_line": 38,
        "content": "function resolveMissingDefault(output) {\n  if (!output || typeof output !== 'object') {\n    return undefined;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(output, 'default')) {\n    return output.default;\n  }\n\n  switch (output.missing) {\n    case 'null':\n      return null;\n    case 'undefined':\n      return undefined;\n    case 'empty':\n      return resolveEmptyDefault(output);\n    case 'error':\n    default:\n      return undefined;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveMissingDefault",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 110,
          "qualified_name": "resolveMissingDefault",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/output.ts",
        "start_line": 40,
        "end_line": 52,
        "content": "function pickFields(value, fields) {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return value;\n  }\n\n  const result = {};\n  for (const field of fields) {\n    if (Object.prototype.hasOwnProperty.call(value, field)) {\n      result[field] = value[field];\n    }\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "pickFields",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 77,
          "qualified_name": "pickFields",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/output.ts",
        "start_line": 54,
        "end_line": 64,
        "content": "function omitFields(value, fields) {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return value;\n  }\n\n  const result = { ...value };\n  for (const field of fields) {\n    delete result[field];\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "omitFields",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "omitFields",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/output.ts",
        "start_line": 66,
        "end_line": 102,
        "content": "function applyOutputTransform(value, output) {\n  if (!output || typeof output !== 'object') {\n    return value;\n  }\n\n  const missingMode = output.missing || 'error';\n  const required = missingMode === 'error';\n  const defaultValue = resolveMissingDefault(output);\n\n  let current = value;\n  if (output.path) {\n    current = getPathValue(current, output.path, { required, defaultValue });\n  }\n\n  if (output.pick && Array.isArray(output.pick)) {\n    current = pickFields(current, output.pick);\n  }\n\n  if (output.omit && Array.isArray(output.omit)) {\n    current = omitFields(current, output.omit);\n  }\n\n  if (output.map) {\n    if (!Array.isArray(current)) {\n      if (required) {\n        throw new Error('Output map expects an array result');\n      }\n      current = defaultValue;\n    }\n\n    if (Array.isArray(current)) {\n      current = current.map((item) => applyOutputTransform(item, output.map));\n    }\n  }\n\n  return current;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "applyOutputTransform",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 232,
          "qualified_name": "applyOutputTransform",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/paths.ts": [
      {
        "file_path": "src/utils/paths.ts",
        "start_line": 8,
        "end_line": 15,
        "content": "function resolveHomeDir() {\n  try {\n    const home = os.homedir();\n    return home && typeof home === 'string' ? home : null;\n  } catch (error) {\n    return null;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveHomeDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 42,
          "qualified_name": "resolveHomeDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/paths.ts",
        "start_line": 17,
        "end_line": 28,
        "content": "function resolveXdgStateDir() {\n  if (process.env.XDG_STATE_HOME) {\n    return path.resolve(process.env.XDG_STATE_HOME);\n  }\n\n  const home = resolveHomeDir();\n  if (home) {\n    return path.join(home, '.local', 'state');\n  }\n\n  return null;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveXdgStateDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "resolveXdgStateDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/paths.ts",
        "start_line": 30,
        "end_line": 36,
        "content": "function resolveEntryDir() {\n  const entryCandidate = process.argv[1] || require.main?.filename;\n  if (!entryCandidate) {\n    return null;\n  }\n  return path.dirname(entryCandidate);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveEntryDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "resolveEntryDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/paths.ts",
        "start_line": 38,
        "end_line": 50,
        "content": "function resolveProfileBaseDir() {\n  if (process.env.MCP_PROFILES_DIR) {\n    return path.resolve(process.env.MCP_PROFILES_DIR);\n  }\n\n  const xdgStateDir = resolveXdgStateDir();\n  if (xdgStateDir) {\n    return path.join(xdgStateDir, 'sentryfrogg');\n  }\n\n  const entryDir = resolveEntryDir();\n  return entryDir || process.cwd();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveProfileBaseDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 82,
          "qualified_name": "resolveProfileBaseDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/paths.ts",
        "start_line": 52,
        "end_line": 58,
        "content": "function resolveProfileKeyPath() {\n  if (process.env.MCP_PROFILE_KEY_PATH) {\n    return path.resolve(process.env.MCP_PROFILE_KEY_PATH);\n  }\n\n  return path.join(resolveProfileBaseDir(), '.mcp_profiles.key');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveProfileKeyPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 52,
          "qualified_name": "resolveProfileKeyPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/redact.ts": [
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 32,
        "end_line": 34,
        "content": "function normalizeKey(key) {\n  return String(key || '').toLowerCase();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 18,
          "qualified_name": "normalizeKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 36,
        "end_line": 51,
        "content": "function isSensitiveKey(key) {\n  const normalized = normalizeKey(key);\n  if (!normalized) {\n    return false;\n  }\n\n  if (SENSITIVE_KEYS.includes(normalized)) {\n    return true;\n  }\n\n  if (normalized.includes('secret') || normalized.includes('token')) {\n    return true;\n  }\n\n  return false;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "isSensitiveKey",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 73,
          "qualified_name": "isSensitiveKey",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 53,
        "end_line": 61,
        "content": "function truncateString(value, maxLength) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.length <= maxLength) {\n    return value;\n  }\n  return `${value.slice(0, maxLength)}...`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "truncateString",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 50,
          "qualified_name": "truncateString",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 63,
        "end_line": 78,
        "content": "function redactHeaders(headers, options) {\n  if (!headers || typeof headers !== 'object' || Array.isArray(headers)) {\n    return headers;\n  }\n\n  const result = {};\n  for (const [key, value] of Object.entries(headers)) {\n    const normalized = normalizeKey(key);\n    if (SENSITIVE_HEADER_KEYS.includes(normalized)) {\n      result[key] = options.redaction;\n    } else {\n      result[key] = truncateString(String(value), options.maxString);\n    }\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "redactHeaders",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 116,
          "qualified_name": "redactHeaders",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 80,
        "end_line": 89,
        "content": "function redactMapValues(map, options) {\n  if (!map || typeof map !== 'object' || Array.isArray(map)) {\n    return map;\n  }\n  const result = {};\n  for (const [key] of Object.entries(map)) {\n    result[key] = options.redaction;\n  }\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "redactMapValues",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "redactMapValues",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/redact.ts",
        "start_line": 91,
        "end_line": 144,
        "content": "function redactObject(value, options = {}, seen = new WeakSet()) {\n  const config = {\n    redaction: options.redaction || DEFAULT_REDACTION,\n    maxString: Number.isFinite(options.maxString) ? options.maxString : DEFAULT_MAX_STRING,\n  };\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return truncateString(value, config.maxString);\n  }\n\n  if (typeof value !== 'object') {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return `[buffer:${value.length}]`;\n  }\n\n  if (seen.has(value)) {\n    return '[circular]';\n  }\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.map((item) => redactObject(item, config, seen));\n  }\n\n  const result = {};\n  for (const [key, raw] of Object.entries(value)) {\n    if (key === 'headers') {\n      result[key] = redactHeaders(raw, config);\n      continue;\n    }\n\n    const normalizedKey = normalizeKey(key);\n    if (normalizedKey === 'env' || normalizedKey === 'variables') {\n      result[key] = redactMapValues(raw, config);\n      continue;\n    }\n\n    if (isSensitiveKey(key)) {\n      result[key] = config.redaction;\n      continue;\n    }\n\n    result[key] = redactObject(raw, config, seen);\n  }\n\n  return result;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "redactObject",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 308,
          "qualified_name": "redactObject",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/runbookDsl.ts": [
      {
        "file_path": "src/utils/runbookDsl.ts",
        "start_line": 6,
        "end_line": 33,
        "content": "function parseValue(raw) {\n  const trimmed = String(raw || '').trim();\n  if (!trimmed) {\n    return '';\n  }\n\n  if (trimmed === 'true' || trimmed === 'false' || trimmed === 'null') {\n    return JSON.parse(trimmed);\n  }\n\n  if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n    return Number(trimmed);\n  }\n\n  if (\n    (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n    (trimmed.startsWith('[') && trimmed.endsWith(']')) ||\n    (trimmed.startsWith('\"') && trimmed.endsWith('\"'))\n  ) {\n    try {\n      return JSON.parse(trimmed);\n    } catch (error) {\n      return trimmed;\n    }\n  }\n\n  return trimmed;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 148,
          "qualified_name": "parseValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/runbookDsl.ts",
        "start_line": 35,
        "end_line": 49,
        "content": "function setPath(target, path, value) {\n  const parts = path.split('.').map((part) => part.trim()).filter(Boolean);\n  if (parts.length === 0) {\n    return;\n  }\n  let current = target;\n  for (let idx = 0; idx < parts.length - 1; idx += 1) {\n    const key = parts[idx];\n    if (!isPlainObject(current[key])) {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n  current[parts[parts.length - 1]] = value;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "setPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 104,
          "qualified_name": "setPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/runbookDsl.ts",
        "start_line": 51,
        "end_line": 63,
        "content": "function parseKeyValue(raw) {\n  const trimmed = String(raw || '').trim();\n  const eqIndex = trimmed.indexOf('=');\n  if (eqIndex === -1) {\n    throw new Error('arg directive requires key=value');\n  }\n  const key = trimmed.slice(0, eqIndex).trim();\n  const valueRaw = trimmed.slice(eqIndex + 1).trim();\n  if (!key) {\n    throw new Error('arg directive requires key=value');\n  }\n  return { key, value: parseValue(valueRaw) };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseKeyValue",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 106,
          "qualified_name": "parseKeyValue",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/runbookDsl.ts",
        "start_line": 65,
        "end_line": 179,
        "content": "function parseRunbookDsl(dsl) {\n  const runbook = { steps: [] };\n  const lines = String(dsl || '').split(/\\r?\\n/);\n  let current = null;\n\n  for (let lineIndex = 0; lineIndex < lines.length; lineIndex += 1) {\n    const rawLine = lines[lineIndex];\n    const trimmed = rawLine.trim();\n    if (!trimmed) {\n      continue;\n    }\n    if (trimmed.startsWith('#') || trimmed.startsWith('//')) {\n      continue;\n    }\n\n    const spaceIndex = trimmed.indexOf(' ');\n    const directive = spaceIndex === -1 ? trimmed : trimmed.slice(0, spaceIndex);\n    const rest = spaceIndex === -1 ? '' : trimmed.slice(spaceIndex + 1).trim();\n\n    switch (directive) {\n      case 'runbook':\n        runbook.name = rest;\n        break;\n      case 'description':\n        runbook.description = rest;\n        break;\n      case 'step': {\n        const tokens = rest.split(/\\s+/).filter(Boolean);\n        const id = tokens.shift();\n        const tool = tokens.shift();\n        const action = tokens.shift();\n        if (!id || !tool) {\n          throw new Error(`step requires id and tool at line ${lineIndex + 1}`);\n        }\n        const step = { id, tool, args: {} };\n        if (action) {\n          step.args.action = action;\n        }\n        if (tokens.length > 0) {\n          const parsed = parseValue(tokens.join(' '));\n          if (isPlainObject(parsed)) {\n            step.args = mergeDeep(step.args, parsed);\n          }\n        }\n        runbook.steps.push(step);\n        current = step;\n        break;\n      }\n      case 'tool':\n        if (!current) {\n          throw new Error(`tool directive before step at line ${lineIndex + 1}`);\n        }\n        current.tool = rest;\n        break;\n      case 'action':\n        if (!current) {\n          throw new Error(`action directive before step at line ${lineIndex + 1}`);\n        }\n        current.args = current.args || {};\n        current.args.action = rest;\n        break;\n      case 'args': {\n        if (!current) {\n          throw new Error(`args directive before step at line ${lineIndex + 1}`);\n        }\n        const parsed = parseValue(rest);\n        if (!isPlainObject(parsed)) {\n          throw new Error(`args directive expects JSON object at line ${lineIndex + 1}`);\n        }\n        current.args = mergeDeep(current.args || {}, parsed);\n        break;\n      }\n      case 'arg': {\n        if (!current) {\n          throw new Error(`arg directive before step at line ${lineIndex + 1}`);\n        }\n        const { key, value } = parseKeyValue(rest);\n        current.args = current.args || {};\n        setPath(current.args, key, value);\n        break;\n      }\n      case 'when': {\n        if (!current) {\n          throw new Error(`when directive before step at line ${lineIndex + 1}`);\n        }\n        const parsed = parseValue(rest);\n        current.when = parsed;\n        break;\n      }\n      case 'foreach': {\n        if (!current) {\n          throw new Error(`foreach directive before step at line ${lineIndex + 1}`);\n        }\n        const parsed = parseValue(rest);\n        current.foreach = parsed;\n        break;\n      }\n      case 'continue_on_error': {\n        if (!current) {\n          throw new Error(`continue_on_error directive before step at line ${lineIndex + 1}`);\n        }\n        current.continue_on_error = parseValue(rest) === true;\n        break;\n      }\n      default:\n        throw new Error(`Unknown DSL directive '${directive}' at line ${lineIndex + 1}`);\n    }\n  }\n\n  if (!Array.isArray(runbook.steps) || runbook.steps.length === 0) {\n    throw new Error('runbook DSL must define at least one step');\n  }\n\n  return runbook;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseRunbookDsl",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 899,
          "qualified_name": "parseRunbookDsl",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/sandbox.ts": [
      {
        "file_path": "src/utils/sandbox.ts",
        "start_line": 7,
        "end_line": 14,
        "content": "function ensureInsideRoot(root, candidate) {\n  if (candidate === root) {\n    return;\n  }\n  if (!candidate.startsWith(`${root}${path.sep}`)) {\n    throw new Error('Path escapes sandbox root');\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "ensureInsideRoot",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 49,
          "qualified_name": "ensureInsideRoot",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/sandbox.ts",
        "start_line": 16,
        "end_line": 43,
        "content": "async function resolveSandboxPath(rootDir, candidatePath, options = {}) {\n  if (typeof rootDir !== 'string' || rootDir.trim().length === 0) {\n    throw new Error('rootDir must be a non-empty string');\n  }\n\n  const mustExist = options.mustExist !== false;\n  const rootReal = await fs.realpath(rootDir);\n\n  if (!candidatePath) {\n    return rootReal;\n  }\n\n  const resolved = path.resolve(rootReal, String(candidatePath));\n  ensureInsideRoot(rootReal, resolved);\n\n  if (mustExist) {\n    const real = await fs.realpath(resolved);\n    ensureInsideRoot(rootReal, real);\n    return real;\n  }\n\n  const parent = path.dirname(resolved);\n  const parentReal = await fs.realpath(parent);\n  ensureInsideRoot(rootReal, parentReal);\n  const final = path.join(parentReal, path.basename(resolved));\n  ensureInsideRoot(rootReal, final);\n  return final;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveSandboxPath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 208,
          "qualified_name": "resolveSandboxPath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/sql.ts": [
      {
        "file_path": "src/utils/sql.ts",
        "start_line": 4,
        "end_line": 16,
        "content": "function normalizeIdentifierPart(value) {\n  const trimmed = String(value ?? '').trim();\n  if (!trimmed) {\n    throw new Error('Identifier must be a non-empty string');\n  }\n  if (trimmed.includes('\\0')) {\n    throw new Error('Identifier must not contain null bytes');\n  }\n  const unquoted = trimmed.startsWith('\"') && trimmed.endsWith('\"')\n    ? trimmed.slice(1, -1)\n    : trimmed;\n  return `\"${unquoted.replace(/\"/g, '\"\"')}\"`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeIdentifierPart",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 110,
          "qualified_name": "normalizeIdentifierPart",
          "documentation": "// @ts-nocheck",
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/sql.ts",
        "start_line": 18,
        "end_line": 24,
        "content": "function quoteQualifiedIdentifier(identifier) {\n  const parts = String(identifier ?? '').split('.');\n  if (parts.length === 0) {\n    throw new Error('Identifier must be a non-empty string');\n  }\n  return parts.map(normalizeIdentifierPart).join('.');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "quoteQualifiedIdentifier",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 62,
          "qualified_name": "quoteQualifiedIdentifier",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/sql.ts",
        "start_line": 26,
        "end_line": 46,
        "content": "function normalizeTableContext(tableName, schemaName) {\n  if (!tableName) {\n    throw new Error('Table name is required');\n  }\n\n  if (schemaName) {\n    const schema = String(schemaName);\n    const table = String(tableName);\n    return {\n      schema,\n      table,\n      qualified: `${normalizeIdentifierPart(schema)}.${normalizeIdentifierPart(table)}`,\n    };\n  }\n\n  return {\n    schema: undefined,\n    table: String(tableName),\n    qualified: quoteQualifiedIdentifier(tableName),\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeTableContext",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 121,
          "qualified_name": "normalizeTableContext",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/sql.ts",
        "start_line": 48,
        "end_line": 106,
        "content": "function buildFiltersClause(filters, startIndex = 1) {\n  const clauses = [];\n  const values = [];\n  let index = startIndex;\n\n  const addValue = (value) => {\n    values.push(value);\n    const placeholder = `$${index}`;\n    index += 1;\n    return placeholder;\n  };\n\n  const normalizeOperator = (op) => String(op || '=').trim().toUpperCase();\n\n  const pushFilter = (column, op, value) => {\n    const columnSql = quoteQualifiedIdentifier(column);\n    const operator = normalizeOperator(op);\n\n    if (value === null) {\n      if (operator === '!=' || operator === '<>') {\n        clauses.push(`${columnSql} IS NOT NULL`);\n        return;\n      }\n      clauses.push(`${columnSql} IS NULL`);\n      return;\n    }\n\n    if (operator === 'IN' || operator === 'NOT IN') {\n      if (!Array.isArray(value) || value.length === 0) {\n        throw new Error(`${operator} filter requires a non-empty array`);\n      }\n      const placeholders = value.map((entry) => addValue(entry)).join(', ');\n      clauses.push(`${columnSql} ${operator} (${placeholders})`);\n      return;\n    }\n\n    const placeholder = addValue(value);\n    clauses.push(`${columnSql} ${operator} ${placeholder}`);\n  };\n\n  if (Array.isArray(filters)) {\n    for (const item of filters) {\n      if (!item || typeof item !== 'object') {\n        throw new Error('Filter item must be an object');\n      }\n      pushFilter(item.column ?? item.field, item.op, item.value);\n    }\n  } else if (filters && typeof filters === 'object') {\n    for (const [column, value] of Object.entries(filters)) {\n      pushFilter(column, '=', value);\n    }\n  }\n\n  return {\n    clause: clauses.join(' AND '),\n    params: values,\n    nextIndex: index,\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildFiltersClause",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 420,
          "qualified_name": "buildFiltersClause",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/sql.ts",
        "start_line": 108,
        "end_line": 122,
        "content": "function buildWhereClause({ filters, whereSql, whereParams, startIndex = 1 } = {}) {\n  if (whereSql) {\n    return {\n      clause: String(whereSql),\n      params: Array.isArray(whereParams) ? whereParams : [],\n      nextIndex: startIndex + (Array.isArray(whereParams) ? whereParams.length : 0),\n    };\n  }\n\n  if (filters) {\n    return buildFiltersClause(filters, startIndex);\n  }\n\n  return { clause: '', params: [], nextIndex: startIndex };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildWhereClause",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 110,
          "qualified_name": "buildWhereClause",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/storeLayout.ts": [
      {
        "file_path": "src/utils/storeLayout.ts",
        "start_line": 25,
        "end_line": 33,
        "content": "function buildStorePaths(baseDir) {\n  if (!baseDir) {\n    return [];\n  }\n  return STORE_ITEMS.map((item) => ({\n    ...item,\n    path: path.join(baseDir, item.relative),\n  }));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "buildStorePaths",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 44,
          "qualified_name": "buildStorePaths",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/template.ts": [
      {
        "file_path": "src/utils/template.ts",
        "start_line": 6,
        "end_line": 15,
        "content": "function normalizeExpression(expression) {\n  const trimmed = String(expression || '').trim();\n  if (!trimmed) {\n    return { path: '', optional: false };\n  }\n  if (trimmed.startsWith('?')) {\n    return { path: trimmed.slice(1).trim(), optional: true };\n  }\n  return { path: trimmed, optional: false };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "normalizeExpression",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 75,
          "qualified_name": "normalizeExpression",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/template.ts",
        "start_line": 17,
        "end_line": 38,
        "content": "function resolveExpression(expression, context, { missing = 'error' } = {}) {\n  const { path, optional } = normalizeExpression(expression);\n  if (!path) {\n    return { value: '', found: false };\n  }\n\n  try {\n    const value = getPathValue(context, path, { required: true });\n    return { value, found: true };\n  } catch (error) {\n    if (optional || missing === 'empty') {\n      return { value: '', found: false };\n    }\n    if (missing === 'null') {\n      return { value: null, found: false };\n    }\n    if (missing === 'undefined') {\n      return { value: undefined, found: false };\n    }\n    throw error;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveExpression",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 153,
          "qualified_name": "resolveExpression",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/template.ts",
        "start_line": 40,
        "end_line": 51,
        "content": "function stringifyResolved(value) {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n  return JSON.stringify(value);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "stringifyResolved",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 71,
          "qualified_name": "stringifyResolved",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/template.ts",
        "start_line": 53,
        "end_line": 67,
        "content": "function resolveTemplateString(template, context, options = {}) {\n  const raw = String(template);\n  const tokenRegex = /{{\\s*([^}]+)\\s*}}/g;\n  const exactMatch = raw.match(/^{{\\s*([^}]+)\\s*}}$/);\n\n  if (exactMatch) {\n    const { value } = resolveExpression(exactMatch[1], context, options);\n    return value;\n  }\n\n  return raw.replace(tokenRegex, (_, expr) => {\n    const { value } = resolveExpression(expr, context, options);\n    return stringifyResolved(value);\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveTemplateString",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 117,
          "qualified_name": "resolveTemplateString",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/template.ts",
        "start_line": 69,
        "end_line": 87,
        "content": "function resolveTemplates(value, context, options = {}) {\n  if (Array.isArray(value)) {\n    return value.map((item) => resolveTemplates(item, context, options));\n  }\n\n  if (value && typeof value === 'object') {\n    const resolved = {};\n    for (const [key, entry] of Object.entries(value)) {\n      resolved[key] = resolveTemplates(entry, context, options);\n    }\n    return resolved;\n  }\n\n  if (typeof value === 'string') {\n    return resolveTemplateString(value, context, options);\n  }\n\n  return value;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveTemplates",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 126,
          "qualified_name": "resolveTemplates",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/userPaths.ts": [
      {
        "file_path": "src/utils/userPaths.ts",
        "start_line": 7,
        "end_line": 19,
        "content": "function resolveHomeDir() {\n  const homeFromEnv = process.env.HOME;\n  if (homeFromEnv && typeof homeFromEnv === 'string' && homeFromEnv.trim().length > 0) {\n    return homeFromEnv;\n  }\n\n  try {\n    const home = os.homedir();\n    return home && typeof home === 'string' ? home : null;\n  } catch (error) {\n    return null;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "resolveHomeDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 81,
          "qualified_name": "resolveHomeDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/userPaths.ts",
        "start_line": 21,
        "end_line": 40,
        "content": "function expandHomePath(value) {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  const raw = String(value);\n  if (raw === '~') {\n    return resolveHomeDir() || raw;\n  }\n\n  if (raw.startsWith('~/') || raw.startsWith('~\\\\')) {\n    const home = resolveHomeDir();\n    if (!home) {\n      return raw;\n    }\n    return path.join(home, raw.slice(2));\n  }\n\n  return raw;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "expandHomePath",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 96,
          "qualified_name": "expandHomePath",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "src/utils/whenMatcher.ts": [
      {
        "file_path": "src/utils/whenMatcher.ts",
        "start_line": 11,
        "end_line": 24,
        "content": "async function fileExists(root, candidate, cache) {\n  if (!root || !candidate) {\n    return false;\n  }\n  if (cache && Object.prototype.hasOwnProperty.call(cache, candidate)) {\n    return cache[candidate];\n  }\n  const full = path.isAbsolute(candidate) ? candidate : path.join(root, candidate);\n  const exists = await pathExists(full).catch(() => false);\n  if (cache) {\n    cache[candidate] = exists;\n  }\n  return exists;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "fileExists",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 105,
          "qualified_name": "fileExists",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/whenMatcher.ts",
        "start_line": 26,
        "end_line": 29,
        "content": "function matchTags(tags = [], contextTags = []) {\n  const tagSet = new Set(contextTags || []);\n  return (tags || []).filter((tag) => tagSet.has(tag));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "matchTags",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 38,
          "qualified_name": "matchTags",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "src/utils/whenMatcher.ts",
        "start_line": 31,
        "end_line": 102,
        "content": "async function matchesWhen(when, context = {}) {\n  if (!when) {\n    return true;\n  }\n  if (typeof when !== 'object' || Array.isArray(when)) {\n    return false;\n  }\n\n  const tags = new Set(context.tags || []);\n  const filesCache = { ...(context.files || {}) };\n  const root = context.root;\n\n  const matchList = (list, predicate) => Array.isArray(list) ? predicate(list) : true;\n  const all = async (list) => {\n    for (const entry of list) {\n      if (!await matchesWhen(entry, context)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const any = async (list) => {\n    for (const entry of list) {\n      if (await matchesWhen(entry, context)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  if (Array.isArray(when.all_of) && !(await all(when.all_of))) {\n    return false;\n  }\n  if (Array.isArray(when.any_of) && !(await any(when.any_of))) {\n    return false;\n  }\n  if (when.not && await matchesWhen(when.not, context)) {\n    return false;\n  }\n\n  const tagsAny = matchList(when.tags_any, (list) => list.some((tag) => tags.has(tag)));\n  if (!tagsAny) {\n    return false;\n  }\n  const tagsAll = matchList(when.tags_all, (list) => list.every((tag) => tags.has(tag)));\n  if (!tagsAll) {\n    return false;\n  }\n\n  if (Array.isArray(when.files_any) && when.files_any.length > 0) {\n    let hit = false;\n    for (const entry of when.files_any) {\n      if (await fileExists(root, entry, filesCache)) {\n        hit = true;\n        break;\n      }\n    }\n    if (!hit) {\n      return false;\n    }\n  }\n\n  if (Array.isArray(when.files_all) && when.files_all.length > 0) {\n    for (const entry of when.files_all) {\n      if (!await fileExists(root, entry, filesCache)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "matchesWhen",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 434,
          "qualified_name": "matchesWhen",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/alias.test.ts": [
      {
        "file_path": "tests/alias.test.ts",
        "start_line": 20,
        "end_line": 22,
        "content": "function createTempDir() {\n  return fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-alias-'));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 23,
          "qualified_name": "createTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/api-manager.test.ts": [
      {
        "file_path": "tests/api-manager.test.ts",
        "start_line": 1,
        "end_line": 98,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst APIManager = require('../src/managers/APIManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  error() {},\n  warn() {},\n  info() {},\n};\n\nconst securityStub = {\n  ensureUrl(url) {\n    return new URL(url);\n  },\n};\n\nconst validationStub = {\n  ensureHeaders(headers) {\n    return headers ?? {};\n  },\n  ensureString(value) {\n    return value;\n  },\n};\n\nconst profileServiceStub = () => ({\n  async getProfile() {\n    return { data: {}, secrets: {} };\n  },\n  async listProfiles() {\n    return [];\n  },\n  async setProfile() {},\n  async deleteProfile() {},\n});\n\nconst createHeaders = (items) => ({\n  get(key) {\n    const found = items.find(([name]) => name.toLowerCase() === key.toLowerCase());\n    return found ? found[1] : undefined;\n  },\n  entries() {\n    return items[Symbol.iterator]();\n  },\n});\n\ntest('APIManager preserves string payloads without double encoding', async () => {\n  let captured;\n  const fetchStub = async (url, options) => {\n    captured = { url, options };\n    return {\n      ok: true,\n      status: 200,\n      statusText: 'OK',\n      headers: createHeaders([['content-type', 'text/plain']]),\n      text: async () => 'pong',\n    };\n  };\n\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n  const result = await manager.request({ method: 'POST', url: 'https://example.com', body: 'ping' });\n\n  assert.equal(captured.options.body, 'ping');\n  assert.equal(captured.options.headers['Content-Type'], 'text/plain; charset=utf-8');\n  assert.equal(result.data, 'pong');\n});\n\ntest('APIManager respects custom headers and sets bearer auth', async () => {\n  let capturedHeaders;\n  const fetchStub = async (_url, options) => {\n    capturedHeaders = options.headers;\n    return {\n      ok: true,\n      status: 201,\n      statusText: 'Created',\n      headers: createHeaders([['content-type', 'application/json']]),\n      json: async () => ({ echoed: options.body }),\n    };\n  };\n\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n  const result = await manager.request({\n    method: 'PUT',\n    url: 'https://example.com',\n    body: { status: 'ok' },\n    headers: { 'Content-Type': 'application/vnd.custom+json' },\n    auth: { type: 'bearer', token: 'secret' },\n  });\n\n  assert.equal(result.status, 201);\n  assert.equal(result.data.echoed, JSON.stringify({ status: 'ok' }));\n  assert.equal(capturedHeaders['Content-Type'], 'application/vnd.custom+json');\n  assert.equal(capturedHeaders.Authorization, 'Bearer secret');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 672,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/api-secretref.test.ts": [
      {
        "file_path": "tests/api-secretref.test.ts",
        "start_line": 1,
        "end_line": 95,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst APIManager = require('../src/managers/APIManager');\nconst SecretRefResolver = require('../src/services/SecretRefResolver');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  error() {},\n  warn() {},\n  info() {},\n};\n\nconst securityStub = {\n  ensureUrl(url) {\n    return new URL(url);\n  },\n};\n\nconst validationStub = {\n  ensureHeaders(headers) {\n    return headers ?? {};\n  },\n  ensureString(value) {\n    return value;\n  },\n};\n\ntest('APIManager resolves SecretRefs inside resolved profile auth/auth_provider', async (t) => {\n  const prevToken = process.env.SF_API_TOKEN;\n  const prevSecret = process.env.SF_API_CLIENT_SECRET;\n  process.env.SF_API_TOKEN = 'token';\n  process.env.SF_API_CLIENT_SECRET = 'shh';\n\n  t.after(() => {\n    if (prevToken === undefined) {\n      delete process.env.SF_API_TOKEN;\n    } else {\n      process.env.SF_API_TOKEN = prevToken;\n    }\n    if (prevSecret === undefined) {\n      delete process.env.SF_API_CLIENT_SECRET;\n    } else {\n      process.env.SF_API_CLIENT_SECRET = prevSecret;\n    }\n  });\n\n  const profileServiceStub = {\n    async getProfile() {\n      return {\n        data: {\n          auth: { type: 'bearer' },\n          auth_provider: { type: 'oauth2', token_url: 'https://idp/token', client_id: 'cid' },\n        },\n        secrets: {\n          auth_token: 'ref:env:SF_API_TOKEN',\n          auth_provider_client_secret: 'ref:env:SF_API_CLIENT_SECRET',\n        },\n      };\n    },\n    async listProfiles() {\n      return [];\n    },\n  };\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, { ensureString: (v) => v }, null, null, null);\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub, null, { secretRefResolver });\n\n  const profile = await manager.resolveProfile('api1', {});\n  assert.equal(profile.auth.token, 'token');\n  assert.equal(profile.authProvider.client_secret, 'shh');\n});\n\ntest('APIManager resolves SecretRefs inside auth_provider (static token)', async (t) => {\n  const prevToken = process.env.SF_API_TOKEN;\n  process.env.SF_API_TOKEN = 'token';\n\n  t.after(() => {\n    if (prevToken === undefined) {\n      delete process.env.SF_API_TOKEN;\n    } else {\n      process.env.SF_API_TOKEN = prevToken;\n    }\n  });\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, { ensureString: (v) => v }, null, null, null);\n  const manager = new APIManager(loggerStub, securityStub, validationStub, { async listProfiles() { return []; } }, null, { secretRefResolver });\n\n  const auth = await manager.resolveAuthProvider({ type: 'static', token: 'ref:env:SF_API_TOKEN' }, 'inline', {});\n  assert.deepEqual(auth, { type: 'bearer', token: 'token' });\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 690,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/api-stream-to-artifact.test.ts": [
      {
        "file_path": "tests/api-stream-to-artifact.test.ts",
        "start_line": 56,
        "end_line": 62,
        "content": "function restoreEnv(key, previous) {\n  if (previous === undefined) {\n    delete process.env[key];\n  } else {\n    process.env[key] = previous;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "restoreEnv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "restoreEnv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/artifact-manager.test.ts": [
      {
        "file_path": "tests/artifact-manager.test.ts",
        "start_line": 1,
        "end_line": 67,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst crypto = require('node:crypto');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst ArtifactManager = require('../src/managers/ArtifactManager');\nconst ToolError = require('../src/errors/ToolError');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('ArtifactManager list/get/head/tail work with bounded reads', async (t) => {\n  const contextRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-artifacts-'));\n  const prevRoot = process.env.SF_CONTEXT_REPO_ROOT;\n  process.env.SF_CONTEXT_REPO_ROOT = contextRoot;\n\n  t.after(async () => {\n    if (prevRoot === undefined) {\n      delete process.env.SF_CONTEXT_REPO_ROOT;\n    } else {\n      process.env.SF_CONTEXT_REPO_ROOT = prevRoot;\n    }\n    await fs.rm(contextRoot, { recursive: true, force: true });\n  });\n\n  const manager = new ArtifactManager(loggerStub, {});\n  const prefix = `test-artifact-manager/${crypto.randomUUID()}`;\n  const rel = `${prefix}/sample.txt`;\n  const filePath = path.join(contextRoot, 'artifacts', rel);\n\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\n  const content = 'hello world\\nsecond line\\nthird line\\n';\n  await fs.writeFile(filePath, content, 'utf8');\n\n  const listed = await manager.handleAction({ action: 'list', prefix, limit: 50 });\n  assert.equal(listed.success, true);\n  assert.ok(listed.items.some((item) => item.rel === rel));\n\n  const head = await manager.handleAction({ action: 'head', rel, max_bytes: 5 });\n  assert.equal(head.success, true);\n  assert.equal(head.content, 'hello');\n  assert.equal(head.truncated, true);\n\n  const tail = await manager.handleAction({ action: 'tail', rel, max_bytes: 5 });\n  assert.equal(tail.success, true);\n  assert.equal(tail.content, 'line\\n');\n  assert.equal(tail.truncated, true);\n\n  const slice = await manager.handleAction({ action: 'get', rel, offset: 6, max_bytes: 5 });\n  assert.equal(slice.success, true);\n  assert.equal(slice.content, 'world');\n  assert.equal(slice.truncated, true);\n\n  await assert.rejects(\n    () => manager.handleAction({ action: 'get', rel: `${prefix}/missing.txt` }),\n    (error) => ToolError.isToolError(error) && error.kind === 'not_found'\n  );\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 586,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/artifacts.test.ts": [
      {
        "file_path": "tests/artifacts.test.ts",
        "start_line": 1,
        "end_line": 63,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst {\n  buildToolCallContextRef,\n  buildToolCallFileRef,\n  resolveArtifactPath,\n  writeTextArtifact,\n  writeBinaryArtifact,\n} = require('../src/utils/artifacts');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('artifacts writes tool call context and files under contextRoot/artifacts', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-artifacts-'));\n  t.after(async () => {\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const ctxRef = buildToolCallContextRef({ traceId: 'trace-1', spanId: 'span-1' });\n  assert.equal(ctxRef.uri, 'artifact://runs/trace-1/tool_calls/span-1.context');\n\n  const ctxWrite = await writeTextArtifact(tmpRoot, ctxRef, 'hello\\n');\n  assert.equal(ctxWrite.uri, ctxRef.uri);\n  assert.ok(ctxWrite.path.endsWith(path.join('artifacts', 'runs', 'trace-1', 'tool_calls', 'span-1.context')));\n  assert.equal(await fs.readFile(ctxWrite.path, 'utf8'), 'hello\\n');\n\n  const fileRef = buildToolCallFileRef({ traceId: 'trace-1', spanId: 'span-1', filename: 'diff.patch' });\n  assert.equal(fileRef.uri, 'artifact://runs/trace-1/tool_calls/span-1/diff.patch');\n  const fileWrite = await writeBinaryArtifact(tmpRoot, fileRef, Buffer.from('patch\\n'));\n  assert.equal(await fs.readFile(fileWrite.path, 'utf8'), 'patch\\n');\n\n  const resolved = resolveArtifactPath(tmpRoot, 'runs/trace-1/tool_calls/span-1/diff.patch');\n  assert.equal(resolved, fileWrite.path);\n});\n\ntest('artifacts rejects traversal in segments/filenames', async () => {\n  assert.throws(() => buildToolCallFileRef({ traceId: '..', spanId: 'x', filename: 'a.txt' }));\n  assert.throws(() => buildToolCallFileRef({ traceId: 'x', spanId: '../y', filename: 'a.txt' }));\n  assert.throws(() => buildToolCallFileRef({ traceId: 'x', spanId: 'y', filename: '../a.txt' }));\n  assert.throws(() => buildToolCallFileRef({ traceId: 'x', spanId: 'y', filename: 'a/b.txt' }));\n  assert.throws(() => buildToolCallFileRef({ traceId: 'x', spanId: 'y', filename: 'a\\\\b.txt' }));\n});\n\ntest('artifacts rejects resolved path escapes', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-artifacts-'));\n  t.after(async () => {\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  assert.throws(() => resolveArtifactPath(tmpRoot, '../evil.txt'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 642,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/audit.test.ts": [
      {
        "file_path": "tests/audit.test.ts",
        "start_line": 20,
        "end_line": 22,
        "content": "function createTempDir() {\n  return fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-audit-'));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 23,
          "qualified_name": "createTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/bounded-output-spill.test.ts": [
      {
        "file_path": "tests/bounded-output-spill.test.ts",
        "start_line": 1,
        "end_line": 177,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst ToolExecutor = require('../src/services/ToolExecutor');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst stateStub = {\n  async set() {},\n};\n\ntest('ToolExecutor spills large strings into artifact placeholders', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-spill-'));\n  const prevRoot = process.env.SF_CONTEXT_REPO_ROOT;\n  const prevInline = process.env.SF_MAX_INLINE_BYTES;\n  const prevCapture = process.env.SF_MAX_CAPTURE_BYTES;\n  const prevMaxSpills = process.env.SF_MAX_SPILLS;\n\n  process.env.SF_CONTEXT_REPO_ROOT = tmpRoot;\n  process.env.SF_MAX_INLINE_BYTES = '128';\n  process.env.SF_MAX_CAPTURE_BYTES = '1024';\n  process.env.SF_MAX_SPILLS = '5';\n\n  t.after(async () => {\n    if (prevRoot === undefined) {\n      delete process.env.SF_CONTEXT_REPO_ROOT;\n    } else {\n      process.env.SF_CONTEXT_REPO_ROOT = prevRoot;\n    }\n    if (prevInline === undefined) {\n      delete process.env.SF_MAX_INLINE_BYTES;\n    } else {\n      process.env.SF_MAX_INLINE_BYTES = prevInline;\n    }\n    if (prevCapture === undefined) {\n      delete process.env.SF_MAX_CAPTURE_BYTES;\n    } else {\n      process.env.SF_MAX_CAPTURE_BYTES = prevCapture;\n    }\n    if (prevMaxSpills === undefined) {\n      delete process.env.SF_MAX_SPILLS;\n    } else {\n      process.env.SF_MAX_SPILLS = prevMaxSpills;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const executor = new ToolExecutor(loggerStub, stateStub, null, null, null, {});\n  const traceId = 'trace-1';\n  const spanId = 'span-1';\n  const payload = await executor.wrapResult({\n    tool: 'mcp_test',\n    args: { trace_id: traceId, span_id: spanId },\n    result: { big: 'a'.repeat(10_000) },\n    startedAt: Date.now(),\n    traceId,\n    spanId,\n  });\n\n  assert.equal(payload.ok, true);\n  assert.equal(payload.result.big.truncated, true);\n  assert.ok(payload.result.big.bytes > 1024);\n  assert.ok(payload.result.big.sha256);\n  assert.ok(payload.result.big.preview);\n  assert.ok(payload.result.big.artifact);\n  assert.ok(payload.result.big.artifact.uri.startsWith('artifact://runs/trace-1/tool_calls/span-1/'));\n\n  const rel = payload.result.big.artifact.rel;\n  const artifactPath = path.join(tmpRoot, 'artifacts', rel);\n  const written = await fs.readFile(artifactPath, 'utf8');\n  assert.ok(Buffer.byteLength(written, 'utf8') <= 1024);\n});\n\ntest('ToolExecutor does not spill sensitive keys to artifacts', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-spill-sensitive-'));\n  const prevRoot = process.env.SF_CONTEXT_REPO_ROOT;\n  const prevInline = process.env.SF_MAX_INLINE_BYTES;\n  const prevCapture = process.env.SF_MAX_CAPTURE_BYTES;\n\n  process.env.SF_CONTEXT_REPO_ROOT = tmpRoot;\n  process.env.SF_MAX_INLINE_BYTES = '64';\n  process.env.SF_MAX_CAPTURE_BYTES = '256';\n\n  t.after(async () => {\n    if (prevRoot === undefined) {\n      delete process.env.SF_CONTEXT_REPO_ROOT;\n    } else {\n      process.env.SF_CONTEXT_REPO_ROOT = prevRoot;\n    }\n    if (prevInline === undefined) {\n      delete process.env.SF_MAX_INLINE_BYTES;\n    } else {\n      process.env.SF_MAX_INLINE_BYTES = prevInline;\n    }\n    if (prevCapture === undefined) {\n      delete process.env.SF_MAX_CAPTURE_BYTES;\n    } else {\n      process.env.SF_MAX_CAPTURE_BYTES = prevCapture;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const executor = new ToolExecutor(loggerStub, stateStub, null, null, null, {});\n  const payload = await executor.wrapResult({\n    tool: 'mcp_test',\n    args: { trace_id: 'trace-2', span_id: 'span-2' },\n    result: { token: 'a'.repeat(10_000) },\n    startedAt: Date.now(),\n    traceId: 'trace-2',\n    spanId: 'span-2',\n  });\n\n  assert.equal(payload.ok, true);\n  assert.equal(payload.result.token.truncated, true);\n  assert.equal(payload.result.token.artifact, null);\n});\n\ntest('ToolExecutor reuses existing *_ref for *_buffer spill placeholders', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-spill-buffer-'));\n  const prevRoot = process.env.SF_CONTEXT_REPO_ROOT;\n  const prevInline = process.env.SF_MAX_INLINE_BYTES;\n  const prevCapture = process.env.SF_MAX_CAPTURE_BYTES;\n\n  process.env.SF_CONTEXT_REPO_ROOT = tmpRoot;\n  process.env.SF_MAX_INLINE_BYTES = '64';\n  process.env.SF_MAX_CAPTURE_BYTES = '256';\n\n  t.after(async () => {\n    if (prevRoot === undefined) {\n      delete process.env.SF_CONTEXT_REPO_ROOT;\n    } else {\n      process.env.SF_CONTEXT_REPO_ROOT = prevRoot;\n    }\n    if (prevInline === undefined) {\n      delete process.env.SF_MAX_INLINE_BYTES;\n    } else {\n      process.env.SF_MAX_INLINE_BYTES = prevInline;\n    }\n    if (prevCapture === undefined) {\n      delete process.env.SF_MAX_CAPTURE_BYTES;\n    } else {\n      process.env.SF_MAX_CAPTURE_BYTES = prevCapture;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const executor = new ToolExecutor(loggerStub, stateStub, null, null, null, {});\n  const existing = {\n    uri: 'artifact://runs/trace-3/tool_calls/span-3/stdout.log',\n    rel: 'runs/trace-3/tool_calls/span-3/stdout.log',\n    bytes: 123,\n    truncated: false,\n  };\n\n  const payload = await executor.wrapResult({\n    tool: 'mcp_test',\n    args: { trace_id: 'trace-3', span_id: 'span-3' },\n    result: { stdout_buffer: Buffer.alloc(10_000, 1), stdout_ref: existing },\n    startedAt: Date.now(),\n    traceId: 'trace-3',\n    spanId: 'span-3',\n  });\n\n  assert.equal(payload.result.stdout_buffer.truncated, true);\n  assert.equal(payload.result.stdout_buffer.artifact.uri, existing.uri);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1445,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/cache.test.ts": [
      {
        "file_path": "tests/cache.test.ts",
        "start_line": 21,
        "end_line": 23,
        "content": "function createTempDir() {\n  return fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-cache-'));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 23,
          "qualified_name": "createTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/capability-manager.test.ts": [
      {
        "file_path": "tests/capability-manager.test.ts",
        "start_line": 1,
        "end_line": 95,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst CapabilityService = require('../src/services/CapabilityService');\nconst CapabilityManager = require('../src/managers/CapabilityManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\nconst validationStub = {\n  ensureString(value, label) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n    return value.trim();\n  },\n  ensureObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  },\n};\n\ntest('CapabilityManager suggests capabilities by context tags', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-capability-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const capabilityService = new CapabilityService(loggerStub, securityStub);\n  await capabilityService.initialize();\n\n  const contextServiceStub = {\n    async getContext() {\n      return { context: { key: 'demo', root: tmpRoot, tags: ['k8s'] } };\n    },\n  };\n\n  const manager = new CapabilityManager(\n    loggerStub,\n    securityStub,\n    validationStub,\n    capabilityService,\n    contextServiceStub\n  );\n\n  await manager.handleAction({\n    action: 'set',\n    name: 'k8s.diff',\n    capability: {\n      intent: 'k8s.diff',\n      runbook: 'k8s.diff',\n      effects: { kind: 'read' },\n      inputs: { required: ['overlay'] },\n      when: { tags_any: ['k8s'] },\n    },\n  });\n\n  await manager.handleAction({\n    action: 'set',\n    name: 'tf.plan',\n    capability: {\n      intent: 'tf.plan',\n      runbook: 'tf.plan',\n      effects: { kind: 'read' },\n      inputs: { required: [] },\n      when: { tags_any: ['terraform'] },\n    },\n  });\n\n  const suggestion = await manager.handleAction({ action: 'suggest' });\n  assert.ok(suggestion.suggestions.some((item) => item.name === 'k8s.diff'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 641,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/capability-service.test.ts": [
      {
        "file_path": "tests/capability-service.test.ts",
        "start_line": 1,
        "end_line": 56,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst CapabilityService = require('../src/services/CapabilityService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\ntest('CapabilityService persists and resolves intents', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-capabilities-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new CapabilityService(loggerStub, securityStub);\n  await service.initialize();\n\n  await service.setCapability('demo.read', {\n    intent: 'demo.read',\n    runbook: 'demo.run',\n    inputs: { required: ['id'] },\n    effects: { kind: 'read', requires_apply: false },\n  });\n\n  const list = await service.listCapabilities();\n  const entry = list.find((item) => item.name === 'demo.read');\n  assert.ok(entry);\n  assert.equal(entry.source, 'local');\n\n  const resolved = await service.findByIntent('demo.read');\n  assert.equal(resolved.runbook, 'demo.run');\n\n  const byName = await service.getCapability('demo.read');\n  assert.equal(byName.intent, 'demo.read');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 414,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/context-service.test.ts": [
      {
        "file_path": "tests/context-service.test.ts",
        "start_line": 1,
        "end_line": 54,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst ContextService = require('../src/services/ContextService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('ContextService detects markers and caches context', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-context-'));\n  const previousContext = process.env.MCP_CONTEXT_PATH;\n  process.env.MCP_CONTEXT_PATH = path.join(tmpRoot, 'context.json');\n\n  await fs.writeFile(path.join(tmpRoot, 'package.json'), '{\"name\":\"demo\"}');\n  await fs.writeFile(path.join(tmpRoot, 'Dockerfile'), 'FROM alpine');\n  await fs.mkdir(path.join(tmpRoot, '.git'), { recursive: true });\n  await fs.mkdir(path.join(tmpRoot, '.argocd'), { recursive: true });\n  await fs.mkdir(path.join(tmpRoot, 'flux-system'), { recursive: true });\n\n  t.after(async () => {\n    if (previousContext === undefined) {\n      delete process.env.MCP_CONTEXT_PATH;\n    } else {\n      process.env.MCP_CONTEXT_PATH = previousContext;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new ContextService(loggerStub, null);\n  await service.initialize();\n\n  const result = await service.getContext({ cwd: tmpRoot, refresh: true });\n  const context = result.context;\n\n  assert.equal(context.root, tmpRoot);\n  assert.ok(context.tags.includes('node'));\n  assert.ok(context.tags.includes('docker'));\n  assert.ok(context.tags.includes('git'));\n  assert.ok(context.tags.includes('argocd'));\n  assert.ok(context.tags.includes('flux'));\n  assert.ok(context.tags.includes('gitops'));\n\n  const list = await service.listContexts();\n  assert.equal(list.contexts.length, 1);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 460,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/context-session.test.ts": [
      {
        "file_path": "tests/context-session.test.ts",
        "start_line": 1,
        "end_line": 55,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst ContextSessionService = require('../src/services/ContextSessionService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('ContextSessionService enriches tags and reports diagnostics', async () => {\n  const contextService = {\n    async getContext() {\n      return {\n        context: {\n          key: 'ctx',\n          root: '/tmp/demo',\n          tags: ['git'],\n        },\n      };\n    },\n  };\n\n  const projectResolver = {\n    async resolveContext() {\n      return {\n        projectName: 'demo',\n        targetName: 'prod',\n        project: { repo_root: '/tmp/demo' },\n        target: { kubeconfig: '/tmp/missing-kubeconfig', ssh_profile: 'demo-ssh' },\n      };\n    },\n  };\n\n  const profileService = {\n    hasProfile() {\n      return true;\n    },\n    async probeProfileSecrets() {\n      return { ok: false, encrypted: true, error: 'decrypt failed' };\n    },\n  };\n\n  const service = new ContextSessionService(loggerStub, contextService, projectResolver, profileService);\n  const session = await service.resolve({});\n\n  assert.ok(session.effective_context.tags.includes('k8s'));\n  assert.ok(session.effective_context.tags.includes('ssh'));\n  assert.ok(session.diagnostics.warnings.some((entry) => entry.code === 'path_missing'));\n  assert.ok(session.diagnostics.warnings.some((entry) => entry.code === 'profile_secrets_unreadable'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 373,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/env-secretref.test.ts": [
      {
        "file_path": "tests/env-secretref.test.ts",
        "start_line": 1,
        "end_line": 230,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst path = require('node:path');\nconst os = require('node:os');\nconst { Writable } = require('node:stream');\n\nconst ProfileService = require('../src/services/ProfileService');\nconst EnvManager = require('../src/managers/EnvManager');\nconst SecretRefResolver = require('../src/services/SecretRefResolver');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensureString(value, _label, { trim = true } = {}) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error('invalid');\n    }\n    return trim ? value.trim() : value;\n  },\n  ensurePort(value, fallback) {\n    return value ?? fallback;\n  },\n};\n\nconst securityStub = {\n  async encrypt(value) {\n    return `enc(${value})`;\n  },\n  async decrypt(value) {\n    return value.replace(/^enc\\(|\\)$/g, '');\n  },\n  cleanCommand(value) {\n    return value;\n  },\n};\n\ntest('EnvManager resolves ref:vault:kv2 values when writing remote env', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-ref-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const vaultCalls = [];\n  const vaultClientStub = {\n    async kv2Get(profileName, ref) {\n      vaultCalls.push({ profileName, ref });\n      return 'postgres://db';\n    },\n  };\n\n  const capture = { content: null };\n  const files = new Map();\n  const sshManagerStub = {\n    async withSftp(_args, handler) {\n      return handler({\n        stat(filePath, cb) {\n          if (files.has(filePath)) {\n            cb(null, {});\n            return;\n          }\n          const error = new Error('missing');\n          error.code = 2;\n          cb(error);\n        },\n        createWriteStream(remotePath) {\n          const chunks = [];\n          const stream = new Writable({\n            write(chunk, _enc, cb) {\n              chunks.push(Buffer.from(chunk).toString('utf8'));\n              cb();\n            },\n          });\n          stream.on('finish', () => {\n            files.set(remotePath, chunks.join(''));\n            capture.content = files.get('/opt/app/.env') || null;\n          });\n          return stream;\n        },\n        rename(fromPath, toPath, cb) {\n          files.set(toPath, files.get(fromPath));\n          files.delete(fromPath);\n          capture.content = files.get('/opt/app/.env') || null;\n          cb(null);\n        },\n        unlink(filePath, cb) {\n          files.delete(filePath);\n          cb(null);\n        },\n        chmod(_filePath, _mode, cb) {\n          cb(null);\n        },\n      });\n    },\n    async ensureRemoteDir() {},\n  };\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, validationStub, profileService, vaultClientStub, null);\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, null, secretRefResolver);\n\n  await envManager.profileUpsert('bundle', {\n    secrets: {\n      DATABASE_URL: 'ref:vault:kv2:secret/myapp/prod#DATABASE_URL',\n    },\n  });\n\n  const result = await envManager.writeRemote({\n    profile_name: 'bundle',\n    ssh_profile_name: 'ssh1',\n    vault_profile_name: 'vault1',\n    remote_path: '/opt/app/.env',\n    mkdirs: true,\n  });\n\n  assert.equal(result.success, true);\n  assert.deepEqual(result.variables.keys, ['DATABASE_URL']);\n  assert.equal(capture.content, 'DATABASE_URL=\"postgres://db\"\\n');\n  assert.deepEqual(vaultCalls, [{ profileName: 'vault1', ref: 'secret/myapp/prod#DATABASE_URL' }]);\n});\n\ntest('EnvManager can infer vault profile from project target', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-ref-proj-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const vaultCalls = [];\n  const vaultClientStub = {\n    async kv2Get(profileName, ref) {\n      vaultCalls.push({ profileName, ref });\n      return 'postgres://db';\n    },\n  };\n\n  const projectResolverStub = {\n    async resolveContext() {\n      return { target: { vault_profile: 'vault-prod' } };\n    },\n  };\n\n  const files = new Map();\n  const sshManagerStub = {\n    async withSftp(_args, handler) {\n      return handler({\n        stat(filePath, cb) {\n          if (files.has(filePath)) {\n            cb(null, {});\n            return;\n          }\n          const error = new Error('missing');\n          error.code = 2;\n          cb(error);\n        },\n        createWriteStream(remotePath) {\n          const stream = new Writable({\n            write(_chunk, _enc, cb) {\n              cb();\n            },\n          });\n          stream.on('finish', () => {\n            files.set(remotePath, 'ok');\n          });\n          return stream;\n        },\n        rename(fromPath, toPath, cb) {\n          files.set(toPath, files.get(fromPath));\n          files.delete(fromPath);\n          cb(null);\n        },\n        unlink(filePath, cb) {\n          files.delete(filePath);\n          cb(null);\n        },\n        chmod(_filePath, _mode, cb) {\n          cb(null);\n        },\n      });\n    },\n    async ensureRemoteDir() {},\n  };\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, validationStub, profileService, vaultClientStub, projectResolverStub);\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, projectResolverStub, secretRefResolver);\n\n  await envManager.profileUpsert('bundle', {\n    secrets: {\n      DATABASE_URL: 'ref:vault:kv2:secret/myapp/prod#DATABASE_URL',\n    },\n  });\n\n  const result = await envManager.writeRemote({\n    profile_name: 'bundle',\n    ssh_profile_name: 'ssh1',\n    target: 'prod',\n    remote_path: '/opt/app/.env',\n  });\n\n  assert.equal(result.success, true);\n  assert.deepEqual(vaultCalls, [{ profileName: 'vault-prod', ref: 'secret/myapp/prod#DATABASE_URL' }]);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { Writable } = require('node:stream')"
          ],
          "parent_scope": null,
          "estimated_tokens": 1670,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/gitops-plan-workspace.test.ts": [
      {
        "file_path": "tests/gitops-plan-workspace.test.ts",
        "start_line": 23,
        "end_line": 30,
        "content": "function callTool(id, name, args) {\n  return {\n    jsonrpc: '2.0',\n    id,\n    method: 'tools/call',\n    params: { name, arguments: args },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "callTool",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "callTool",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-plan-workspace.test.ts",
        "start_line": 32,
        "end_line": 37,
        "content": "function parseToolText(resp) {\n  assert.equal(resp.jsonrpc, '2.0');\n  assert.ok(resp.result);\n  assert.ok(Array.isArray(resp.result.content));\n  return resp.result.content[0].text;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseToolText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "parseToolText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/gitops-propose-workspace.test.ts": [
      {
        "file_path": "tests/gitops-propose-workspace.test.ts",
        "start_line": 24,
        "end_line": 31,
        "content": "function callTool(id, name, args) {\n  return {\n    jsonrpc: '2.0',\n    id,\n    method: 'tools/call',\n    params: { name, arguments: args },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "callTool",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "callTool",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-propose-workspace.test.ts",
        "start_line": 33,
        "end_line": 38,
        "content": "function parseToolText(resp) {\n  assert.equal(resp.jsonrpc, '2.0');\n  assert.ok(resp.result);\n  assert.ok(Array.isArray(resp.result.content));\n  return resp.result.content[0].text;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseToolText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "parseToolText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-propose-workspace.test.ts",
        "start_line": 40,
        "end_line": 44,
        "content": "function parseTraceId(text) {\n  const traceLine = text.split('\\n').find((line) => line.startsWith('N: trace_id:'));\n  assert.ok(traceLine, `expected trace_id in output, got:\\n${text}`);\n  return traceLine.replace('N: trace_id:', '').trim();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseTraceId",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "parseTraceId",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-propose-workspace.test.ts",
        "start_line": 46,
        "end_line": 116,
        "content": "function startFakeGithubServer() {\n  const requests = [];\n  let statusCalls = 0;\n\n  const server = http.createServer(async (req, res) => {\n    if (req.method === 'POST' && req.url === '/repos/acme/demo/pulls') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n\n      res.writeHead(201, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ number: 1, html_url: 'https://github.com/acme/demo/pull/1' }));\n      return;\n    }\n\n    if (req.method === 'GET' && /^\\/repos\\/acme\\/demo\\/commits\\/[^/]+\\/status$/.test(req.url)) {\n      requests.push({ method: req.method, url: req.url, body: null });\n      statusCalls += 1;\n\n      res.writeHead(200, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ state: statusCalls >= 2 ? 'success' : 'pending' }));\n      return;\n    }\n\n    if (req.method === 'PUT' && req.url === '/repos/acme/demo/pulls/1/merge') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n\n      res.writeHead(200, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ merged: true }));\n      return;\n    }\n\n    if (req.method === 'POST' && req.url === '/repos/acme/demo/issues/1/comments') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n\n      res.writeHead(201, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ id: 10 }));\n      return;\n    }\n\n    res.writeHead(404, { 'content-type': 'application/json' });\n    res.end(JSON.stringify({ error: 'not found' }));\n  });\n\n  return new Promise((resolve) => {\n    server.listen(0, '127.0.0.1', () => {\n      const address = server.address();\n      resolve({\n        server,\n        baseUrl: `http://127.0.0.1:${address.port}`,\n        requests,\n      });\n    });\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "startFakeGithubServer",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 594,
          "qualified_name": "startFakeGithubServer",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/gitops-release-workspace.test.ts": [
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 23,
        "end_line": 30,
        "content": "function callTool(id, name, args) {\n  return {\n    jsonrpc: '2.0',\n    id,\n    method: 'tools/call',\n    params: { name, arguments: args },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "callTool",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "callTool",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 32,
        "end_line": 37,
        "content": "function parseToolText(resp) {\n  assert.equal(resp.jsonrpc, '2.0');\n  assert.ok(resp.result);\n  assert.ok(Array.isArray(resp.result.content));\n  return resp.result.content[0].text;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseToolText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "parseToolText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 39,
        "end_line": 43,
        "content": "function parseTraceId(text) {\n  const traceLine = text.split('\\n').find((line) => line.startsWith('N: trace_id:'));\n  assert.ok(traceLine, `expected trace_id in output, got:\\n${text}`);\n  return traceLine.replace('N: trace_id:', '').trim();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseTraceId",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "parseTraceId",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 45,
        "end_line": 101,
        "content": "async function writeKubectlStub(dir) {\n  const scriptPath = path.join(dir, 'kubectl');\n  const body = `#!/usr/bin/env node\nconst fs = require('node:fs');\n\nconst statePath = process.env.KUBECTL_STUB_STATE;\nconst mode = process.env.KUBECTL_STUB_MODE || 'happy';\nconst argv = process.argv.slice(2);\n\nlet state = { argocd_gets: 0, argocd_patches: 0 };\nif (statePath && fs.existsSync(statePath)) {\n  try {\n    state = JSON.parse(fs.readFileSync(statePath, 'utf8'));\n  } catch (error) {\n  }\n}\n\nconst has = (token) => argv.includes(token);\n\nif (has('patch') && has('application')) {\n  state.argocd_patches += 1;\n  if (statePath) {\n    fs.writeFileSync(statePath, JSON.stringify(state));\n  }\n  process.exit(0);\n}\n\nif (has('get') && has('application')) {\n  state.argocd_gets += 1;\n\n  let out = 'Synced Healthy';\n  if (mode === 'rollback') {\n    if (state.argocd_patches >= 2) {\n      out = 'Synced Healthy';\n    } else if (state.argocd_patches === 1 && state.argocd_gets === 1) {\n      out = 'Synced Healthy';\n    } else {\n      out = 'OutOfSync Progressing';\n    }\n  }\n\n  if (statePath) {\n    fs.writeFileSync(statePath, JSON.stringify(state));\n  }\n  process.stdout.write(out);\n  process.exit(0);\n}\n\nif (statePath) {\n  fs.writeFileSync(statePath, JSON.stringify(state));\n}\nprocess.exit(0);\n`;\n\n  await fs.writeFile(scriptPath, body, { mode: 0o755 });\n  return scriptPath;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeKubectlStub",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 341,
          "qualified_name": "writeKubectlStub",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 103,
        "end_line": 186,
        "content": "function startFakeGithubServer({ remoteBare }) {\n  const requests = [];\n  let statusCalls = 0;\n  let lastPr = null;\n\n  const server = http.createServer(async (req, res) => {\n    if (req.method === 'POST' && req.url === '/repos/acme/demo/pulls') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n      lastPr = body;\n\n      res.writeHead(201, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ number: 1, html_url: 'https://github.com/acme/demo/pull/1' }));\n      return;\n    }\n\n    if (req.method === 'GET' && /^\\/repos\\/acme\\/demo\\/commits\\/[^/]+\\/status$/.test(req.url)) {\n      requests.push({ method: req.method, url: req.url, body: null });\n      statusCalls += 1;\n\n      res.writeHead(200, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ state: statusCalls >= 2 ? 'success' : 'pending' }));\n      return;\n    }\n\n    if (req.method === 'PUT' && req.url === '/repos/acme/demo/pulls/1/merge') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n\n      if (lastPr && remoteBare) {\n        const head = String(lastPr.head || '').split(':')[1];\n        const base = String(lastPr.base || '').trim();\n        if (head && base) {\n          const sha = execFileSync('git', ['--git-dir', remoteBare, 'rev-parse', `refs/heads/${head}`])\n            .toString('utf8')\n            .trim();\n          execFileSync('git', ['--git-dir', remoteBare, 'update-ref', `refs/heads/${base}`, sha], { stdio: 'ignore' });\n        }\n      }\n\n      res.writeHead(200, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ merged: true }));\n      return;\n    }\n\n    if (req.method === 'POST' && req.url === '/repos/acme/demo/issues/1/comments') {\n      const chunks = [];\n      for await (const chunk of req) {\n        chunks.push(chunk);\n      }\n      const raw = Buffer.concat(chunks).toString('utf8');\n      const body = raw ? JSON.parse(raw) : null;\n      requests.push({ method: req.method, url: req.url, body });\n\n      res.writeHead(201, { 'content-type': 'application/json' });\n      res.end(JSON.stringify({ id: 10 }));\n      return;\n    }\n\n    res.writeHead(404, { 'content-type': 'application/json' });\n    res.end(JSON.stringify({ error: 'not found' }));\n  });\n\n  return new Promise((resolve) => {\n    server.listen(0, '127.0.0.1', () => {\n      const address = server.address();\n      resolve({\n        server,\n        baseUrl: `http://127.0.0.1:${address.port}`,\n        requests,\n      });\n    });\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "startFakeGithubServer",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 726,
          "qualified_name": "startFakeGithubServer",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-release-workspace.test.ts",
        "start_line": 188,
        "end_line": 190,
        "content": "function gitShowFile(gitDir, ref, filePath) {\n  return execFileSync('git', ['--git-dir', gitDir, 'show', `${ref}:${filePath}`]).toString('utf8');\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "gitShowFile",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "gitShowFile",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/gitops-sync-verify-workspace.test.ts": [
      {
        "file_path": "tests/gitops-sync-verify-workspace.test.ts",
        "start_line": 21,
        "end_line": 28,
        "content": "function callTool(id, name, args) {\n  return {\n    jsonrpc: '2.0',\n    id,\n    method: 'tools/call',\n    params: { name, arguments: args },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "callTool",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "callTool",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-sync-verify-workspace.test.ts",
        "start_line": 30,
        "end_line": 35,
        "content": "function parseToolText(resp) {\n  assert.equal(resp.jsonrpc, '2.0');\n  assert.ok(resp.result);\n  assert.ok(Array.isArray(resp.result.content));\n  return resp.result.content[0].text;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseToolText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "parseToolText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-sync-verify-workspace.test.ts",
        "start_line": 37,
        "end_line": 41,
        "content": "function parseTraceId(text) {\n  const traceLine = text.split('\\n').find((line) => line.startsWith('N: trace_id:'));\n  assert.ok(traceLine, `expected trace_id in output, got:\\n${text}`);\n  return traceLine.replace('N: trace_id:', '').trim();\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseTraceId",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 60,
          "qualified_name": "parseTraceId",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/gitops-sync-verify-workspace.test.ts",
        "start_line": 43,
        "end_line": 89,
        "content": "async function writeKubectlStub(dir) {\n  const scriptPath = path.join(dir, 'kubectl');\n  const body = `#!/usr/bin/env node\nconst fs = require('node:fs');\n\nconst statePath = process.env.KUBECTL_STUB_STATE;\nconst argv = process.argv.slice(2);\n\nlet state = { argocd_gets: 0, flux_gets: 0 };\nif (statePath && fs.existsSync(statePath)) {\n  try {\n    state = JSON.parse(fs.readFileSync(statePath, 'utf8'));\n  } catch (error) {\n  }\n}\n\nconst has = (token) => argv.includes(token);\n\nif (has('get') && has('application')) {\n  state.argocd_gets += 1;\n  const out = state.argocd_gets >= 3 ? 'Synced Healthy' : 'OutOfSync Progressing';\n  if (statePath) {\n    fs.writeFileSync(statePath, JSON.stringify(state));\n  }\n  process.stdout.write(out);\n  process.exit(0);\n}\n\nif (has('get') && has('kustomization')) {\n  state.flux_gets += 1;\n  const out = state.flux_gets >= 2 ? 'True' : 'False';\n  if (statePath) {\n    fs.writeFileSync(statePath, JSON.stringify(state));\n  }\n  process.stdout.write(out);\n  process.exit(0);\n}\n\nif (statePath) {\n  fs.writeFileSync(statePath, JSON.stringify(state));\n}\nprocess.exit(0);\n`;\n\n  await fs.writeFile(scriptPath, body, { mode: 0o755 });\n  return scriptPath;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeKubectlStub",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 294,
          "qualified_name": "writeKubectlStub",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/handshake.test.ts": [
      {
        "file_path": "tests/handshake.test.ts",
        "start_line": 1,
        "end_line": 41,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst { startServer, readLine, terminate } = require('./util');\n\nconst MCP_INIT = {\n  jsonrpc: '2.0',\n  id: 1,\n  method: 'initialize',\n  params: {\n    protocolVersion: '2025-06-18',\n    capabilities: {},\n    clientInfo: { name: 'handshake-test', version: '1.0.0' },\n  },\n};\n\nconst MCP_LIST = {\n  jsonrpc: '2.0',\n  id: 2,\n  method: 'tools/list',\n};\ntest('STDIO handshake returns initialize response and tools list', async () => {\n  const proc = startServer();\n\n  try {\n    proc.stdin.write(JSON.stringify(MCP_INIT) + '\\n');\n    const initResp = JSON.parse(await readLine(proc.stdout));\n    assert.equal(initResp.id, 1);\n    assert.equal(initResp.result.protocolVersion, '2025-06-18');\n    assert.equal(initResp.result.capabilities.tools.list, true);\n    assert.equal(initResp.result.capabilities.tools.call, true);\n\n    proc.stdin.write(JSON.stringify(MCP_LIST) + '\\n');\n    const listResp = JSON.parse(await readLine(proc.stdout));\n    assert.equal(listResp.id, 2);\n    assert.ok(Array.isArray(listResp.result.tools));\n    assert.ok(listResp.result.tools.length >= 4);\n  } finally {\n    await terminate(proc);\n  }\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { startServer, readLine, terminate } = require('./util')"
          ],
          "parent_scope": null,
          "estimated_tokens": 318,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/handshake_local_unsafe.test.ts": [
      {
        "file_path": "tests/handshake_local_unsafe.test.ts",
        "start_line": 23,
        "end_line": 29,
        "content": "async function listToolNames(proc) {\n  proc.stdin.write(JSON.stringify(MCP_INIT) + '\\n');\n  await readLine(proc.stdout);\n  proc.stdin.write(JSON.stringify(MCP_LIST) + '\\n');\n  const listResp = JSON.parse(await readLine(proc.stdout));\n  return listResp.result.tools.map((tool) => tool.name);\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "listToolNames",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 73,
          "qualified_name": "listToolNames",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/handshake_negative.test.ts": [
      {
        "file_path": "tests/handshake_negative.test.ts",
        "start_line": 31,
        "end_line": 50,
        "content": "function waitForSilence(stream, timeoutMs = 200) {\n  return new Promise((resolve) => {\n    const timer = setTimeout(() => {\n      cleanup();\n      resolve('');\n    }, timeoutMs);\n\n    const onData = (chunk) => {\n      cleanup();\n      resolve(chunk.toString());\n    };\n\n    const cleanup = () => {\n      clearTimeout(timer);\n      stream.off('data', onData);\n    };\n\n    stream.on('data', onData);\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "waitForSilence",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 101,
          "qualified_name": "waitForSilence",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/help.test.ts": [
      {
        "file_path": "tests/help.test.ts",
        "start_line": 17,
        "end_line": 24,
        "content": "function callTool(id, name, args) {\n  return {\n    jsonrpc: '2.0',\n    id,\n    method: 'tools/call',\n    params: { name, arguments: args },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "callTool",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "callTool",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/help.test.ts",
        "start_line": 26,
        "end_line": 31,
        "content": "function parseToolText(resp) {\n  assert.equal(resp.jsonrpc, '2.0');\n  assert.ok(resp.result);\n  assert.ok(Array.isArray(resp.result.content));\n  return resp.result.content[0].text;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "parseToolText",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 45,
          "qualified_name": "parseToolText",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/http-manager.test.ts": [
      {
        "file_path": "tests/http-manager.test.ts",
        "start_line": 1,
        "end_line": 175,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\nconst APIManager = require('../src/managers/APIManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  error() {},\n  warn() {},\n  info() {},\n};\n\nconst securityStub = {\n  ensureUrl(url) {\n    return new URL(url);\n  },\n};\n\nconst validationStub = {\n  ensureHeaders(headers) {\n    return headers ?? {};\n  },\n  ensureString(value) {\n    return value;\n  },\n};\n\nconst profileServiceStub = () => ({\n  async getProfile() {\n    return { data: {}, secrets: {} };\n  },\n  async listProfiles() {\n    return [];\n  },\n  async setProfile() {},\n  async deleteProfile() {},\n});\n\nconst createHeaders = (items) => ({\n  get(key) {\n    const found = items.find(([name]) => name.toLowerCase() === key.toLowerCase());\n    return found ? found[1] : undefined;\n  },\n  entries() {\n    return items[Symbol.iterator]();\n  },\n});\n\nconst createResponse = ({ status, body, contentType }) => ({\n  ok: status >= 200 && status < 300,\n  status,\n  statusText: status === 200 ? 'OK' : 'Error',\n  headers: createHeaders([['content-type', contentType || 'application/json']]),\n  async json() {\n    return typeof body === 'string' ? JSON.parse(body) : body;\n  },\n  async text() {\n    return typeof body === 'string' ? body : JSON.stringify(body);\n  },\n  async arrayBuffer() {\n    const raw = typeof body === 'string' ? body : JSON.stringify(body);\n    return Buffer.from(raw);\n  },\n});\n\ntest('APIManager retries on retryable status codes', async () => {\n  let calls = 0;\n  const fetchStub = async () => {\n    calls += 1;\n    if (calls === 1) {\n      return createResponse({ status: 503, body: { ok: false } });\n    }\n    return createResponse({ status: 200, body: { ok: true } });\n  };\n\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n  const result = await manager.request({ method: 'GET', url: 'https://example.com' });\n\n  assert.equal(calls, 2);\n  assert.equal(result.status, 200);\n  assert.equal(result.attempts, 2);\n});\n\ntest('APIManager paginates using page-based pagination', async () => {\n  const fetchStub = async (url) => {\n    const parsed = new URL(url);\n    const page = Number(parsed.searchParams.get('page') || '1');\n    const body = page < 3 ? { items: [page] } : { items: [] };\n    return createResponse({ status: 200, body });\n  };\n\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n  const result = await manager.paginate({\n    method: 'GET',\n    url: 'https://example.com/items',\n    pagination: {\n      type: 'page',\n      param: 'page',\n      size_param: 'limit',\n      size: 1,\n      max_pages: 5,\n      item_path: 'data.items',\n    },\n  });\n\n  assert.equal(result.page_count, 3);\n  assert.deepEqual(result.items, [1, 2]);\n});\n\ntest('APIManager download refuses to overwrite local files by default', async () => {\n  const dir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-download-'));\n  const targetPath = path.join(dir, 'report.txt');\n  await fs.writeFile(targetPath, 'old');\n\n  const fetchStub = async () => createResponse({ status: 200, body: 'new' });\n  const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n\n  await assert.rejects(\n    () => manager.download({ method: 'GET', url: 'https://example.com/report', download_path: targetPath }),\n    /Local path already exists/\n  );\n\n  const result = await manager.download({\n    method: 'GET',\n    url: 'https://example.com/report',\n    download_path: targetPath,\n    overwrite: true,\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(await fs.readFile(targetPath, 'utf8'), 'new');\n\n  await fs.rm(dir, { recursive: true, force: true });\n});\n\ntest('APIManager download expands ~ in download_path', async () => {\n  const dir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-download-home-'));\n  const previousHome = process.env.HOME;\n  try {\n    process.env.HOME = dir;\n    const targetPath = path.join(dir, 'report.txt');\n    await fs.writeFile(targetPath, 'old');\n\n    const fetchStub = async () => createResponse({ status: 200, body: 'new' });\n    const manager = new APIManager(loggerStub, securityStub, validationStub, profileServiceStub(), null, { fetch: fetchStub });\n\n    await assert.rejects(\n      () => manager.download({ method: 'GET', url: 'https://example.com/report', download_path: '~/report.txt' }),\n      /Local path already exists/\n    );\n\n    const result = await manager.download({\n      method: 'GET',\n      url: 'https://example.com/report',\n      download_path: '~/report.txt',\n      overwrite: true,\n    });\n\n    assert.equal(result.success, true);\n    assert.equal(result.file_path, targetPath);\n    assert.equal(await fs.readFile(targetPath, 'utf8'), 'new');\n  } finally {\n    if (previousHome === undefined) {\n      delete process.env.HOME;\n    } else {\n      process.env.HOME = previousHome;\n    }\n    await fs.rm(dir, { recursive: true, force: true });\n  }\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1296,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/index.ts": [
      {
        "file_path": "tests/index.ts",
        "start_line": 1,
        "end_line": 11,
        "content": "// @ts-nocheck\nconst fs = require('node:fs');\nconst path = require('node:path');\n\nconst dir = __dirname;\nfor (const entry of fs.readdirSync(dir)) {\n  if (!entry.endsWith('.test.js')) {\n    continue;\n  }\n  require(path.join(dir, entry));\n}\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 59,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/intent-manager.test.ts": [
      {
        "file_path": "tests/intent-manager.test.ts",
        "start_line": 1,
        "end_line": 136,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst CapabilityService = require('../src/services/CapabilityService');\nconst EvidenceService = require('../src/services/EvidenceService');\nconst IntentManager = require('../src/managers/IntentManager');\nconst ToolError = require('../src/errors/ToolError');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\nconst validationStub = {\n  ensureString(value, label) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n    return value.trim();\n  },\n  ensureOptionalString(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureString(value, label);\n  },\n  ensureObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  },\n  ensureOptionalObject(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureObject(value, label);\n  },\n};\n\ntest('IntentManager compiles and enforces apply for write effects', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-intent-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  const previousEvidence = process.env.MCP_EVIDENCE_DIR;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n  process.env.MCP_EVIDENCE_DIR = path.join(tmpRoot, 'evidence');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    if (previousEvidence === undefined) {\n      delete process.env.MCP_EVIDENCE_DIR;\n    } else {\n      process.env.MCP_EVIDENCE_DIR = previousEvidence;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const capabilityService = new CapabilityService(loggerStub, securityStub);\n  await capabilityService.initialize();\n  await capabilityService.setCapability('k8s.apply', {\n    intent: 'k8s.apply',\n    runbook: 'k8s.apply',\n    inputs: { required: ['overlay'] },\n    effects: { kind: 'write', requires_apply: true },\n  });\n\n  const runbookManagerStub = {\n    handleAction: async (args) => ({\n      success: true,\n      runbook: args.name,\n      steps: [],\n    }),\n  };\n\n  const contextServiceStub = {\n    async getContext() {\n      return { context: { key: 'demo', root: tmpRoot, tags: ['k8s'] } };\n    },\n  };\n\n  const evidenceService = new EvidenceService(loggerStub, securityStub);\n  const intentManager = new IntentManager(\n    loggerStub,\n    securityStub,\n    validationStub,\n    capabilityService,\n    runbookManagerStub,\n    evidenceService,\n    null,\n    contextServiceStub\n  );\n\n  const compiled = await intentManager.handleAction({\n    action: 'compile',\n    intent: { type: 'k8s.apply', inputs: { overlay: '/repo/overlay' } },\n  });\n  assert.equal(compiled.plan.steps.length, 1);\n\n  await assert.rejects(\n    () =>\n      intentManager.handleAction({\n        action: 'execute',\n        intent: { type: 'k8s.apply', inputs: { overlay: '/repo/overlay' } },\n      }),\n    (error) => {\n      assert.equal(ToolError.isToolError(error), true);\n      assert.equal(error.kind, 'denied');\n      assert.equal(error.code, 'APPLY_REQUIRED');\n      return true;\n    }\n  );\n\n  const executed = await intentManager.handleAction({\n    action: 'execute',\n    apply: true,\n    save_evidence: true,\n    intent: { type: 'k8s.apply', inputs: { overlay: '/repo/overlay' } },\n  });\n  assert.equal(executed.success, true);\n  assert.ok(executed.evidence_path);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 989,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/intent-project-policy.test.ts": [
      {
        "file_path": "tests/intent-project-policy.test.ts",
        "start_line": 1,
        "end_line": 153,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst CapabilityService = require('../src/services/CapabilityService');\nconst EvidenceService = require('../src/services/EvidenceService');\nconst StateService = require('../src/services/StateService');\nconst PolicyService = require('../src/services/PolicyService');\nconst IntentManager = require('../src/managers/IntentManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\nconst validationStub = {\n  ensureString(value, label) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n    return value.trim();\n  },\n  ensureOptionalString(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureString(String(value), label);\n  },\n  ensureObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  },\n  ensureOptionalObject(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureObject(value, label);\n  },\n};\n\ntest('IntentManager resolves target.policy and target.* mappings even when project/target are provided', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-intent-policy-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  const previousEvidence = process.env.MCP_EVIDENCE_DIR;\n  const previousState = process.env.MCP_STATE_PATH;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n  process.env.MCP_EVIDENCE_DIR = path.join(tmpRoot, 'evidence');\n  process.env.MCP_STATE_PATH = path.join(tmpRoot, 'state.json');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    if (previousEvidence === undefined) {\n      delete process.env.MCP_EVIDENCE_DIR;\n    } else {\n      process.env.MCP_EVIDENCE_DIR = previousEvidence;\n    }\n    if (previousState === undefined) {\n      delete process.env.MCP_STATE_PATH;\n    } else {\n      process.env.MCP_STATE_PATH = previousState;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const capabilityService = new CapabilityService(loggerStub, securityStub);\n  await capabilityService.initialize();\n  await capabilityService.setCapability('gitops.propose', {\n    intent: 'gitops.propose',\n    runbook: 'noop',\n    when: null,\n    inputs: {\n      required: ['patch', 'message', 'kubeconfig'],\n      map: {\n        kubeconfig: 'target.kubeconfig',\n      },\n    },\n    effects: { kind: 'write', requires_apply: true },\n  });\n\n  const runbookManagerStub = {\n    handleAction: async () => ({ success: true, steps: [] }),\n  };\n\n  let resolverCalls = 0;\n  const projectResolverStub = {\n    async resolveContext(args) {\n      resolverCalls += 1;\n      assert.equal(args.project, 'demo');\n      assert.equal(args.target, 'prod');\n      return {\n        projectName: 'demo',\n        targetName: 'prod',\n        project: {},\n        target: {\n          kubeconfig: '/tmp/kubeconfig',\n          policy: { mode: 'operatorless', lock: { enabled: false } },\n        },\n      };\n    },\n  };\n\n  const stateService = new StateService(loggerStub);\n  await stateService.initialize();\n  const policyService = new PolicyService(loggerStub, validationStub, stateService);\n  const evidenceService = new EvidenceService(loggerStub, securityStub);\n\n  const intentManager = new IntentManager(\n    loggerStub,\n    securityStub,\n    validationStub,\n    capabilityService,\n    runbookManagerStub,\n    evidenceService,\n    projectResolverStub,\n    null,\n    policyService\n  );\n\n  const executed = await intentManager.handleAction({\n    action: 'execute',\n    apply: true,\n    project: 'demo',\n    target: 'prod',\n    intent: {\n      type: 'gitops.propose',\n      inputs: {\n        patch: 'diff --git a/a b/a\\n',\n        message: 'test',\n      },\n    },\n  });\n\n  assert.equal(executed.success, true);\n  assert.equal(resolverCalls, 1);\n  assert.equal(executed.plan.steps[0].inputs.kubeconfig, '/tmp/kubeconfig');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1128,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/intent-routing.test.ts": [
      {
        "file_path": "tests/intent-routing.test.ts",
        "start_line": 1,
        "end_line": 186,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst path = require('node:path');\nconst os = require('node:os');\n\nconst CapabilityService = require('../src/services/CapabilityService');\nconst EvidenceService = require('../src/services/EvidenceService');\nconst IntentManager = require('../src/managers/IntentManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\nconst validationStub = {\n  ensureString(value, label) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n    return value.trim();\n  },\n  ensureOptionalString(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureString(value, label);\n  },\n  ensureObject(value, label) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`${label} must be an object`);\n    }\n    return value;\n  },\n  ensureOptionalObject(value, label) {\n    if (value === undefined || value === null) {\n      return undefined;\n    }\n    return this.ensureObject(value, label);\n  },\n};\n\ntest('IntentManager selects among multiple capabilities for the same intent via when tags', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-intent-routing-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  const previousEvidence = process.env.MCP_EVIDENCE_DIR;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n  process.env.MCP_EVIDENCE_DIR = path.join(tmpRoot, 'evidence');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    if (previousEvidence === undefined) {\n      delete process.env.MCP_EVIDENCE_DIR;\n    } else {\n      process.env.MCP_EVIDENCE_DIR = previousEvidence;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const capabilityService = new CapabilityService(loggerStub, securityStub);\n  await capabilityService.initialize();\n\n  await capabilityService.setCapability('gitops.plan.argocd', {\n    intent: 'gitops.plan',\n    runbook: 'gitops.plan.argocd',\n    effects: { kind: 'read' },\n    inputs: { required: [] },\n    when: { tags_any: ['argocd'] },\n  });\n\n  await capabilityService.setCapability('gitops.plan.flux', {\n    intent: 'gitops.plan',\n    runbook: 'gitops.plan.flux',\n    effects: { kind: 'read' },\n    inputs: { required: [] },\n    when: { tags_any: ['flux'] },\n  });\n\n  const contextServiceStub = {\n    async getContext() {\n      return { context: { key: 'demo', root: tmpRoot, tags: ['flux'] } };\n    },\n  };\n\n  const runbookManagerStub = {\n    handleAction: async () => ({ success: true, steps: [] }),\n  };\n\n  const evidenceService = new EvidenceService(loggerStub, securityStub);\n  const intentManager = new IntentManager(\n    loggerStub,\n    securityStub,\n    validationStub,\n    capabilityService,\n    runbookManagerStub,\n    evidenceService,\n    null,\n    contextServiceStub\n  );\n\n  const compiled = await intentManager.handleAction({\n    action: 'compile',\n    intent: { type: 'gitops.plan', inputs: {} },\n  });\n\n  assert.equal(compiled.plan.steps[0].runbook, 'gitops.plan.flux');\n});\n\ntest('IntentManager propagates apply into runbook inputs', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-intent-apply-'));\n  const previousCapabilities = process.env.MCP_CAPABILITIES_PATH;\n  const previousEvidence = process.env.MCP_EVIDENCE_DIR;\n  process.env.MCP_CAPABILITIES_PATH = path.join(tmpRoot, 'capabilities.json');\n  process.env.MCP_EVIDENCE_DIR = path.join(tmpRoot, 'evidence');\n\n  t.after(async () => {\n    if (previousCapabilities === undefined) {\n      delete process.env.MCP_CAPABILITIES_PATH;\n    } else {\n      process.env.MCP_CAPABILITIES_PATH = previousCapabilities;\n    }\n    if (previousEvidence === undefined) {\n      delete process.env.MCP_EVIDENCE_DIR;\n    } else {\n      process.env.MCP_EVIDENCE_DIR = previousEvidence;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const capabilityService = new CapabilityService(loggerStub, securityStub);\n  await capabilityService.initialize();\n  await capabilityService.setCapability('k8s.apply', {\n    intent: 'k8s.apply',\n    runbook: 'k8s.apply',\n    inputs: { required: [] },\n    effects: { kind: 'write', requires_apply: true },\n  });\n\n  let sawApply = false;\n  const runbookManagerStub = {\n    handleAction: async (args) => {\n      sawApply = args.input?.apply === true;\n      return { success: true, steps: [] };\n    },\n  };\n\n  const contextServiceStub = {\n    async getContext() {\n      return { context: { key: 'demo', root: tmpRoot, tags: ['k8s'] } };\n    },\n  };\n\n  const evidenceService = new EvidenceService(loggerStub, securityStub);\n  const intentManager = new IntentManager(\n    loggerStub,\n    securityStub,\n    validationStub,\n    capabilityService,\n    runbookManagerStub,\n    evidenceService,\n    null,\n    contextServiceStub\n  );\n\n  const executed = await intentManager.handleAction({\n    action: 'execute',\n    apply: true,\n    intent: { type: 'k8s.apply', inputs: {} },\n  });\n\n  assert.equal(executed.success, true);\n  assert.equal(sawApply, true);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1376,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/job-service.test.ts": [
      {
        "file_path": "tests/job-service.test.ts",
        "start_line": 1,
        "end_line": 127,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst JobService = require('../src/services/JobService');\nconst JobManager = require('../src/managers/JobManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensureString(value, label) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error(`${label} must be a non-empty string`);\n    }\n    return value.trim();\n  },\n};\n\ntest('JobService enforces maxJobs via LRU eviction', () => {\n  const prevMax = process.env.SF_JOBS_MAX;\n  process.env.SF_JOBS_MAX = '2';\n\n  const service = new JobService(loggerStub);\n  service.create({ kind: 'one' });\n  service.create({ kind: 'two' });\n  service.create({ kind: 'three' });\n\n  assert.equal(service.getStats().jobs, 2);\n\n  if (prevMax === undefined) {\n    delete process.env.SF_JOBS_MAX;\n  } else {\n    process.env.SF_JOBS_MAX = prevMax;\n  }\n});\n\ntest('JobService cancel aborts and marks job canceled', () => {\n  const service = new JobService(loggerStub);\n  const job = service.create({ kind: 'task' });\n  const signal = service.getAbortSignal(job.job_id);\n  assert.equal(signal.aborted, false);\n\n  const canceled = service.cancel(job.job_id, 'test');\n  assert.equal(canceled.status, 'canceled');\n  assert.equal(signal.aborted, true);\n});\n\ntest('JobService purgeExpired removes expired jobs', () => {\n  const prevTtl = process.env.SF_JOBS_TTL_MS;\n  process.env.SF_JOBS_TTL_MS = '1';\n\n  const service = new JobService(loggerStub);\n  const job = service.create({ kind: 'task' });\n  service.purgeExpired(Date.now() + 10_000);\n  assert.equal(service.get(job.job_id), null);\n\n  if (prevTtl === undefined) {\n    delete process.env.SF_JOBS_TTL_MS;\n  } else {\n    process.env.SF_JOBS_TTL_MS = prevTtl;\n  }\n});\n\ntest('JobManager supports list/cancel/forget for inprocess jobs', async () => {\n  const service = new JobService(loggerStub);\n  const job = service.create({ kind: 'inprocess_task' });\n  service.upsert({ job_id: job.job_id, status: 'running' });\n\n  const manager = new JobManager(loggerStub, validationStub, service, {});\n  const listed = await manager.handleAction({ action: 'job_list', limit: 10 });\n  assert.equal(listed.success, true);\n  assert.ok(listed.jobs.some((entry) => entry.job_id === job.job_id));\n\n  const canceled = await manager.handleAction({ action: 'job_cancel', job_id: job.job_id });\n  assert.equal(canceled.success, true);\n  assert.equal(canceled.job.status, 'canceled');\n\n  const forgotten = await manager.handleAction({ action: 'job_forget', job_id: job.job_id });\n  assert.equal(forgotten.success, true);\n  assert.equal(forgotten.removed, true);\n});\n\ntest('JobService persists jobs with file store (durable mode)', async (t) => {\n  const profilesDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-jobs-store-'));\n\n  const prevProfilesDir = process.env.MCP_PROFILES_DIR;\n  const prevJobsStore = process.env.SF_JOBS_STORE;\n\n  process.env.MCP_PROFILES_DIR = profilesDir;\n  process.env.SF_JOBS_STORE = 'file';\n\n  t.after(async () => {\n    if (prevProfilesDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfilesDir;\n    }\n    if (prevJobsStore === undefined) {\n      delete process.env.SF_JOBS_STORE;\n    } else {\n      process.env.SF_JOBS_STORE = prevJobsStore;\n    }\n    await fs.rm(profilesDir, { recursive: true, force: true });\n  });\n\n  const first = new JobService(loggerStub);\n  const job = first.create({ kind: 'durable_task' });\n  first.upsert({ job_id: job.job_id, status: 'running' });\n  await first.flush();\n\n  const second = new JobService(loggerStub);\n  const loaded = second.get(job.job_id);\n  assert.ok(loaded);\n  assert.equal(loaded.job_id, job.job_id);\n  assert.equal(loaded.kind, 'durable_task');\n  assert.equal(loaded.status, 'running');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1003,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/local-manager.test.ts": [
      {
        "file_path": "tests/local-manager.test.ts",
        "start_line": 20,
        "end_line": 23,
        "content": "function createLocalManager({ enabled }) {\n  const validation = new Validation(loggerStub);\n  return new LocalManager(loggerStub, validation, { enabled });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createLocalManager",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 39,
          "qualified_name": "createLocalManager",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/output.test.ts": [
      {
        "file_path": "tests/output.test.ts",
        "start_line": 1,
        "end_line": 57,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst { applyOutputTransform } = require('../src/utils/output');\n\ntest('output.missing=error throws when path is missing (default)', () => {\n  assert.throws(() => applyOutputTransform({ ok: true }, { path: 'missing.path' }), /not found/);\n});\n\ntest('output.missing=null returns null when path is missing', () => {\n  const shaped = applyOutputTransform({ ok: true }, { path: 'missing.path', missing: 'null' });\n  assert.equal(shaped, null);\n});\n\ntest('output.missing=undefined returns undefined when path is missing', () => {\n  const shaped = applyOutputTransform({ ok: true }, { path: 'missing.path', missing: 'undefined' });\n  assert.equal(shaped, undefined);\n});\n\ntest('output.missing=empty returns {} when pick/omit implies object', () => {\n  const shaped = applyOutputTransform({ ok: true }, { path: 'missing.path', missing: 'empty', pick: ['id'] });\n  assert.deepEqual(shaped, {});\n});\n\ntest('output.missing=empty returns [] when map implies array', () => {\n  const shaped = applyOutputTransform({ ok: true }, { path: 'missing.path', missing: 'empty', map: { pick: ['id'] } });\n  assert.deepEqual(shaped, []);\n});\n\ntest('output.map throws when value is not an array and missing=error', () => {\n  assert.throws(\n    () => applyOutputTransform({ rows: { id: 1 } }, { path: 'rows', map: { pick: ['id'] } }),\n    /expects an array/\n  );\n});\n\ntest('output.map returns [] when value is not an array and missing=empty', () => {\n  const shaped = applyOutputTransform(\n    { rows: { id: 1 } },\n    { path: 'rows', missing: 'empty', map: { pick: ['id'] } }\n  );\n  assert.deepEqual(shaped, []);\n});\n\ntest('output.default overrides missing behavior and still participates in map', () => {\n  const shaped = applyOutputTransform(\n    { ok: true },\n    {\n      path: 'rows',\n      missing: 'null',\n      default: [{ id: 1, secret: 'nope' }],\n      map: { pick: ['id'] },\n    }\n  );\n  assert.deepEqual(shaped, [{ id: 1 }]);\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { applyOutputTransform } = require('../src/utils/output')"
          ],
          "parent_scope": null,
          "estimated_tokens": 518,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/paths.test.ts": [
      {
        "file_path": "tests/paths.test.ts",
        "start_line": 1,
        "end_line": 89,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst path = require('node:path');\nconst os = require('node:os');\n\nconst { resolveProfileBaseDir } = require('../src/utils/paths');\n\ntest('resolveProfileBaseDir uses MCP_PROFILES_DIR override', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-paths-'));\n  const prev = process.env.MCP_PROFILES_DIR;\n\n  t.after(async () => {\n    if (prev === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prev;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n  assert.equal(resolveProfileBaseDir(), tmpRoot);\n});\n\ntest('resolveProfileBaseDir uses XDG state dir when set', async (t) => {\n  const xdgDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-xdg-state-'));\n\n  const prevProfilesDir = process.env.MCP_PROFILES_DIR;\n  const prevXdg = process.env.XDG_STATE_HOME;\n\n  t.after(async () => {\n    if (prevProfilesDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfilesDir;\n    }\n\n    if (prevXdg === undefined) {\n      delete process.env.XDG_STATE_HOME;\n    } else {\n      process.env.XDG_STATE_HOME = prevXdg;\n    }\n\n    await fs.rm(xdgDir, { recursive: true, force: true });\n  });\n\n  delete process.env.MCP_PROFILES_DIR;\n  process.env.XDG_STATE_HOME = xdgDir;\n\n  assert.equal(resolveProfileBaseDir(), path.join(xdgDir, 'sentryfrogg'));\n});\n\ntest('resolveProfileBaseDir uses HOME fallback when XDG_STATE_HOME is unset', async (t) => {\n  const homeDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-home-'));\n\n  const prevProfilesDir = process.env.MCP_PROFILES_DIR;\n  const prevXdg = process.env.XDG_STATE_HOME;\n  const prevHome = process.env.HOME;\n\n  t.after(async () => {\n    if (prevProfilesDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfilesDir;\n    }\n\n    if (prevXdg === undefined) {\n      delete process.env.XDG_STATE_HOME;\n    } else {\n      process.env.XDG_STATE_HOME = prevXdg;\n    }\n\n    if (prevHome === undefined) {\n      delete process.env.HOME;\n    } else {\n      process.env.HOME = prevHome;\n    }\n\n    await fs.rm(homeDir, { recursive: true, force: true });\n  });\n\n  delete process.env.MCP_PROFILES_DIR;\n  delete process.env.XDG_STATE_HOME;\n  process.env.HOME = homeDir;\n\n  assert.equal(resolveProfileBaseDir(), path.join(homeDir, '.local', 'state', 'sentryfrogg'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { resolveProfileBaseDir } = require('../src/utils/paths')"
          ],
          "parent_scope": null,
          "estimated_tokens": 672,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/pipeline-stream-to-artifact.test.ts": [
      {
        "file_path": "tests/pipeline-stream-to-artifact.test.ts",
        "start_line": 22,
        "end_line": 27,
        "content": "constructor(body) {\n    this.ok = true;\n    this.status = 200;\n    this.headers = new Map();\n    this.body = body;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MockResponse",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/pipeline-stream-to-artifact.test.ts",
        "start_line": 29,
        "end_line": 31,
        "content": "async text() {\n    return '';\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MockResponse",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/pipeline-stream-to-artifact.test.ts",
        "start_line": 34,
        "end_line": 40,
        "content": "function restoreEnv(key, previous) {\n  if (previous === undefined) {\n    delete process.env[key];\n  } else {\n    process.env[key] = previous;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "restoreEnv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "restoreEnv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/pipeline.test.ts": [
      {
        "file_path": "tests/pipeline.test.ts",
        "start_line": 19,
        "end_line": 24,
        "content": "constructor(body) {\n    this.ok = true;\n    this.status = 200;\n    this.headers = new Map();\n    this.body = body;\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MockResponse",
          "estimated_tokens": 32,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/pipeline.test.ts",
        "start_line": 26,
        "end_line": 28,
        "content": "async text() {\n    return '';\n  }",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Method",
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": "MockResponse",
          "estimated_tokens": 11,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/policy-service.test.ts": [
      {
        "file_path": "tests/policy-service.test.ts",
        "start_line": 1,
        "end_line": 174,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\n\nconst PolicyService = require('../src/services/PolicyService');\nconst StateService = require('../src/services/StateService');\nconst ToolError = require('../src/errors/ToolError');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('PolicyService environment lock is re-entrant (ref-counted)', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-policy-'));\n  const prevProfiles = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (prevProfiles === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfiles;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const stateService = new StateService(loggerStub);\n  await stateService.initialize();\n  const policyService = new PolicyService(loggerStub, {}, stateService);\n\n  const key = 'gitops.lock.test';\n  await policyService.acquireLock({ key, traceId: 'trace-1', ttlMs: 1000, meta: {} });\n  await policyService.acquireLock({ key, traceId: 'trace-1', ttlMs: 1000, meta: {} });\n\n  const locked = await stateService.get(key, 'persistent');\n  assert.equal(locked.value.trace_id, 'trace-1');\n  assert.equal(locked.value.count, 2);\n\n  await policyService.releaseLock({ key, traceId: 'trace-1' });\n  const stillHeld = await stateService.get(key, 'persistent');\n  assert.equal(stillHeld.value.count, 1);\n\n  await policyService.releaseLock({ key, traceId: 'trace-1' });\n  const cleared = await stateService.get(key, 'persistent');\n  assert.equal(cleared.value, undefined);\n});\n\ntest('PolicyService denies GitOps write without policy', async () => {\n  const prevAutonomyPolicy = process.env.SENTRYFROGG_AUTONOMY_POLICY;\n  const prevAutonomyFlag = process.env.SENTRYFROGG_AUTONOMY;\n  delete process.env.SENTRYFROGG_AUTONOMY_POLICY;\n  delete process.env.SENTRYFROGG_AUTONOMY;\n\n  const stateService = { get: async () => ({ value: undefined }), set: async () => {}, unset: async () => {} };\n  const policyService = new PolicyService(loggerStub, {}, stateService);\n\n  await assert.rejects(\n    () =>\n      policyService.guardGitOpsWrite({\n        intentType: 'gitops.propose',\n        inputs: { merge: true },\n        traceId: 'trace-1',\n        repoRoot: '/tmp/repo',\n      }),\n    (error) => {\n      assert.equal(ToolError.isToolError(error), true);\n      assert.equal(error.kind, 'denied');\n      assert.equal(error.code, 'POLICY_REQUIRED');\n      return true;\n    }\n  );\n\n  if (prevAutonomyPolicy === undefined) {\n    delete process.env.SENTRYFROGG_AUTONOMY_POLICY;\n  } else {\n    process.env.SENTRYFROGG_AUTONOMY_POLICY = prevAutonomyPolicy;\n  }\n  if (prevAutonomyFlag === undefined) {\n    delete process.env.SENTRYFROGG_AUTONOMY;\n  } else {\n    process.env.SENTRYFROGG_AUTONOMY = prevAutonomyFlag;\n  }\n});\n\ntest('PolicyService honors autonomy policy env for GitOps writes', async (t) => {\n  const prevAutonomyPolicy = process.env.SENTRYFROGG_AUTONOMY_POLICY;\n  const prevAutonomyFlag = process.env.SENTRYFROGG_AUTONOMY;\n\n  process.env.SENTRYFROGG_AUTONOMY_POLICY = 'operatorless';\n  delete process.env.SENTRYFROGG_AUTONOMY;\n\n  t.after(() => {\n    if (prevAutonomyPolicy === undefined) {\n      delete process.env.SENTRYFROGG_AUTONOMY_POLICY;\n    } else {\n      process.env.SENTRYFROGG_AUTONOMY_POLICY = prevAutonomyPolicy;\n    }\n    if (prevAutonomyFlag === undefined) {\n      delete process.env.SENTRYFROGG_AUTONOMY;\n    } else {\n      process.env.SENTRYFROGG_AUTONOMY = prevAutonomyFlag;\n    }\n  });\n\n  const stateService = { get: async () => ({ value: undefined }), set: async () => {}, unset: async () => {} };\n  const policyService = new PolicyService(loggerStub, {}, stateService);\n\n  const guard = await policyService.guardGitOpsWrite({\n    intentType: 'gitops.propose',\n    inputs: { merge: false },\n    traceId: 'trace-1',\n    repoRoot: '/tmp/repo',\n  });\n\n  assert.equal(guard.policy.mode, 'operatorless');\n});\n\ntest('PolicyService enforces change window when configured', async () => {\n  const stateService = { get: async () => ({ value: undefined }), set: async () => {}, unset: async () => {} };\n  const policyService = new PolicyService(loggerStub, {}, stateService);\n\n  await assert.rejects(\n    () =>\n      policyService.guardGitOpsWrite({\n        intentType: 'gitops.sync',\n        inputs: {\n          namespace: 'argocd',\n          policy: {\n            mode: 'operatorless',\n            lock: { enabled: false },\n            change_windows: [],\n          },\n        },\n        traceId: 'trace-1',\n        repoRoot: '/tmp/repo',\n      }),\n    (error) => {\n      assert.equal(ToolError.isToolError(error), true);\n      assert.equal(error.kind, 'denied');\n      assert.equal(error.code, 'POLICY_CHANGE_WINDOW');\n      return true;\n    }\n  );\n});\n\ntest('PolicyService resolves policy profile names from project context', async () => {\n  const stateService = { get: async () => ({ value: undefined }), set: async () => {}, unset: async () => {} };\n  const policyService = new PolicyService(loggerStub, {}, stateService);\n\n  const guard = await policyService.guardGitOpsWrite({\n    intentType: 'gitops.propose',\n    inputs: { policy: 'autonomy', merge: false },\n    traceId: 'trace-1',\n    repoRoot: '/tmp/repo',\n    projectContext: {\n      project: {\n        policy_profiles: {\n          autonomy: { mode: 'operatorless' },\n        },\n      },\n      target: {},\n    },\n  });\n\n  assert.equal(guard.policy.mode, 'operatorless');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1428,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/postgres-helpers.test.ts": [
      {
        "file_path": "tests/postgres-helpers.test.ts",
        "start_line": 1,
        "end_line": 90,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst PostgreSQLManager = require('../src/managers/PostgreSQLManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  warn() {},\n  error() {},\n  info() {},\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return value;\n  },\n  ensureTableName(name) {\n    return name;\n  },\n  ensureSchemaName(name) {\n    return name;\n  },\n  ensureDataObject(data) {\n    return data;\n  },\n  ensureSql(sql) {\n    return sql;\n  },\n};\n\nconst profileServiceStub = () => ({\n  async listProfiles() {\n    return [];\n  },\n  async getProfile() {\n    return { data: {}, secrets: {} };\n  },\n});\n\ntest('select builds a safe query with filters/order/limit/offset', async () => {\n  const manager = new PostgreSQLManager(loggerStub, validationStub, profileServiceStub());\n  manager.resolveConnection = async () => ({ connection: {}, poolOptions: {}, profileName: undefined });\n  manager.getPool = async () => ({});\n\n  let captured;\n  manager.executeQuery = async (_pool, sql, params) => {\n    captured = { sql, params };\n    return { rows: [], fields: [] };\n  };\n\n  await manager.select({\n    table: 'orders',\n    columns: ['id', 'status'],\n    filters: { status: 'open' },\n    order_by: { column: 'id', direction: 'DESC' },\n    limit: 5,\n    offset: 10,\n  });\n\n  assert.ok(captured.sql.includes('SELECT \"id\", \"status\" FROM \"orders\"'));\n  assert.ok(captured.sql.includes('WHERE \"status\" = $1'));\n  assert.ok(captured.sql.includes('ORDER BY \"id\" DESC'));\n  assert.ok(captured.sql.includes('LIMIT 5'));\n  assert.ok(captured.sql.includes('OFFSET 10'));\n  assert.deepEqual(captured.params, ['open']);\n});\n\ntest('count returns numeric value', async () => {\n  const manager = new PostgreSQLManager(loggerStub, validationStub, profileServiceStub());\n  manager.resolveConnection = async () => ({ connection: {}, poolOptions: {}, profileName: undefined });\n  manager.getPool = async () => ({});\n\n  manager.executeQuery = async () => ({ row: { count: '12' } });\n\n  const result = await manager.count({ table: 'orders' });\n  assert.equal(result.count, 12);\n});\n\ntest('exists returns boolean', async () => {\n  const manager = new PostgreSQLManager(loggerStub, validationStub, profileServiceStub());\n  manager.resolveConnection = async () => ({ connection: {}, poolOptions: {}, profileName: undefined });\n  manager.getPool = async () => ({});\n\n  manager.executeQuery = async () => ({ row: { exists: true } });\n\n  const result = await manager.exists({ table: 'orders' });\n  assert.equal(result.exists, true);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 645,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/postgres-manager.test.ts": [
      {
        "file_path": "tests/postgres-manager.test.ts",
        "start_line": 1,
        "end_line": 195,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\nconst PostgreSQLManager = require('../src/managers/PostgreSQLManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  warn() {},\n  error() {},\n  info() {},\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return value;\n  },\n  ensureTableName(name) {\n    return name;\n  },\n  ensureSchemaName(name) {\n    return name;\n  },\n  ensureDataObject(data) {\n    return data;\n  },\n  ensureSql(sql) {\n    return sql;\n  },\n};\n\nconst profileServiceStub = () => ({\n  stored: new Map(),\n  async setProfile(name, config) {\n    this.stored.set(name, config);\n  },\n  async listProfiles() {\n    return [];\n  },\n  async getProfile(name) {\n    return this.stored.get(name);\n  },\n  async deleteProfile(name) {\n    this.stored.delete(name);\n  },\n});\n\ntest('profileUpsert invalidates existing pool after successful update', async () => {\n  const service = profileServiceStub();\n  const manager = new PostgreSQLManager(loggerStub, validationStub, service);\n  manager.testConnection = async () => {};\n\n  let closed = false;\n  manager.pools.set('profile:default', {\n    async end() {\n      closed = true;\n    },\n  });\n\n  await manager.profileUpsert('default', {\n    connection: {\n      host: 'db.local',\n      port: 5432,\n      username: 'service',\n      password: 'secret',\n      database: 'warehouse',\n    },\n  });\n\n  assert.ok(closed, 'expected existing pool to be closed');\n  assert.equal(manager.pools.has('profile:default'), false);\n});\n\ntest('catalogColumns honours provided schema', async () => {\n  const service = profileServiceStub();\n  service.stored.set('default', {\n    data: {\n      host: 'db',\n      port: 5432,\n      username: 'x',\n      password: 'p',\n      database: 'd',\n      ssl: false,\n    },\n  });\n\n  const manager = new PostgreSQLManager(loggerStub, validationStub, service);\n  let capturedParams;\n  manager.getPool = async () => ({\n    async query(config) {\n      capturedParams = config.values;\n      return { command: 'SELECT', rowCount: 1, rows: [{ ok: true }], fields: [] };\n    },\n  });\n\n  const result = await manager.catalogColumns({ profile_name: 'default', table: 'orders', schema: 'analytics' });\n  assert.equal(result.schema, 'analytics');\n  assert.deepEqual(capturedParams, ['analytics', 'orders']);\n});\n\ntest('insert quotes identifiers and returns metadata', async () => {\n  const service = profileServiceStub();\n  const manager = new PostgreSQLManager(loggerStub, validationStub, service);\n\n  let capturedSql;\n  let capturedValues;\n  manager.getPool = async () => ({\n    async query(config) {\n      capturedSql = config.text;\n      capturedValues = config.values;\n      return { command: 'INSERT', rowCount: 1, rows: [{ id: 1 }], fields: [] };\n    },\n  });\n\n  const result = await manager.insert({\n    connection: {},\n    table: 'analytics.orders',\n    data: { status: 'new', amount: 10 },\n    returning: true,\n  });\n\n  assert.ok(capturedSql.includes('\"analytics\".\"orders\"'));\n  assert.ok(capturedSql.includes('\"status\"'));\n  assert.ok(capturedSql.includes('\"amount\"'));\n  assert.ok(capturedSql.includes('RETURNING *'));\n  assert.deepEqual(capturedValues, ['new', 10]);\n  assert.equal(result.command, 'INSERT');\n});\n\ntest('update and delete allow missing filters', async () => {\n  const service = profileServiceStub();\n  const manager = new PostgreSQLManager(loggerStub, validationStub, service);\n\n  let capturedUpdateSql;\n  let capturedDeleteSql;\n  manager.getPool = async () => ({\n    async query(config) {\n      if (config.text.startsWith('UPDATE')) {\n        capturedUpdateSql = config.text;\n      } else if (config.text.startsWith('DELETE')) {\n        capturedDeleteSql = config.text;\n      }\n      return { command: 'OK', rowCount: 0, rows: [], fields: [] };\n    },\n  });\n\n  await manager.update({ connection: {}, table: 'orders', data: { status: 'archived' } });\n  await manager.remove({ connection: {}, table: 'orders' });\n\n  assert.ok(!capturedUpdateSql.includes('WHERE'));\n  assert.ok(!capturedDeleteSql.includes('WHERE'));\n});\n\ntest('export refuses to overwrite local files by default', async () => {\n  const dir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-export-'));\n  const targetPath = path.join(dir, 'export.csv');\n  await fs.writeFile(targetPath, 'old');\n\n  const service = profileServiceStub();\n  const manager = new PostgreSQLManager(loggerStub, validationStub, service);\n\n  manager.exportToStream = async (args, stream) => new Promise((resolve, reject) => {\n    stream.write('id,name\\n1,alpha\\n', (error) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n      stream.end(() => {\n        resolve({\n          success: true,\n          table: 'items',\n          schema: 'public',\n          format: 'csv',\n          rows_written: 1,\n          duration_ms: 1,\n        });\n      });\n    });\n  });\n\n  await assert.rejects(\n    () => manager.exportData({ file_path: targetPath }),\n    /Local path already exists/\n  );\n\n  const result = await manager.exportData({ file_path: targetPath, overwrite: true });\n  assert.equal(result.success, true);\n  assert.equal(await fs.readFile(targetPath, 'utf8'), 'id,name\\n1,alpha\\n');\n\n  await fs.rm(dir, { recursive: true, force: true });\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1339,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/postgres-secretref.test.ts": [
      {
        "file_path": "tests/postgres-secretref.test.ts",
        "start_line": 1,
        "end_line": 55,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst PostgreSQLManager = require('../src/managers/PostgreSQLManager');\nconst SecretRefResolver = require('../src/services/SecretRefResolver');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {};\n\ntest('PostgreSQLManager resolves ref:env password and ssl fields in resolveConnection', async (t) => {\n  const prevPass = process.env.SF_PG_PASS;\n  const prevCa = process.env.SF_PG_CA;\n  process.env.SF_PG_PASS = 'secret';\n  process.env.SF_PG_CA = 'CA_CERT';\n\n  t.after(() => {\n    if (prevPass === undefined) {\n      delete process.env.SF_PG_PASS;\n    } else {\n      process.env.SF_PG_PASS = prevPass;\n    }\n    if (prevCa === undefined) {\n      delete process.env.SF_PG_CA;\n    } else {\n      process.env.SF_PG_CA = prevCa;\n    }\n  });\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, { ensureString: (v) => v }, null, null, null);\n  const manager = new PostgreSQLManager(loggerStub, validationStub, null, null, secretRefResolver);\n\n  const input = {\n    host: 'db.example',\n    username: 'app',\n    database: 'app',\n    password: 'ref:env:SF_PG_PASS',\n    ssl: { ca: 'ref:env:SF_PG_CA' },\n  };\n\n  const resolved = await manager.resolveConnection({ connection: input });\n\n  assert.equal(resolved.connection.password, 'secret');\n  assert.equal(resolved.connection.ssl.ca, 'CA_CERT');\n  assert.equal(input.password, 'ref:env:SF_PG_PASS', 'must not mutate input');\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 387,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/preset.test.ts": [
      {
        "file_path": "tests/preset.test.ts",
        "start_line": 20,
        "end_line": 22,
        "content": "function createTempDir() {\n  return fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-preset-'));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "createTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 24,
          "qualified_name": "createTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/profile-service.test.ts": [
      {
        "file_path": "tests/profile-service.test.ts",
        "start_line": 1,
        "end_line": 107,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst ProfileService = require('../src/services/ProfileService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst createSecurityStub = () => ({\n  async encrypt(value) {\n    return `enc(${value})`;\n  },\n  async decrypt(value) {\n    return value.replace(/^enc\\(|\\)$/g, '');\n  },\n});\n\ntest('ProfileService can remove stored secrets via null payload', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-profiles-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new ProfileService(loggerStub, createSecurityStub());\n  await service.initialize();\n\n  await service.setProfile('analytics', {\n    type: 'postgresql',\n    data: {\n      host: 'db.local',\n      port: 5432,\n      username: 'service',\n      database: 'warehouse',\n      ssl: false,\n    },\n    secrets: {\n      password: 'initial-secret',\n    },\n  });\n\n  const stored = service.profiles.get('analytics');\n  assert.ok(stored.secrets.password.startsWith('enc('));\n\n  await service.setProfile('analytics', {\n    type: 'postgresql',\n    secrets: {\n      password: null,\n    },\n  });\n\n  const updated = service.profiles.get('analytics');\n  assert.ok(!updated.secrets || updated.secrets.password === undefined);\n});\n\ntest('ProfileService probeProfileSecrets reports decrypt failures', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-profiles-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const securityStub = {\n    async encrypt(value) {\n      return `enc(${value})`;\n    },\n    async decrypt() {\n      throw new Error('decrypt failed');\n    },\n  };\n\n  const service = new ProfileService(loggerStub, securityStub);\n  await service.initialize();\n  await service.setProfile('ssh-prod', {\n    type: 'ssh',\n    data: { host: '10.0.0.1', username: 'root' },\n    secrets: { password: 'secret' },\n  });\n\n  const probe = await service.probeProfileSecrets('ssh-prod', 'ssh');\n  assert.equal(probe.ok, false);\n  assert.equal(probe.encrypted, true);\n  assert.match(probe.error, /decrypt failed/);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 715,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/project-env.test.ts": [
      {
        "file_path": "tests/project-env.test.ts",
        "start_line": 1,
        "end_line": 451,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst path = require('node:path');\nconst os = require('node:os');\nconst { Writable } = require('node:stream');\n\nconst ProjectService = require('../src/services/ProjectService');\nconst ProjectResolver = require('../src/services/ProjectResolver');\nconst ProfileService = require('../src/services/ProfileService');\nconst EnvManager = require('../src/managers/EnvManager');\nconst SSHManager = require('../src/managers/SSHManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst secretRefResolverStub = {\n  async resolveDeep(value) {\n    return value;\n  },\n};\n\nconst validationStub = {\n  ensureString(value, _label, { trim = true } = {}) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error('invalid');\n    }\n    return trim ? value.trim() : value;\n  },\n  ensurePort(value, fallback) {\n    return value ?? fallback;\n  },\n};\n\nconst securityStub = {\n  async encrypt(value) {\n    return `enc(${value})`;\n  },\n  async decrypt(value) {\n    return value.replace(/^enc\\(|\\)$/g, '');\n  },\n  cleanCommand(value) {\n    return value;\n  },\n};\n\ntest('ProjectService stores targets with ssh/env profile bindings', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-projects-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new ProjectService(loggerStub);\n  await service.initialize();\n\n  await service.setProject('myapp', {\n    default_target: 'prod',\n    targets: {\n      prod: {\n        ssh_profile: 'myapp-prod',\n        env_profile: 'myapp-prod-env',\n        postgres_profile: 'myapp-prod-db',\n        api_profile: 'myapp-prod-api',\n        vault_profile: 'myapp-vault',\n        cwd: '/opt/myapp',\n        env_path: '/opt/myapp/.env',\n      },\n    },\n  });\n\n  const stored = await service.getProject('myapp');\n  assert.equal(stored.project.name, 'myapp');\n  assert.equal(stored.project.default_target, 'prod');\n  assert.equal(stored.project.targets.prod.ssh_profile, 'myapp-prod');\n  assert.equal(stored.project.targets.prod.postgres_profile, 'myapp-prod-db');\n  assert.equal(stored.project.targets.prod.vault_profile, 'myapp-vault');\n});\n\ntest('SSHManager resolves ssh profile via project target (and active project)', async () => {\n  const calls = { profile: null };\n  const profileServiceStub = {\n    async listProfiles() {\n      return [];\n    },\n    async getProfile(name) {\n      calls.profile = name;\n      return { data: { host: '127.0.0.1', username: 'root', port: 22 }, secrets: {} };\n    },\n  };\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: { ssh_profile: 'ssh-prod' },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validationStub, projectServiceStub, stateServiceStub);\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub, resolver);\n\n  const resolved1 = await manager.resolveConnection({ project: 'myapp', target: 'prod' });\n  assert.equal(resolved1.profileName, 'ssh-prod');\n  assert.equal(calls.profile, 'ssh-prod');\n\n  calls.profile = null;\n  const resolved2 = await manager.resolveConnection({ target: 'prod' });\n  assert.equal(resolved2.profileName, 'ssh-prod');\n  assert.equal(calls.profile, 'ssh-prod');\n});\n\ntest('EnvManager write_remote uploads deterministic dotenv content (no values in response)', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const capture = { content: null, chmod: [], renames: [], exec: null };\n  const files = new Map();\n  const sshManagerStub = {\n    async withSftp(_args, handler) {\n      return handler({\n        stat(filePath, cb) {\n          if (files.has(filePath)) {\n            cb(null, {});\n            return;\n          }\n          const error = new Error('missing');\n          error.code = 2;\n          cb(error);\n        },\n        createWriteStream(remotePath) {\n          const chunks = [];\n          const stream = new Writable({\n            write(chunk, _enc, cb) {\n              chunks.push(Buffer.from(chunk).toString('utf8'));\n              cb();\n            },\n          });\n          stream.on('finish', () => {\n            files.set(remotePath, chunks.join(''));\n            capture.content = files.get('/opt/app/.env') || null;\n          });\n          return stream;\n        },\n        rename(fromPath, toPath, cb) {\n          capture.renames.push([fromPath, toPath]);\n          files.set(toPath, files.get(fromPath));\n          files.delete(fromPath);\n          capture.content = files.get('/opt/app/.env') || null;\n          cb(null);\n        },\n        unlink(filePath, cb) {\n          files.delete(filePath);\n          cb(null);\n        },\n        chmod(filePath, mode, cb) {\n          capture.chmod.push({ path: filePath, mode });\n          cb(null);\n        },\n      });\n    },\n    async ensureRemoteDir() {},\n    async execCommand(args) {\n      capture.exec = args;\n      return { exitCode: 0, stdout: 'ok', stderr: '', command: args.command, signal: null, timedOut: false, duration_ms: 1 };\n    },\n  };\n\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, null, secretRefResolverStub);\n\n  await envManager.profileUpsert('bundle', {\n    secrets: {\n      B: 'hello world',\n      A: '1',\n      C: 'line\\nbreak',\n    },\n  });\n\n  const result = await envManager.writeRemote({\n    profile_name: 'bundle',\n    ssh_profile_name: 'ssh1',\n    remote_path: '/opt/app/.env',\n    mkdirs: true,\n    mode: 0o600,\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.remote_path, '/opt/app/.env');\n  assert.deepEqual(result.variables.keys, ['A', 'B', 'C']);\n\n  assert.equal(capture.content, 'A=\"1\"\\nB=\"hello world\"\\nC=\"line\\\\nbreak\"\\n');\n  assert.ok(capture.renames.some(([, to]) => to === '/opt/app/.env'));\n  assert.ok(capture.chmod.some((entry) => entry.path === '/opt/app/.env' && entry.mode === 0o600));\n});\n\ntest('EnvManager write_remote refuses to overwrite existing remote_path by default', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const files = new Map([['/opt/app/.env', 'EXISTING=1\\n']]);\n  const sshManagerStub = {\n    async withSftp(_args, handler) {\n      return handler({\n        stat(filePath, cb) {\n          if (files.has(filePath)) {\n            cb(null, {});\n            return;\n          }\n          const error = new Error('missing');\n          error.code = 2;\n          cb(error);\n        },\n        createWriteStream() {\n          throw new Error('should not write when overwrite=false');\n        },\n        rename(_from, _to, cb) {\n          cb(new Error('should not rename when overwrite=false'));\n        },\n        unlink(_path, cb) {\n          cb(null);\n        },\n      });\n    },\n    async ensureRemoteDir() {},\n    async execCommand() {\n      throw new Error('not used');\n    },\n  };\n\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, null, secretRefResolverStub);\n\n  await envManager.profileUpsert('bundle', {\n    secrets: { A: '1' },\n  });\n\n  await assert.rejects(\n    () => envManager.writeRemote({\n      profile_name: 'bundle',\n      ssh_profile_name: 'ssh1',\n      remote_path: '/opt/app/.env',\n    }),\n    /Remote path already exists/\n  );\n});\n\ntest('EnvManager write_remote defaults remote_path from project target.env_path', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: { env_path: '/opt/app/.env', cwd: '/opt/app' },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validationStub, projectServiceStub, stateServiceStub);\n\n  const files = new Map();\n  const sshManagerStub = {\n    async withSftp(_args, handler) {\n      return handler({\n        stat(filePath, cb) {\n          if (files.has(filePath)) {\n            cb(null, {});\n            return;\n          }\n          const error = new Error('missing');\n          error.code = 2;\n          cb(error);\n        },\n        createWriteStream(remotePath) {\n          const chunks = [];\n          const stream = new Writable({\n            write(chunk, _enc, cb) {\n              chunks.push(Buffer.from(chunk).toString('utf8'));\n              cb();\n            },\n          });\n          stream.on('finish', () => {\n            files.set(remotePath, chunks.join(''));\n          });\n          return stream;\n        },\n        rename(fromPath, toPath, cb) {\n          files.set(toPath, files.get(fromPath));\n          files.delete(fromPath);\n          cb(null);\n        },\n        unlink(filePath, cb) {\n          files.delete(filePath);\n          cb(null);\n        },\n      });\n    },\n    async ensureRemoteDir() {},\n    async execCommand() {\n      throw new Error('not used');\n    },\n  };\n\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, resolver, secretRefResolverStub);\n\n  await envManager.profileUpsert('bundle', { secrets: { A: '1' } });\n\n  const result = await envManager.writeRemote({\n    profile_name: 'bundle',\n    ssh_profile_name: 'ssh1',\n    target: 'prod',\n    mkdirs: true,\n  });\n\n  assert.equal(result.remote_path, '/opt/app/.env');\n  assert.equal(files.get('/opt/app/.env'), 'A=\"1\"\\n');\n});\n\ntest('EnvManager run_remote defaults cwd from project target.cwd', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-env-'));\n  const previousDir = process.env.MCP_PROFILES_DIR;\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  t.after(async () => {\n    if (previousDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = previousDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const profileService = new ProfileService(loggerStub, securityStub);\n  await profileService.initialize();\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: { cwd: '/opt/app' },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validationStub, projectServiceStub, stateServiceStub);\n\n  let received;\n  const sshManagerStub = {\n    async execCommand(args) {\n      received = args;\n      return { exitCode: 0, stdout: 'ok', stderr: '', command: args.command, signal: null, timedOut: false, duration_ms: 1 };\n    },\n  };\n\n  const envManager = new EnvManager(loggerStub, validationStub, profileService, sshManagerStub, resolver, secretRefResolverStub);\n\n  await envManager.profileUpsert('bundle', { secrets: { A: '1' } });\n\n  await envManager.runRemote({\n    profile_name: 'bundle',\n    ssh_profile_name: 'ssh1',\n    target: 'prod',\n    command: 'pwd',\n  });\n\n  assert.equal(received.cwd, '/opt/app');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { Writable } = require('node:stream')"
          ],
          "parent_scope": null,
          "estimated_tokens": 3281,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/project-profile-resolution.test.ts": [
      {
        "file_path": "tests/project-profile-resolution.test.ts",
        "start_line": 1,
        "end_line": 229,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst { Readable } = require('node:stream');\n\nconst Validation = require('../src/services/Validation');\nconst ProjectResolver = require('../src/services/ProjectResolver');\nconst PostgreSQLManager = require('../src/managers/PostgreSQLManager');\nconst APIManager = require('../src/managers/APIManager');\nconst PipelineManager = require('../src/managers/PipelineManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  warn() {},\n  info() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureUrl(url) {\n    return new URL(url);\n  },\n};\n\ntest('PostgreSQLManager resolves profile via project target (and active project)', async () => {\n  const validation = new Validation(loggerStub);\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: { postgres_profile: 'pg-prod' },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validation, projectServiceStub, stateServiceStub);\n  const manager = new PostgreSQLManager(loggerStub, validation, { async listProfiles() { return []; } }, resolver);\n\n  assert.equal(await manager.resolveProfileName(undefined, { project: 'myapp', target: 'prod' }), 'pg-prod');\n  assert.equal(await manager.resolveProfileName(undefined, { target: 'prod' }), 'pg-prod');\n});\n\ntest('PostgreSQLManager errors when project target has no postgres_profile', async () => {\n  const validation = new Validation(loggerStub);\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: { prod: {} },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validation, projectServiceStub, stateServiceStub);\n  const manager = new PostgreSQLManager(loggerStub, validation, { async listProfiles() { return []; } }, resolver);\n\n  await assert.rejects(\n    () => manager.resolveProfileName(undefined, { target: 'prod' }),\n    /missing postgres_profile/\n  );\n});\n\ntest('APIManager defaults profile via project target when resolvable', async () => {\n  const validation = new Validation(loggerStub);\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: { api_profile: 'api-prod' },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validation, projectServiceStub, stateServiceStub);\n\n  let usedProfile = null;\n  const profileServiceStub = {\n    async listProfiles() {\n      return [];\n    },\n    async getProfile(name) {\n      usedProfile = name;\n      return { data: {}, secrets: {} };\n    },\n  };\n\n  const manager = new APIManager(loggerStub, securityStub, validation, profileServiceStub, null, { projectResolver: resolver });\n  await manager.resolveProfile(undefined, { target: 'prod' });\n  assert.equal(usedProfile, 'api-prod');\n});\n\ntest('PipelineManager injects project target profiles into http/postgres/sftp defaults', async () => {\n  const validation = new Validation(loggerStub);\n\n  const projectServiceStub = {\n    async getProject() {\n      return {\n        project: {\n          default_target: 'prod',\n          targets: {\n            prod: {\n              api_profile: 'api-prod',\n              postgres_profile: 'pg-prod',\n              ssh_profile: 'ssh-prod',\n            },\n          },\n        },\n      };\n    },\n  };\n\n  const stateServiceStub = {\n    async get() {\n      return { value: 'myapp' };\n    },\n  };\n\n  const resolver = new ProjectResolver(validation, projectServiceStub, stateServiceStub);\n\n  let resolvedHttpProfile = null;\n  const apiManager = {\n    async resolveProfile(profileName) {\n      resolvedHttpProfile = profileName;\n      return { name: profileName, data: {}, auth: undefined, authProvider: undefined, retry: undefined };\n    },\n    async resolveAuthProvider() {\n      return undefined;\n    },\n    buildRequestConfig() {\n      return { url: 'http://local', method: 'GET', headers: {} };\n    },\n    async fetchWithRetry() {\n      return { response: { ok: true, status: 200, headers: new Map(), body: Readable.from('{\"id\":1}\\n') }, config: {}, duration_ms: 1, attempts: 1, retries: 0 };\n    },\n  };\n\n  let usedPostgresProfile = null;\n  const postgresqlManager = {\n    async insertBulk(args) {\n      usedPostgresProfile = args.profile_name;\n      return { inserted: 1 };\n    },\n    exportStream() {\n      return {\n        stream: Readable.from('id\\n1\\n'),\n        completion: Promise.resolve({ rows_written: 1, format: 'csv', table: 'items', schema: 'public', duration_ms: 1 }),\n      };\n    },\n  };\n\n  let usedSftpProfile = null;\n  const sftp = {\n    stat(_path, cb) {\n      const error = new Error('missing');\n      error.code = 2;\n      cb(error);\n    },\n    createWriteStream() {\n      return new (require('node:stream').PassThrough)();\n    },\n  };\n\n  const sshManager = {\n    async withSftp(args, fn) {\n      usedSftpProfile = args.profile_name;\n      return fn(sftp);\n    },\n    async ensureRemoteDir() {},\n  };\n\n  const pipeline = new PipelineManager(loggerStub, validation, apiManager, sshManager, postgresqlManager, null, null, resolver);\n\n  await pipeline.handleAction({\n    action: 'run',\n    flow: 'http_to_postgres',\n    target: 'prod',\n    http: { url: 'http://local' },\n    postgres: { table: 'items' },\n    format: 'jsonl',\n  });\n\n  assert.equal(resolvedHttpProfile, 'api-prod');\n  assert.equal(usedPostgresProfile, 'pg-prod');\n\n  await pipeline.handleAction({\n    action: 'run',\n    flow: 'postgres_to_sftp',\n    target: 'prod',\n    postgres: { table: 'items' },\n    sftp: { remote_path: '/tmp/items.csv' },\n    format: 'csv',\n  });\n\n  assert.equal(usedSftpProfile, 'ssh-prod');\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { Readable } = require('node:stream')"
          ],
          "parent_scope": null,
          "estimated_tokens": 1539,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/project-service.test.ts": [
      {
        "file_path": "tests/project-service.test.ts",
        "start_line": 1,
        "end_line": 104,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst ProjectService = require('../src/services/ProjectService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('ProjectService persists and lists projects', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-projects-'));\n  const previousPath = process.env.MCP_PROJECTS_PATH;\n  process.env.MCP_PROJECTS_PATH = path.join(tmpRoot, 'projects.json');\n\n  t.after(async () => {\n    if (previousPath === undefined) {\n      delete process.env.MCP_PROJECTS_PATH;\n    } else {\n      process.env.MCP_PROJECTS_PATH = previousPath;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new ProjectService(loggerStub);\n  await service.initialize();\n\n  const payload = {\n    description: 'Demo project',\n    default_target: 'prod',\n    targets: {\n      prod: {\n        ssh_profile: 'demo-prod-ssh',\n        env_profile: 'demo-prod-env',\n      },\n    },\n  };\n\n  const saved = await service.setProject('demo', payload);\n  assert.equal(saved.success, true);\n  assert.equal(saved.project.name, 'demo');\n\n  const fetched = await service.getProject('demo');\n  assert.equal(fetched.project.default_target, 'prod');\n  assert.equal(fetched.project.targets.prod.ssh_profile, 'demo-prod-ssh');\n\n  const list = await service.listProjects();\n  assert.equal(list.projects.length, 1);\n  assert.equal(list.projects[0].name, 'demo');\n\n  const removed = await service.deleteProject('demo');\n  assert.equal(removed.project, 'demo');\n\n  const listAfter = await service.listProjects();\n  assert.equal(listAfter.projects.length, 0);\n});\n\ntest('ProjectService accepts policy profiles and target policy references', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-projects-'));\n  const previousPath = process.env.MCP_PROJECTS_PATH;\n  process.env.MCP_PROJECTS_PATH = path.join(tmpRoot, 'projects.json');\n\n  t.after(async () => {\n    if (previousPath === undefined) {\n      delete process.env.MCP_PROJECTS_PATH;\n    } else {\n      process.env.MCP_PROJECTS_PATH = previousPath;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const service = new ProjectService(loggerStub);\n  await service.initialize();\n\n  const payload = {\n    description: 'Policy profile project',\n    policy_profiles: {\n      autonomy: {\n        mode: 'operatorless',\n        lock: { enabled: false },\n      },\n    },\n    targets: {\n      prod: {\n        ssh_profile: 'demo-prod-ssh',\n        policy: 'autonomy',\n      },\n    },\n  };\n\n  const saved = await service.setProject('policy-demo', payload);\n  assert.equal(saved.success, true);\n\n  const fetched = await service.getProject('policy-demo');\n  assert.equal(fetched.project.policy_profiles.autonomy.mode, 'operatorless');\n  assert.equal(fetched.project.targets.prod.policy, 'autonomy');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 764,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-exec-allowlist.test.ts": [
      {
        "file_path": "tests/repo-exec-allowlist.test.ts",
        "start_line": 58,
        "end_line": 60,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-exec-budgets.test.ts": [
      {
        "file_path": "tests/repo-exec-budgets.test.ts",
        "start_line": 59,
        "end_line": 61,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-git-primitives.test.ts": [
      {
        "file_path": "tests/repo-git-primitives.test.ts",
        "start_line": 59,
        "end_line": 61,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-manager.test.ts": [
      {
        "file_path": "tests/repo-manager.test.ts",
        "start_line": 1,
        "end_line": 68,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst os = require('node:os');\nconst path = require('node:path');\nconst { execFileSync } = require('node:child_process');\n\nconst RepoManager = require('../src/managers/RepoManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst securityStub = {\n  ensureSizeFits() {},\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return String(value);\n  },\n};\n\ntest('RepoManager rejects unknown actions', async () => {\n  const manager = new RepoManager(loggerStub, securityStub, validationStub, null);\n  await assert.rejects(() => manager.handleAction({ action: 'nope' }), /Unknown repo action/);\n});\n\ntest('RepoManager assert_clean rejects dirty worktrees', async () => {\n  const manager = new RepoManager(loggerStub, securityStub, validationStub, null);\n  const repoRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sf-repo-assert-clean-'));\n\n  try {\n    await fs.writeFile(path.join(repoRoot, 'README.md'), '# demo\\n', 'utf8');\n\n    execFileSync('git', ['init'], { cwd: repoRoot, stdio: 'ignore' });\n    execFileSync('git', ['config', 'user.name', 'Test'], { cwd: repoRoot, stdio: 'ignore' });\n    execFileSync('git', ['config', 'user.email', 'test@example.com'], { cwd: repoRoot, stdio: 'ignore' });\n    execFileSync('git', ['add', '-A'], { cwd: repoRoot, stdio: 'ignore' });\n    execFileSync('git', ['commit', '-m', 'init'], { cwd: repoRoot, stdio: 'ignore' });\n\n    const clean = await manager.handleAction({ action: 'assert_clean', repo_root: repoRoot });\n    assert.equal(clean.success, true);\n    assert.equal(clean.clean, true);\n\n    await fs.writeFile(path.join(repoRoot, 'README.md'), '# demo\\n\\nchanged\\n', 'utf8');\n    await assert.rejects(\n      () => manager.handleAction({ action: 'assert_clean', repo_root: repoRoot }),\n      /Repository is dirty/\n    );\n\n    execFileSync('git', ['checkout', '--', 'README.md'], { cwd: repoRoot, stdio: 'ignore' });\n    await fs.writeFile(path.join(repoRoot, 'untracked.txt'), 'hi\\n', 'utf8');\n\n    await assert.rejects(\n      () => manager.handleAction({ action: 'assert_clean', repo_root: repoRoot }),\n      /Repository is dirty/\n    );\n  } finally {\n    await fs.rm(repoRoot, { recursive: true, force: true });\n  }\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { execFileSync } = require('node:child_process')"
          ],
          "parent_scope": null,
          "estimated_tokens": 604,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-policy.test.ts": [
      {
        "file_path": "tests/repo-policy.test.ts",
        "start_line": 36,
        "end_line": 38,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/repo-policy.test.ts",
        "start_line": 40,
        "end_line": 48,
        "content": "async function writeKubectlStub(dir) {\n  const scriptPath = path.join(dir, 'kubectl');\n  const body = `#!/usr/bin/env node\nprocess.stdout.write('ok\\\\n');\nprocess.exit(0);\n`;\n  await fs.writeFile(scriptPath, body, { encoding: 'utf8', mode: 0o755 });\n  return scriptPath;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "writeKubectlStub",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 67,
          "qualified_name": "writeKubectlStub",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/repo-render.test.ts": [
      {
        "file_path": "tests/repo-render.test.ts",
        "start_line": 59,
        "end_line": 61,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/runbook-dsl.test.ts": [
      {
        "file_path": "tests/runbook-dsl.test.ts",
        "start_line": 1,
        "end_line": 71,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst RunbookManager = require('../src/managers/RunbookManager');\nconst { parseRunbookDsl } = require('../src/utils/runbookDsl');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  warn() {},\n  info() {},\n  error() {},\n};\n\nconst stateServiceStub = () => ({\n  state: {},\n  async set(key, value) {\n    this.state[key] = value;\n  },\n  async dump() {\n    return { state: { ...this.state } };\n  },\n});\n\nconst runbookServiceStub = () => ({\n  async getRunbook() {\n    throw new Error('not used');\n  },\n  async setRunbook() {},\n  async listRunbooks() {\n    return { success: true, runbooks: [] };\n  },\n  async deleteRunbook() {},\n});\n\ntest('parseRunbookDsl builds a runbook', () => {\n  const dsl = `runbook sample\\nstep ping mcp_api_client request\\narg url=https://{{input.host}}/health`;\n  const runbook = parseRunbookDsl(dsl);\n  assert.equal(runbook.name, 'sample');\n  assert.equal(runbook.steps.length, 1);\n  assert.equal(runbook.steps[0].tool, 'mcp_api_client');\n  assert.equal(runbook.steps[0].args.action, 'request');\n  assert.equal(runbook.steps[0].args.url, 'https://{{input.host}}/health');\n});\n\ntest('RunbookManager executes DSL runs', async () => {\n  const toolExecutor = {\n    async execute(tool, args) {\n      return { result: { tool, args }, meta: { tool } };\n    },\n  };\n\n  const manager = new RunbookManager(\n    loggerStub,\n    runbookServiceStub(),\n    stateServiceStub(),\n    toolExecutor\n  );\n\n  const dsl = `step ping mcp_api_client request\\narg url=https://{{input.host}}/health`;\n  const result = await manager.handleAction({\n    action: 'runbook_run_dsl',\n    dsl,\n    input: { host: 'example.com' },\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.steps[0].result.args.url, 'https://example.com/health');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { parseRunbookDsl } = require('../src/utils/runbookDsl')"
          ],
          "parent_scope": null,
          "estimated_tokens": 477,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/runbook-manager.test.ts": [
      {
        "file_path": "tests/runbook-manager.test.ts",
        "start_line": 1,
        "end_line": 238,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst RunbookService = require('../src/services/RunbookService');\nconst StateService = require('../src/services/StateService');\nconst RunbookManager = require('../src/managers/RunbookManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('RunbookManager resolves templates and forwards args to tools', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-runbooks-'));\n  const previousRunbooks = process.env.MCP_RUNBOOKS_PATH;\n  const previousState = process.env.MCP_STATE_PATH;\n  process.env.MCP_RUNBOOKS_PATH = path.join(tmpRoot, 'runbooks.json');\n  process.env.MCP_STATE_PATH = path.join(tmpRoot, 'state.json');\n\n  t.after(async () => {\n    if (previousRunbooks === undefined) {\n      delete process.env.MCP_RUNBOOKS_PATH;\n    } else {\n      process.env.MCP_RUNBOOKS_PATH = previousRunbooks;\n    }\n    if (previousState === undefined) {\n      delete process.env.MCP_STATE_PATH;\n    } else {\n      process.env.MCP_STATE_PATH = previousState;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const runbookPayload = {\n    'demo.echo': {\n      description: 'Template resolution smoke test',\n      steps: [\n        {\n          id: 'first',\n          tool: 'mcp_api_client',\n          args: {\n            action: 'request',\n            url: 'https://example.com/{{ input.path }}',\n            optional: '{{ ?input.optional }}',\n          },\n        },\n        {\n          id: 'second',\n          tool: 'mcp_api_client',\n          args: {\n            action: 'request',\n            url: '{{ steps.first.received.url }}?ok=1',\n          },\n        },\n      ],\n    },\n  };\n\n  await fs.writeFile(process.env.MCP_RUNBOOKS_PATH, `${JSON.stringify(runbookPayload, null, 2)}\\n`);\n\n  const runbookService = new RunbookService(loggerStub);\n  await runbookService.initialize();\n  const stateService = new StateService(loggerStub);\n  await stateService.initialize();\n\n  const calls = [];\n  const toolExecutor = {\n    async execute(tool, args) {\n      calls.push({ tool, args });\n      return { result: { received: args }, meta: { tool } };\n    },\n  };\n\n  const manager = new RunbookManager(loggerStub, runbookService, stateService, toolExecutor);\n  const result = await manager.handleAction({\n    action: 'runbook_run',\n    name: 'demo.echo',\n    input: { path: 'status' },\n    trace_id: 'trace-1',\n    span_id: 'span-1',\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.steps.length, 2);\n\n  assert.equal(calls[0].tool, 'mcp_api_client');\n  assert.equal(calls[0].args.url, 'https://example.com/status');\n  assert.equal(calls[0].args.optional, '');\n  assert.equal(calls[0].args.trace_id, 'trace-1');\n  assert.equal(calls[0].args.parent_span_id, 'span-1');\n\n  assert.equal(calls[1].args.url, 'https://example.com/status?ok=1');\n});\n\ntest('RunbookManager retries a step until retry.until matches', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-runbooks-'));\n  const previousRunbooks = process.env.MCP_RUNBOOKS_PATH;\n  const previousState = process.env.MCP_STATE_PATH;\n  process.env.MCP_RUNBOOKS_PATH = path.join(tmpRoot, 'runbooks.json');\n  process.env.MCP_STATE_PATH = path.join(tmpRoot, 'state.json');\n\n  t.after(async () => {\n    if (previousRunbooks === undefined) {\n      delete process.env.MCP_RUNBOOKS_PATH;\n    } else {\n      process.env.MCP_RUNBOOKS_PATH = previousRunbooks;\n    }\n    if (previousState === undefined) {\n      delete process.env.MCP_STATE_PATH;\n    } else {\n      process.env.MCP_STATE_PATH = previousState;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const runbookPayload = {\n    'demo.retry': {\n      description: 'Retry engine smoke test',\n      steps: [\n        {\n          id: 'probe',\n          tool: 'mcp_api_client',\n          retry: {\n            max_attempts: 5,\n            delay_ms: 0,\n            until: { path: 'result.attempt', gte: 3 },\n          },\n          args: {\n            action: 'request',\n            url: 'https://example.com',\n          },\n        },\n      ],\n    },\n  };\n\n  await fs.writeFile(process.env.MCP_RUNBOOKS_PATH, `${JSON.stringify(runbookPayload, null, 2)}\\n`);\n\n  const runbookService = new RunbookService(loggerStub);\n  await runbookService.initialize();\n  const stateService = new StateService(loggerStub);\n  await stateService.initialize();\n\n  let attempt = 0;\n  const toolExecutor = {\n    async execute() {\n      attempt += 1;\n      return { result: { attempt }, meta: {} };\n    },\n  };\n\n  const manager = new RunbookManager(loggerStub, runbookService, stateService, toolExecutor);\n  const result = await manager.handleAction({\n    action: 'runbook_run',\n    name: 'demo.retry',\n    input: {},\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(attempt, 3);\n  assert.equal(result.steps[0].retry.attempts, 3);\n});\n\ntest('RunbookManager fails when retry condition is not satisfied in time', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-runbooks-'));\n  const previousRunbooks = process.env.MCP_RUNBOOKS_PATH;\n  const previousState = process.env.MCP_STATE_PATH;\n  process.env.MCP_RUNBOOKS_PATH = path.join(tmpRoot, 'runbooks.json');\n  process.env.MCP_STATE_PATH = path.join(tmpRoot, 'state.json');\n\n  t.after(async () => {\n    if (previousRunbooks === undefined) {\n      delete process.env.MCP_RUNBOOKS_PATH;\n    } else {\n      process.env.MCP_RUNBOOKS_PATH = previousRunbooks;\n    }\n    if (previousState === undefined) {\n      delete process.env.MCP_STATE_PATH;\n    } else {\n      process.env.MCP_STATE_PATH = previousState;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  const runbookPayload = {\n    'demo.retry.fail': {\n      description: 'Retry failure',\n      steps: [\n        {\n          id: 'probe',\n          tool: 'mcp_api_client',\n          retry: {\n            max_attempts: 2,\n            delay_ms: 0,\n            until: { path: 'result.ready', equals: true },\n          },\n          args: {\n            action: 'request',\n            url: 'https://example.com',\n          },\n        },\n      ],\n    },\n  };\n\n  await fs.writeFile(process.env.MCP_RUNBOOKS_PATH, `${JSON.stringify(runbookPayload, null, 2)}\\n`);\n\n  const runbookService = new RunbookService(loggerStub);\n  await runbookService.initialize();\n  const stateService = new StateService(loggerStub);\n  await stateService.initialize();\n\n  let attempt = 0;\n  const toolExecutor = {\n    async execute() {\n      attempt += 1;\n      return { result: { ready: false, attempt }, meta: {} };\n    },\n  };\n\n  const manager = new RunbookManager(loggerStub, runbookService, stateService, toolExecutor);\n  const result = await manager.handleAction({\n    action: 'runbook_run',\n    name: 'demo.retry.fail',\n    input: {},\n  });\n\n  assert.equal(result.success, false);\n  assert.equal(attempt, 2);\n  assert.ok(result.error);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1776,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/runbook.test.ts": [
      {
        "file_path": "tests/runbook.test.ts",
        "start_line": 1,
        "end_line": 83,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst RunbookManager = require('../src/managers/RunbookManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  warn() {},\n  info() {},\n  error() {},\n};\n\nconst stateServiceStub = () => ({\n  state: {},\n  async set(key, value) {\n    this.state[key] = value;\n  },\n  async dump() {\n    return { state: { ...this.state } };\n  },\n});\n\nconst runbookServiceStub = () => ({\n  async getRunbook() {\n    throw new Error('not used');\n  },\n  async setRunbook() {},\n  async listRunbooks() {\n    return { success: true, runbooks: [] };\n  },\n  async deleteRunbook() {},\n});\n\ntest('RunbookManager resolves templates, foreach, and when clauses', async () => {\n  const toolExecutor = {\n    async execute(tool, args) {\n      return { result: { tool, args }, meta: { tool } };\n    },\n  };\n\n  const manager = new RunbookManager(\n    loggerStub,\n    runbookServiceStub(),\n    stateServiceStub(),\n    toolExecutor\n  );\n\n  const runbook = {\n    steps: [\n      {\n        id: 'ping',\n        tool: 'mcp_api_client',\n        args: { action: 'request', url: 'https://{{input.host}}/{{input.path}}' },\n      },\n      {\n        id: 'loop',\n        tool: 'mcp_api_client',\n        foreach: { items: '{{input.ids}}' },\n        args: { action: 'request', query: { id: '{{item}}' } },\n      },\n      {\n        id: 'skipme',\n        tool: 'mcp_api_client',\n        when: { path: 'input.enabled', equals: true },\n        args: { action: 'request', url: 'https://{{input.host}}/skip' },\n      },\n    ],\n  };\n\n  const result = await manager.runbookRun({\n    runbook,\n    input: { host: 'example.com', path: 'health', ids: [1, 2], enabled: false },\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.steps[0].result.args.url, 'https://example.com/health');\n  assert.equal(result.steps[1].result.length, 2);\n  assert.equal(result.steps[1].result[0].args.query.id, 1);\n  assert.equal(result.steps[1].result[1].args.query.id, 2);\n  assert.equal(result.steps[2].skipped, true);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 515,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/sandbox.test.ts": [
      {
        "file_path": "tests/sandbox.test.ts",
        "start_line": 10,
        "end_line": 12,
        "content": "async function makeTempDir(prefix) {\n  return fs.mkdtemp(path.join(os.tmpdir(), prefix));\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeTempDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 22,
          "qualified_name": "makeTempDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/schema-openai-compat.test.ts": [
      {
        "file_path": "tests/schema-openai-compat.test.ts",
        "start_line": 23,
        "end_line": 75,
        "content": "function validateOpenAICompatibleJsonSchema(schema, path = []) {\n  const errors = [];\n\n  function walk(node, nodePath) {\n    if (node === null || node === undefined) {\n      return;\n    }\n    if (typeof node !== 'object') {\n      return;\n    }\n    if (Array.isArray(node)) {\n      node.forEach((item, idx) => walk(item, nodePath.concat(idx)));\n      return;\n    }\n\n    if (Array.isArray(node.type)) {\n      errors.push({\n        kind: 'type-union-array',\n        path: nodePath.concat('type').join('.'),\n      });\n    }\n\n    if (node.type === 'array' && node.items === undefined) {\n      errors.push({\n        kind: 'array-missing-items',\n        path: nodePath.join('.'),\n      });\n    }\n\n    if (node.properties && typeof node.properties === 'object') {\n      for (const [key, value] of Object.entries(node.properties)) {\n        walk(value, nodePath.concat('properties', key));\n      }\n    }\n\n    if (node.items !== undefined) {\n      walk(node.items, nodePath.concat('items'));\n    }\n\n    if (node.additionalProperties && typeof node.additionalProperties === 'object') {\n      walk(node.additionalProperties, nodePath.concat('additionalProperties'));\n    }\n\n    for (const keyword of ['anyOf', 'oneOf', 'allOf']) {\n      if (Array.isArray(node[keyword])) {\n        node[keyword].forEach((sub, idx) => walk(sub, nodePath.concat(keyword, idx)));\n      }\n    }\n  }\n\n  walk(schema, path);\n  return errors;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "validateOpenAICompatibleJsonSchema",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 351,
          "qualified_name": "validateOpenAICompatibleJsonSchema",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/secret-export-gate.test.ts": [
      {
        "file_path": "tests/secret-export-gate.test.ts",
        "start_line": 36,
        "end_line": 60,
        "content": "function setExportFlag(t, value) {\n  const prevA = process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT;\n  const prevB = process.env.SF_ALLOW_SECRET_EXPORT;\n\n  if (value === null) {\n    delete process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT;\n    delete process.env.SF_ALLOW_SECRET_EXPORT;\n  } else {\n    process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT = value;\n    delete process.env.SF_ALLOW_SECRET_EXPORT;\n  }\n\n  t.after(() => {\n    if (prevA === undefined) {\n      delete process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT;\n    } else {\n      process.env.SENTRYFROGG_ALLOW_SECRET_EXPORT = prevA;\n    }\n    if (prevB === undefined) {\n      delete process.env.SF_ALLOW_SECRET_EXPORT;\n    } else {\n      process.env.SF_ALLOW_SECRET_EXPORT = prevB;\n    }\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "setExportFlag",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 184,
          "qualified_name": "setExportFlag",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/secret-ref-resolver.test.ts": [
      {
        "file_path": "tests/secret-ref-resolver.test.ts",
        "start_line": 1,
        "end_line": 135,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst SecretRefResolver = require('../src/services/SecretRefResolver');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensureString(value, _label, { trim = true } = {}) {\n    if (typeof value !== 'string' || value.trim().length === 0) {\n      throw new Error('invalid');\n    }\n    return trim ? value.trim() : value;\n  },\n};\n\ntest('SecretRefResolver resolves ref:env:* values', async (t) => {\n  const previous = process.env.SF_TEST_SECRET;\n  process.env.SF_TEST_SECRET = 'ok';\n\n  t.after(() => {\n    if (previous === undefined) {\n      delete process.env.SF_TEST_SECRET;\n    } else {\n      process.env.SF_TEST_SECRET = previous;\n    }\n  });\n\n  const resolver = new SecretRefResolver(loggerStub, validationStub, null, null, null);\n  const resolved = await resolver.resolveDeep('ref:env:SF_TEST_SECRET', {});\n  assert.equal(resolved, 'ok');\n});\n\ntest('SecretRefResolver selects vault profile by args.vault_profile_name', async () => {\n  const calls = [];\n  const resolver = new SecretRefResolver(\n    loggerStub,\n    validationStub,\n    { async listProfiles() { return [{ name: 'ignored' }]; } },\n    { async kv2Get(profileName, ref) { calls.push({ profileName, ref }); return `v:${profileName}:${ref}`; } },\n    { async resolveContext() { return { target: { vault_profile: 'ignored' } }; } }\n  );\n\n  const input = { db: 'ref:vault:kv2:secret/app#DATABASE_URL' };\n  const resolved = await resolver.resolveDeep(input, { vault_profile_name: 'explicit' });\n\n  assert.deepEqual(resolved, { db: 'v:explicit:secret/app#DATABASE_URL' });\n  assert.deepEqual(input, { db: 'ref:vault:kv2:secret/app#DATABASE_URL' }, 'must not mutate input');\n  assert.equal(calls.length, 1);\n  assert.deepEqual(calls[0], { profileName: 'explicit', ref: 'secret/app#DATABASE_URL' });\n});\n\ntest('SecretRefResolver selects vault profile by project target', async () => {\n  const calls = [];\n  const resolver = new SecretRefResolver(\n    loggerStub,\n    validationStub,\n    { async listProfiles() { return [{ name: 'ignored' }]; } },\n    { async kv2Get(profileName, ref) { calls.push({ profileName, ref }); return `v:${profileName}:${ref}`; } },\n    { async resolveContext() { return { target: { vault_profile: 'from-project' } }; } }\n  );\n\n  const resolved = await resolver.resolveDeep(\n    { token: 'ref:vault:kv2:kv/app#token' },\n    { project: 'demo', target: 'prod' }\n  );\n\n  assert.deepEqual(resolved, { token: 'v:from-project:kv/app#token' });\n  assert.equal(calls[0].profileName, 'from-project');\n});\n\ntest('SecretRefResolver selects vault profile when there is exactly one vault profile', async () => {\n  const calls = [];\n  const resolver = new SecretRefResolver(\n    loggerStub,\n    validationStub,\n    { async listProfiles() { return [{ name: 'only' }]; } },\n    { async kv2Get(profileName, ref) { calls.push({ profileName, ref }); return `v:${profileName}:${ref}`; } },\n    { async resolveContext() { return null; } }\n  );\n\n  const resolved = await resolver.resolveDeep({ v: 'ref:vault:kv2:secret/app#k' }, {});\n  assert.deepEqual(resolved, { v: 'v:only:secret/app#k' });\n});\n\ntest('SecretRefResolver errors when multiple vault profiles exist and none is selected', async () => {\n  const resolver = new SecretRefResolver(\n    loggerStub,\n    validationStub,\n    { async listProfiles() { return [{ name: 'a' }, { name: 'b' }]; } },\n    { async kv2Get() { return 'nope'; } },\n    { async resolveContext() { return null; } }\n  );\n\n  await assert.rejects(\n    () => resolver.resolveDeep('ref:vault:kv2:secret/app#k', {}),\n    /vault profile is required when multiple vault profiles exist/\n  );\n});\n\ntest('SecretRefResolver errors on unknown ref scheme', async () => {\n  const resolver = new SecretRefResolver(loggerStub, validationStub, null, null, null);\n  await assert.rejects(\n    () => resolver.resolveDeep('ref:unknown:thing', {}),\n    /Unknown secret ref scheme: unknown/\n  );\n});\n\ntest('SecretRefResolver caches identical vault refs within a single resolveDeep call', async () => {\n  const calls = [];\n  const resolver = new SecretRefResolver(\n    loggerStub,\n    validationStub,\n    { async listProfiles() { return [{ name: 'only' }]; } },\n    { async kv2Get(profileName, ref) { calls.push({ profileName, ref }); return `v:${profileName}:${ref}`; } },\n    null\n  );\n\n  const resolved = await resolver.resolveDeep({\n    a: 'ref:vault:kv2:secret/app#k',\n    b: 'ref:vault:kv2:secret/app#k',\n  }, {});\n\n  assert.deepEqual(resolved, { a: 'v:only:secret/app#k', b: 'v:only:secret/app#k' });\n  assert.equal(calls.length, 1);\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1171,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-authorized-keys.test.ts": [
      {
        "file_path": "tests/ssh-authorized-keys.test.ts",
        "start_line": 43,
        "end_line": 47,
        "content": "function sha256FingerprintFromBlobBase64(blob) {\n  const bytes = Buffer.from(blob, 'base64');\n  const hash = crypto.createHash('sha256').update(bytes).digest('base64').replace(/=+$/, '');\n  return `SHA256:${hash}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "sha256FingerprintFromBlobBase64",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 54,
          "qualified_name": "sha256FingerprintFromBlobBase64",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-exec-timeout.test.ts": [
      {
        "file_path": "tests/ssh-exec-timeout.test.ts",
        "start_line": 1,
        "end_line": 63,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst { EventEmitter } = require('node:events');\n\nconst SSHManager = require('../src/managers/SSHManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensurePort(value, fallback) {\n    return value ?? fallback;\n  },\n  ensureString(value) {\n    return String(value);\n  },\n};\n\nconst securityStub = {\n  cleanCommand(value) {\n    return value;\n  },\n};\n\ntest('SSHManager exec settles on hard timeout even if stream never closes', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, null, null, null);\n\n  const previousGrace = process.env.SENTRYFROGG_SSH_EXEC_HARD_GRACE_MS;\n  try {\n    process.env.SENTRYFROGG_SSH_EXEC_HARD_GRACE_MS = '5';\n\n    const stream = new EventEmitter();\n    stream.stderr = new EventEmitter();\n    stream.close = () => {};\n    stream.destroy = () => {};\n\n    const client = {\n      exec(_command, _options, cb) {\n        cb(null, stream);\n      },\n      destroy() {},\n    };\n\n    const result = await manager.exec(client, 'echo hi', {}, { timeout_ms: 20 });\n\n    assert.equal(result.timedOut, true);\n    assert.equal(result.hardTimedOut, true);\n    assert.equal(result.exitCode, null);\n  } finally {\n    if (previousGrace === undefined) {\n      delete process.env.SENTRYFROGG_SSH_EXEC_HARD_GRACE_MS;\n    } else {\n      process.env.SENTRYFROGG_SSH_EXEC_HARD_GRACE_MS = previousGrace;\n    }\n  }\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { EventEmitter } = require('node:events')"
          ],
          "parent_scope": null,
          "estimated_tokens": 394,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-hostkey.test.ts": [
      {
        "file_path": "tests/ssh-hostkey.test.ts",
        "start_line": 29,
        "end_line": 32,
        "content": "function fpSha256(buffer) {\n  const hash = crypto.createHash('sha256').update(buffer).digest('base64');\n  return `SHA256:${hash.replace(/=+$/g, '')}`;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "fpSha256",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 38,
          "qualified_name": "fpSha256",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-resilience.test.ts": [
      {
        "file_path": "tests/ssh-resilience.test.ts",
        "start_line": 1,
        "end_line": 86,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst SSHManager = require('../src/managers/SSHManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensurePort(value, fallback) {\n    return value ?? fallback;\n  },\n  ensureString(value) {\n    return String(value);\n  },\n};\n\nconst securityStub = {\n  cleanCommand(value) {\n    return value;\n  },\n};\n\ntest('SSHManager withClientRetry resets and retries on channel open failure', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, null, null, null);\n\n  let attempts = 0;\n  manager.withClient = async (_profileName, _args, handler) => {\n    attempts += 1;\n    if (attempts === 1) {\n      throw new Error('(SSH) Channel open failure: open failed');\n    }\n    return handler({});\n  };\n\n  let resets = 0;\n  manager.resetProfileConnection = async () => {\n    resets += 1;\n    return { success: true };\n  };\n\n  const result = await manager.withClientRetry('ssh1', {}, async () => 'ok');\n  assert.equal(result, 'ok');\n  assert.equal(attempts, 2);\n  assert.equal(resets, 1);\n});\n\ntest('SSHManager execDetached returns pid and paths', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, null, null, null);\n\n  manager.resolveConnection = async () => ({ connection: {}, profileName: null });\n\n  let received = null;\n  manager.execOnce = async (_connection, command) => {\n    received = command;\n    return {\n      stdout: '4321\\n',\n      stderr: '',\n      exitCode: 0,\n      signal: null,\n      timedOut: false,\n      duration_ms: 1,\n    };\n  };\n\n  const result = await manager.execDetached({\n    command: 'sleep 10',\n    log_path: '/tmp/sentryfrogg-detached.log',\n    pid_path: '/tmp/sentryfrogg-detached.pid',\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.pid, 4321);\n  assert.equal(result.log_path, '/tmp/sentryfrogg-detached.log');\n  assert.equal(result.pid_path, '/tmp/sentryfrogg-detached.pid');\n  assert.ok(received.includes('nohup'));\n  assert.ok(received.includes('/tmp/sentryfrogg-detached.log'));\n  assert.ok(received.includes('/tmp/sentryfrogg-detached.pid'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 560,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-secretref.test.ts": [
      {
        "file_path": "tests/ssh-secretref.test.ts",
        "start_line": 1,
        "end_line": 87,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst SSHManager = require('../src/managers/SSHManager');\nconst SecretRefResolver = require('../src/services/SecretRefResolver');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensurePort(value, fallback) {\n    return value ?? fallback;\n  },\n};\n\nconst securityStub = {\n  cleanCommand(value) {\n    return value;\n  },\n};\n\ntest('SSHManager materializeConnection resolves ref:env password', async (t) => {\n  const previous = process.env.SF_SSH_PASS;\n  process.env.SF_SSH_PASS = 'p@ss';\n\n  t.after(() => {\n    if (previous === undefined) {\n      delete process.env.SF_SSH_PASS;\n    } else {\n      process.env.SF_SSH_PASS = previous;\n    }\n  });\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, { ensureString: (v) => v }, null, null, null);\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, null, null, secretRefResolver);\n\n  const input = { host: '127.0.0.1', username: 'root', password: 'ref:env:SF_SSH_PASS' };\n  const config = await manager.materializeConnection(input, {});\n\n  assert.equal(config.host, '127.0.0.1');\n  assert.equal(config.username, 'root');\n  assert.equal(config.password, 'p@ss');\n  assert.equal(input.password, 'ref:env:SF_SSH_PASS', 'must not mutate input');\n});\n\ntest('SSHManager materializeConnection resolves ref:env private_key and passphrase', async (t) => {\n  const prevKey = process.env.SF_SSH_KEY;\n  const prevPass = process.env.SF_SSH_PASSPHRASE;\n  process.env.SF_SSH_KEY = 'KEYDATA';\n  process.env.SF_SSH_PASSPHRASE = 'unlock';\n\n  t.after(() => {\n    if (prevKey === undefined) {\n      delete process.env.SF_SSH_KEY;\n    } else {\n      process.env.SF_SSH_KEY = prevKey;\n    }\n    if (prevPass === undefined) {\n      delete process.env.SF_SSH_PASSPHRASE;\n    } else {\n      process.env.SF_SSH_PASSPHRASE = prevPass;\n    }\n  });\n\n  const secretRefResolver = new SecretRefResolver(loggerStub, { ensureString: (v) => v }, null, null, null);\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, null, null, secretRefResolver);\n\n  const input = {\n    host: 'example.com',\n    username: 'deploy',\n    private_key: 'ref:env:SF_SSH_KEY',\n    passphrase: 'ref:env:SF_SSH_PASSPHRASE',\n  };\n  const config = await manager.materializeConnection(input, {});\n\n  assert.equal(config.privateKey, 'KEYDATA');\n  assert.equal(config.passphrase, 'unlock');\n  assert.equal(input.private_key, 'ref:env:SF_SSH_KEY', 'must not mutate input');\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 647,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-sftp.test.ts": [
      {
        "file_path": "tests/ssh-sftp.test.ts",
        "start_line": 1,
        "end_line": 194,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs/promises');\nconst path = require('path');\nconst os = require('os');\nconst SSHManager = require('../src/managers/SSHManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  error() {},\n  warn() {},\n  info() {},\n};\n\nconst securityStub = {\n  cleanCommand(value) {\n    return value;\n  },\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return value;\n  },\n  ensurePort(value) {\n    return value ?? 22;\n  },\n};\n\nconst profileServiceStub = () => ({\n  async listProfiles() {\n    return [];\n  },\n  async getProfile() {\n    return { data: {}, secrets: {} };\n  },\n});\n\ntest('sftpUpload rejects when overwrite is false and remote exists', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n  manager.withSftp = async (_args, handler) => handler({\n    stat(_path, cb) {\n      cb(null, { size: 1 });\n    },\n    fastPut(_local, _remote, cb) {\n      cb(null);\n    },\n  });\n\n  await assert.rejects(\n    () => manager.sftpUpload({ local_path: '/tmp/local.txt', remote_path: '/remote.txt', overwrite: false }),\n    /already exists/\n  );\n});\n\ntest('sftpList returns entries for remote path', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n  manager.withSftp = async (_args, handler) => handler({\n    readdir(_path, cb) {\n      cb(null, [\n        { filename: 'file.txt', longname: '-rw', attrs: { size: 10, mode: 0o100644, mtime: 1, atime: 1, isDirectory: () => false } },\n      ]);\n    },\n  });\n\n  const result = await manager.sftpList({ path: '/data' });\n  assert.equal(result.entries.length, 1);\n  assert.equal(result.entries[0].path, '/data/file.txt');\n  assert.equal(result.entries[0].type, 'file');\n});\n\ntest('sftpDownload refuses to overwrite local file by default', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n  manager.withSftp = async (_args, handler) => handler({\n    fastGet(_remote, _local, cb) {\n      cb(null);\n    },\n    stat(_remote, cb) {\n      cb(null, { atime: 1, mtime: 1 });\n    },\n  });\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-sftp-'));\n  const localPath = path.join(tmpDir, 'file.txt');\n  await fs.writeFile(localPath, 'exists');\n\n  await assert.rejects(\n    () => manager.sftpDownload({ remote_path: '/remote/file.txt', local_path: localPath }),\n    /already exists/\n  );\n});\n\ntest('sftpUpload expands ~ in local_path', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-sftp-home-'));\n  const previousHome = process.env.HOME;\n  try {\n    process.env.HOME = tmpDir;\n\n    let capturedLocal = null;\n    manager.withSftp = async (_args, handler) => handler({\n      fastPut(local, _remote, cb) {\n        capturedLocal = local;\n        cb(null);\n      },\n    });\n\n    await manager.sftpUpload({ local_path: '~/local.txt', remote_path: '/remote.txt', overwrite: true });\n    assert.equal(capturedLocal, path.join(tmpDir, 'local.txt'));\n  } finally {\n    if (previousHome === undefined) {\n      delete process.env.HOME;\n    } else {\n      process.env.HOME = previousHome;\n    }\n  }\n});\n\ntest('sftpDownload expands ~ in local_path', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-sftp-home-'));\n  const previousHome = process.env.HOME;\n  try {\n    process.env.HOME = tmpDir;\n\n    let capturedLocal = null;\n    manager.withSftp = async (_args, handler) => handler({\n      fastGet(_remote, local, cb) {\n        capturedLocal = local;\n        fs.writeFile(local, 'downloaded')\n          .then(() => cb(null))\n          .catch((error) => cb(error));\n      },\n    });\n\n    await manager.sftpDownload({ remote_path: '/remote/file.txt', local_path: '~/file.txt', overwrite: true, mkdirs: true });\n    const expected = path.join(tmpDir, 'file.txt');\n    assert.ok(capturedLocal.startsWith(`${expected}.sentryfrogg.tmp-`));\n    assert.equal(await fs.readFile(expected, 'utf8'), 'downloaded');\n  } finally {\n    if (previousHome === undefined) {\n      delete process.env.HOME;\n    } else {\n      process.env.HOME = previousHome;\n    }\n  }\n});\n\ntest('sftpDownload returns success=false when remote is missing and cleans tmp file', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-sftp-missing-'));\n  const localPath = path.join(tmpDir, 'file.txt');\n\n  let capturedTmp = null;\n  manager.withSftp = async (_args, handler) => handler({\n    fastGet(_remote, local, cb) {\n      capturedTmp = local;\n      fs.writeFile(local, 'partial')\n        .then(() => cb({ code: 2, message: 'No such file' }))\n        .catch((error) => cb(error));\n    },\n  });\n\n  const result = await manager.sftpDownload({ remote_path: '/remote/missing.txt', local_path: localPath, overwrite: true, mkdirs: true });\n  assert.equal(result.success, false);\n  assert.equal(result.code, 'ENOENT');\n  await assert.rejects(() => fs.access(localPath), /ENOENT/);\n  assert.ok(capturedTmp);\n  await assert.rejects(() => fs.access(capturedTmp), /ENOENT/);\n});\n\ntest('sftpDownload remote missing keeps existing local file when overwrite=true', async () => {\n  const manager = new SSHManager(loggerStub, securityStub, validationStub, profileServiceStub());\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-sftp-missing-existing-'));\n  const localPath = path.join(tmpDir, 'file.txt');\n  await fs.writeFile(localPath, 'exists');\n\n  manager.withSftp = async (_args, handler) => handler({\n    fastGet(_remote, _local, cb) {\n      cb({ code: 2, message: 'No such file' });\n    },\n  });\n\n  const result = await manager.sftpDownload({ remote_path: '/remote/missing.txt', local_path: localPath, overwrite: true });\n  assert.equal(result.success, false);\n  assert.equal(await fs.readFile(localPath, 'utf8'), 'exists');\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 1561,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/ssh-stream-to-artifact.test.ts": [
      {
        "file_path": "tests/ssh-stream-to-artifact.test.ts",
        "start_line": 35,
        "end_line": 41,
        "content": "function restoreEnv(key, previous) {\n  if (previous === undefined) {\n    delete process.env[key];\n  } else {\n    process.env[key] = previous;\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "restoreEnv",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 36,
          "qualified_name": "restoreEnv",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/state.test.ts": [
      {
        "file_path": "tests/state.test.ts",
        "start_line": 18,
        "end_line": 41,
        "content": "async function withTempStateStore(task) {\n  const baseDir = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-state-'));\n  const prevProfilesDir = process.env.MCP_PROFILES_DIR;\n  const prevStatePath = process.env.MCP_STATE_PATH;\n\n  process.env.MCP_PROFILES_DIR = baseDir;\n  process.env.MCP_STATE_PATH = path.join(baseDir, 'state.json');\n\n  try {\n    await task(baseDir);\n  } finally {\n    if (prevProfilesDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfilesDir;\n    }\n    if (prevStatePath === undefined) {\n      delete process.env.MCP_STATE_PATH;\n    } else {\n      process.env.MCP_STATE_PATH = prevStatePath;\n    }\n    await fs.rm(baseDir, { recursive: true, force: true });\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "withTempStateStore",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 189,
          "qualified_name": "withTempStateStore",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/user-paths.test.ts": [
      {
        "file_path": "tests/user-paths.test.ts",
        "start_line": 1,
        "end_line": 25,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('node:path');\nconst { expandHomePath } = require('../src/utils/userPaths');\n\ntest('expandHomePath expands ~ and leaves other paths intact', async () => {\n  const previousHome = process.env.HOME;\n  try {\n    process.env.HOME = path.join(path.sep, 'tmp', 'sentryfrogg-home');\n\n    assert.equal(expandHomePath('~'), process.env.HOME);\n    assert.equal(expandHomePath('~/id_ed25519'), path.join(process.env.HOME, 'id_ed25519'));\n    assert.equal(expandHomePath('/var/tmp/file'), '/var/tmp/file');\n    assert.equal(expandHomePath('relative/file'), 'relative/file');\n    assert.equal(expandHomePath('~someone/file'), '~someone/file');\n  } finally {\n    if (previousHome === undefined) {\n      delete process.env.HOME;\n    } else {\n      process.env.HOME = previousHome;\n    }\n  }\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [
            "const { expandHomePath } = require('../src/utils/userPaths')"
          ],
          "parent_scope": null,
          "estimated_tokens": 239,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/util.ts": [
      {
        "file_path": "tests/util.ts",
        "start_line": 10,
        "end_line": 24,
        "content": "function startServer(args = [], envOverrides = {}) {\n  const profilesDir = fs.mkdtempSync(join(os.tmpdir(), 'sentryfrogg-mcp-test-'));\n  const proc = spawn('node', ['dist/sentryfrogg_server.js', ...args], {\n    cwd: PROJECT_ROOT,\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: {\n      ...process.env,\n      MCP_PROFILES_DIR: profilesDir,\n      SF_CONTEXT_REPO_ROOT: profilesDir,\n      ...envOverrides,\n    },\n  });\n  proc.__sentryfrogg_profiles_dir = profilesDir;\n  return proc;\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "startServer",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 119,
          "qualified_name": "startServer",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/util.ts",
        "start_line": 26,
        "end_line": 55,
        "content": "function readLine(stream) {\n  return new Promise((resolve, reject) => {\n    let buffer = '';\n    const onData = (chunk) => {\n      buffer += chunk;\n      const idx = buffer.indexOf('\\n');\n      if (idx !== -1) {\n        const line = buffer.slice(0, idx);\n        cleanup();\n        resolve(line);\n      }\n    };\n    const onError = (err) => {\n      cleanup();\n      reject(err);\n    };\n    const onClose = () => {\n      cleanup();\n      reject(new Error('stream closed before newline'));\n    };\n    const cleanup = () => {\n      stream.off('data', onData);\n      stream.off('error', onError);\n      stream.off('close', onClose);\n    };\n    stream.on('data', onData);\n    stream.on('error', onError);\n    stream.on('close', onClose);\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "readLine",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 185,
          "qualified_name": "readLine",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/util.ts",
        "start_line": 57,
        "end_line": 67,
        "content": "async function cleanupProfilesDir(proc) {\n  const dir = proc?.__sentryfrogg_profiles_dir;\n  if (!dir) {\n    return;\n  }\n\n  try {\n    await fsp.rm(dir, { recursive: true, force: true });\n  } catch (error) {\n  }\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "cleanupProfilesDir",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 52,
          "qualified_name": "cleanupProfilesDir",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/util.ts",
        "start_line": 69,
        "end_line": 88,
        "content": "function terminate(proc) {\n  return new Promise((resolve) => {\n    if (proc.exitCode !== null) {\n      return resolve();\n    }\n\n    const killTimer = setTimeout(() => {\n      if (proc.exitCode === null) {\n        proc.kill('SIGKILL');\n      }\n    }, 5000);\n\n    proc.once('exit', () => {\n      clearTimeout(killTimer);\n      cleanupProfilesDir(proc).finally(resolve);\n    });\n\n    proc.kill('SIGTERM');\n  });\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "terminate",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 102,
          "qualified_name": "terminate",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/validation.test.ts": [
      {
        "file_path": "tests/validation.test.ts",
        "start_line": 1,
        "end_line": 39,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst Validation = require('../src/services/Validation');\n\nconst createValidation = () => new Validation({\n  child() {\n    return this;\n  },\n});\n\ntest('ensureString preserves whitespace when trimming disabled', () => {\n  const validation = createValidation();\n  const secret = ' secret surrounded by spaces ';\n\n  assert.strictEqual(validation.ensureString(secret, 'Secret', { trim: false }), secret);\n});\n\ntest('ensureString rejects whitespace-only secret even without trimming', () => {\n  const validation = createValidation();\n\n  assert.throws(() => validation.ensureString('   ', 'Secret', { trim: false }), /must be a non-empty string/);\n});\n\ntest('ensureHeaders normalizes values to strings and drops nulls', () => {\n  const validation = createValidation();\n  const headers = validation.ensureHeaders({\n    Accept: 'application/json',\n    'X-Count': 12,\n    'X-Flag': false,\n    'X-Empty': null,\n  });\n\n  assert.deepEqual(headers, {\n    Accept: 'application/json',\n    'X-Count': '12',\n    'X-Flag': 'false',\n  });\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 280,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/vault-client.test.ts": [
      {
        "file_path": "tests/vault-client.test.ts",
        "start_line": 21,
        "end_line": 29,
        "content": "function profileServiceStub(profile) {\n  return {\n    async getProfile(name, expectedType) {\n      assert.equal(name, profile.name);\n      assert.equal(expectedType, 'vault');\n      return profile;\n    },\n  };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "profileServiceStub",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 52,
          "qualified_name": "profileServiceStub",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      },
      {
        "file_path": "tests/vault-client.test.ts",
        "start_line": 31,
        "end_line": 54,
        "content": "function makeFetchStub(routes) {\n  const calls = [];\n  const fetch = async (url, options) => {\n    calls.push({ url, options });\n    const entry = routes.find((route) => String(url).includes(route.match));\n    if (!entry) {\n      return {\n        ok: false,\n        status: 404,\n        async text() {\n          return JSON.stringify({ errors: ['not found'] });\n        },\n      };\n    }\n    return {\n      ok: entry.status >= 200 && entry.status < 300,\n      status: entry.status,\n      async text() {\n        return JSON.stringify(entry.body);\n      },\n    };\n  };\n  return { fetch, calls };\n}",
        "metadata": {
          "language": "typescript",
          "chunk_type": "Function",
          "symbol_name": "makeFetchStub",
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 148,
          "qualified_name": "makeFetchStub",
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/vault-manager-approle.test.ts": [
      {
        "file_path": "tests/vault-manager-approle.test.ts",
        "start_line": 1,
        "end_line": 139,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst VaultManager = require('../src/managers/VaultManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return value;\n  },\n};\n\ntest('VaultManager profile_upsert stores AppRole creds and skips token lookup', async () => {\n  const calls = { setProfile: [], deleteProfile: 0, sysHealth: 0, tokenLookup: 0 };\n\n  const profileServiceStub = {\n    async getProfile() {\n      const error = new Error('Profile not found');\n      error.code = 'NOT_FOUND';\n      throw error;\n    },\n    async setProfile(name, config) {\n      calls.setProfile.push({ name, config });\n    },\n    async deleteProfile() {\n      calls.deleteProfile += 1;\n    },\n  };\n\n  const vaultClientStub = {\n    async sysHealth() {\n      calls.sysHealth += 1;\n      return { initialized: true, sealed: false };\n    },\n    async tokenLookupSelf() {\n      calls.tokenLookup += 1;\n      return { data: { ttl: 1000 } };\n    },\n  };\n\n  const manager = new VaultManager(loggerStub, validationStub, profileServiceStub, vaultClientStub);\n\n  const result = await manager.handleAction({\n    action: 'profile_upsert',\n    profile_name: 'vault-prod',\n    addr: 'https://vault.example',\n    auth_type: 'approle',\n    role_id: 'role-1',\n    secret_id: 'secret-1',\n    token: null,\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.profile.auth, 'approle');\n\n  assert.equal(calls.sysHealth, 1);\n  assert.equal(calls.tokenLookup, 0);\n  assert.equal(calls.deleteProfile, 0);\n\n  assert.equal(calls.setProfile.length, 1);\n  assert.equal(calls.setProfile[0].name, 'vault-prod');\n  assert.equal(calls.setProfile[0].config.type, 'vault');\n  assert.equal(calls.setProfile[0].config.data.auth_type, 'approle');\n  assert.deepEqual(calls.setProfile[0].config.secrets, {\n    token: null,\n    role_id: 'role-1',\n    secret_id: 'secret-1',\n  });\n});\n\ntest('VaultManager profile_upsert infers approle auth_type', async () => {\n  const calls = { setProfile: [] };\n\n  const profileServiceStub = {\n    async getProfile() {\n      throw new Error('not found');\n    },\n    async setProfile(name, config) {\n      calls.setProfile.push({ name, config });\n    },\n    async deleteProfile() {},\n  };\n\n  const vaultClientStub = {\n    async sysHealth() {\n      return { initialized: true };\n    },\n    async tokenLookupSelf() {\n      throw new Error('should not be called');\n    },\n  };\n\n  const manager = new VaultManager(loggerStub, validationStub, profileServiceStub, vaultClientStub);\n\n  const result = await manager.handleAction({\n    action: 'profile_upsert',\n    profile_name: 'vault-prod',\n    addr: 'https://vault.example',\n    role_id: 'role-1',\n    secret_id: 'secret-1',\n  });\n\n  assert.equal(result.success, true);\n  assert.equal(result.profile.auth, 'approle');\n  assert.equal(calls.setProfile[0].config.data.auth_type, 'approle');\n});\n\ntest('VaultManager profile_upsert rejects token auth without token', async () => {\n  const manager = new VaultManager(loggerStub, validationStub, {\n    async getProfile() {\n      throw new Error('not found');\n    },\n    async setProfile() {},\n    async deleteProfile() {},\n  }, {\n    async sysHealth() {},\n    async tokenLookupSelf() {},\n  });\n\n  await assert.rejects(\n    () => manager.handleAction({\n      action: 'profile_upsert',\n      profile_name: 'vault-prod',\n      addr: 'https://vault.example',\n      auth_type: 'token',\n      token: null,\n    }),\n    /token is required/i\n  );\n});\n\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 895,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/workspace-cleanup.test.ts": [
      {
        "file_path": "tests/workspace-cleanup.test.ts",
        "start_line": 1,
        "end_line": 76,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst WorkspaceManager = require('../src/managers/WorkspaceManager');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\nconst validationStub = {\n  ensureString(value) {\n    return String(value);\n  },\n};\n\ntest('WorkspaceManager cleanup triggers cleanup on runbook and ssh managers', async () => {\n  let runbookCleanups = 0;\n  let sshCleanups = 0;\n\n  const runbookManagerStub = {\n    async cleanup() {\n      runbookCleanups += 1;\n    },\n    async handleAction() {\n      return { success: true };\n    },\n  };\n\n  const sshManagerStub = {\n    async cleanup() {\n      sshCleanups += 1;\n    },\n  };\n\n  const workspaceServiceStub = {\n    summarize() {\n      return { success: true };\n    },\n    suggest() {\n      return { success: true };\n    },\n    diagnose() {\n      return { success: true };\n    },\n    getStoreStatus() {\n      return { success: true };\n    },\n    migrateLegacy() {\n      return { success: true };\n    },\n    getStats() {\n      return { success: true };\n    },\n  };\n\n  const manager = new WorkspaceManager(\n    loggerStub,\n    validationStub,\n    workspaceServiceStub,\n    runbookManagerStub,\n    null,\n    sshManagerStub\n  );\n\n  const result = await manager.handleAction({ action: 'cleanup' });\n  assert.equal(result.success, true);\n  assert.deepEqual(result.cleaned.sort(), ['runbook', 'ssh']);\n  assert.equal(runbookCleanups, 1);\n  assert.equal(sshCleanups, 1);\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 382,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tests/workspace.test.ts": [
      {
        "file_path": "tests/workspace.test.ts",
        "start_line": 1,
        "end_line": 141,
        "content": "// @ts-nocheck\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('node:fs/promises');\nconst path = require('node:path');\nconst os = require('node:os');\nconst WorkspaceService = require('../src/services/WorkspaceService');\n\nconst loggerStub = {\n  child() {\n    return this;\n  },\n  info() {},\n  warn() {},\n  error() {},\n};\n\ntest('WorkspaceService summary returns suggestions', async (t) => {\n  const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), 'sentryfrogg-workspace-'));\n  const prevProfilesDir = process.env.MCP_PROFILES_DIR;\n\n  t.after(async () => {\n    if (prevProfilesDir === undefined) {\n      delete process.env.MCP_PROFILES_DIR;\n    } else {\n      process.env.MCP_PROFILES_DIR = prevProfilesDir;\n    }\n    await fs.rm(tmpRoot, { recursive: true, force: true });\n  });\n\n  process.env.MCP_PROFILES_DIR = tmpRoot;\n\n  const contextService = {\n    async getContext() {\n      return {\n        context: {\n          key: 'ctx',\n          root: tmpRoot,\n          tags: ['k8s', 'git'],\n          project_name: 'demo',\n          target_name: 'prod',\n          updated_at: new Date().toISOString(),\n        },\n      };\n    },\n  };\n\n  const projectResolver = {\n    async resolveContext() {\n      return {\n        projectName: 'demo',\n        targetName: 'prod',\n        project: { description: 'Demo project', repo_root: tmpRoot },\n        target: { ssh_profile: 'demo-ssh' },\n      };\n    },\n  };\n\n  const profileService = {\n    async listProfiles() {\n      return [{ name: 'demo-ssh', type: 'ssh', data: {} }];\n    },\n    hasProfile() {\n      return true;\n    },\n  };\n\n  const runbookService = {\n    async listRunbooks() {\n      return {\n        success: true,\n        runbooks: [\n          { name: 'k8s.diff', tags: ['k8s'], description: 'Diff', source: 'default' },\n        ],\n      };\n    },\n  };\n\n  const capabilityService = {\n    async listCapabilities() {\n      return [\n        {\n          name: 'k8s.diff',\n          intent: 'k8s.diff',\n          when: { tags_any: ['k8s'] },\n          tags: ['k8s'],\n          effects: { kind: 'read' },\n          source: 'default',\n        },\n      ];\n    },\n  };\n\n  const projectService = {\n    async listProjects() {\n      return { success: true, projects: [] };\n    },\n  };\n\n  const aliasService = {\n    getStats() {\n      return { total: 0 };\n    },\n  };\n\n  const presetService = {\n    getStats() {\n      return { total: 0 };\n    },\n  };\n\n  const stateService = {\n    getStats() {\n      return { session_keys: 0, persistent_keys: 0 };\n    },\n  };\n\n  const workspace = new WorkspaceService(\n    loggerStub,\n    contextService,\n    null,\n    projectResolver,\n    profileService,\n    runbookService,\n    capabilityService,\n    projectService,\n    aliasService,\n    presetService,\n    stateService\n  );\n\n  const result = await workspace.summarize({});\n  assert.equal(result.success, true);\n  assert.ok(result.workspace.suggestions.capabilities.some((item) => item.name === 'k8s.diff'));\n  assert.ok(result.workspace.suggestions.runbooks.some((item) => item.name === 'k8s.diff'));\n  assert.ok(result.workspace.actions.intents.some((item) => item.intent === 'k8s.diff'));\n\n  const actionsOnly = await workspace.summarize({ format: 'actions' });\n  assert.equal(actionsOnly.success, true);\n  assert.ok(actionsOnly.actions.intents.some((item) => item.intent === 'k8s.diff'));\n});\n",
        "metadata": {
          "language": "typescript",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 842,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tsconfig.json": [
      {
        "file_path": "tsconfig.json",
        "start_line": 1,
        "end_line": 33,
        "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"moduleResolution\": \"Node\",\n    \"moduleDetection\": \"force\",\n    \"lib\": [\"ES2022\"],\n    \"rootDir\": \".\",\n    \"outDir\": \"dist\",\n    \"declaration\": false,\n    \"sourceMap\": false,\n    \"inlineSources\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"allowJs\": false,\n    \"strict\": false,\n    \"noImplicitAny\": false,\n    \"useUnknownInCatchVariables\": false,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\n    \"sentryfrogg_server.ts\",\n    \"src/**/*.ts\",\n    \"scripts/**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\",\n    \"integration\"\n  ]\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 175,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ],
    "tsconfig.test.json": [
      {
        "file_path": "tsconfig.test.json",
        "start_line": 1,
        "end_line": 18,
        "content": "{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"rootDir\": \".\",\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\n    \"sentryfrogg_server.ts\",\n    \"src/**/*.ts\",\n    \"tests/**/*.ts\",\n    \"integration/**/*.ts\",\n    \"scripts/**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\"\n  ]\n}",
        "metadata": {
          "language": "json",
          "chunk_type": null,
          "symbol_name": null,
          "context_imports": [],
          "parent_scope": null,
          "estimated_tokens": 73,
          "qualified_name": null,
          "documentation": null,
          "tags": [],
          "bundle_tags": [],
          "related_paths": []
        }
      }
    ]
  }
}